/*
 * All software provided below is unsupported and provided as-is, without warranty 
 * of any kind.
 *
 * To the extent possible under law, Red Hat, Inc. has dedicated all copyright
 * to this software to the public domain worldwide, pursuant to the CC0 Public
 * Domain Dedication. This software is distributed without any warranty.
 * See <http://creativecommons.org/publicdomain/zero/1.0/>.
 *
 *----------------------------------------------------------------------------------------
 */

/*
 *  Useage: blktrace_merge <inpfilename> <outfilename>
 *  
 *  cc -o blktrace_merge blktrace_merge.c -std=c99 -lm
 *  cc -o blktrace_merge blktrace_merge.c siglib.c -lm -DSIGLIB
 *
 */

#define VERSION    "06.42-0626-23022024"		/* Fri Feb 23 11:52:39 2024 bubrown */

/* 
 * Author    : bud brown 
 * Maintainer: bud brown
 */
#define MAINTAINER "blackhole.401693@gmail.com"


/* 
 * History:
 *              TBD  : [ ], completed = [x] or none.
 * 11.01.2024 + VER  : [x]  Bump major version 4->6.
 *
 * 02.22.2024 + TBD  : [ ]  The new v6 should be a complete reorg of the data structures.. the constant
 *                          add ons have created a really crappy mish mash of data structures.  The current
 *                          use needs to be analyzed and streamlined to make more sense of how data is 
 *                          captured, and into which fields in which data structures.  Coding additions at
 *                          this point are taking a longer time than they should because of the fractured
 *                          view of the current set of data structures.  In addition, standardize on %12ld,%6ld
 *                          or similar for sector,length combo as debug output etc. is all over the place.
 *                          make allowances for some exceptions such as %12ld,%ld or similar in some debug 
 *                          locations where it might make sense, but honestly this code is all over the place
 *                          with precision.  Alignment of data makes it easier to read and track what's going
 *                          on/wrong and not standarizing on precision contributes to difficulty tracking things.
 *                          Add estimated time to complete and number of events parsed total and per/second undated
 *                          on 10, 15, or 30s fixed boundaries to give feedback the system isn't "hung" Add anti-hang
 *                          detection code triggered when events/second fall belwo threshold or prestage exceeds 
 *                          threshold. Need to change message wording as discarding an orphan event and a discard
 *                          io type might become confused as to whether the orphan is a discard event or vice versa
 * 11.14.2023 + TBD  : [ ]  New io type combinations seen: RA (Read.Ahead) -> NA (None.Ahead), and
 *                                                         RM (Read.Meta ) -> NM (None.Meta )  in 4.18++
 *
 *                           253,11  16  4028403   197.023293650  356549  Q  RA 265392 + 32 [s1-agent]
 *                           253,11  16  4028404   197.023300396  356549  G  RA 265392 + 32 [s1-agent]
 *                           253,11  16  4028407   197.023303764  356549  I  RA 265392 + 32 [s1-agent]
 *                           253,11  16  4028408   197.023312055  356549  D  RA 265392 + 32 [s1-agent]
 *                           253,11  16  4028409   197.023484868  565381  C  RA 265392 + 32 [0]
 *                           253,11  16  4028410   197.023492124     112  C  NA 265392 [0]
 *                           ## 2nd C is RA -> NA   Read.Ahead -> None.Ahead
 *                           253,11  60  1498258   213.075431510 3235044  Q  RM 264976 + 8 [gfs2_quotad]
 *                           253,11  60  1498259   213.075437754 3235044  G  RM 264976 + 8 [gfs2_quotad]
 *                           253,11  60  1498260   213.075439784 3235044  I  RM 264976 + 8 [gfs2_quotad]
 *                           253,11  60  1498261   213.075457874    1181  D  RM 264976 + 8 [kworker/60:1H]
 *                           253,11  60  1498262   213.075593636  544658  C  RM 264976 + 8 [0]
 *                           253,11  60  1498263   213.075647776     377  C  NM 264976 [0]
 *                           ## 2nd C is RM -> NM   Read.Metadata -> None.Metadata
 *                           
 * 06.09.2022 + TBD  : [ ] the added bmerge code to deal with mainio to mainio merging corner cases was *not* added to fmerge_event
 *                         as of right now the issue is only seen with Fmerge followed by Bmerge but not the other way around.  In
 *                         addition this is only being seen in mdraid raid1 mirror code such that dirty io is flushed and arrives
 *                         out of sequence for some reason and the merging happens before insert events but after getrequest events.
 *                         overall, likely may need to add same code to fmerge_event to cover the case of b->f merging.  but will wait.
 *
 * 02.20.2024 + RFE  : [ ]  Track and output dispatch events in per second summary.  Treate as write for purpose of busy if not already
 *                          done so. Need separate stats just for discards, but dance card if full already! what to do what to do
 *
 *
 * 02.20.2024 + RFE  : [ ]  Remove discards from being accumulated in the stats as writes and moved them to their own section of typ_accumulator
 *                          to provide greater visibility to discard actions.  For inflight counter purposes, discards are still treated as 
 *                          writes.  This also doesn't affect heatmaps which also continue to treat discards as writes.
 *
 * 02.21.2024 + RFE  : [ ]  A new discard wrinkle.  The merge code works, except there are cases where a dispatch of a discard requests say
 *                          2048 sector discard, but there are only individual {A,Q} requests for 1762 sectors... the missing sectors are in
 *                          the middle portion of 2048.  Since it cannot find the requests to merge, the code dumps out at the end because of
 *                          missing sectors covered.  Manual verification of the blktrace.txt shows that indeed the missing 256 sectors are
 *                          never referenced except at discard.  Add yet more code that allows this, but generates an error message into the
 *                          merged.txt file complaining about it.
 *
 * 11.01.2024 + RFE  : [ ]  The summary "iostat" output needs to fill-in missing seconds with zero data (which can then be disabled via the
 *                          blktrace_merge.conf file option).
 *                          #SEC@MM:SS|  tot/s    r/s    w/s    d/s|   tkB/s   rkB/s   wkB/s   dkB/s|    avrq  qusz:max |    await:disk |  r_await:disk |  w_await:disk | d_await:disk  ...
 *                          #SEC@-----|-------+------+------+------|--------+-------+-------+-------|--------+-----:----|---------:-----|---------:-----|---------:-----|---------:-----...
 *                          #SEC@00:00|      7      0      7      0|     128       0     128       0|   36.57   1.8   3 |     3.53 100% |     0.00   0% |     3.53 100% |     0.00   0% ...
 *                          >>   00:01 missing (all zeros)
 *                          #SEC@00:02|      5      0      5      0|      24       0      24       0|    9.60   0.0   1 |     0.13  99% |     0.00   0% |     0.13  99% |     0.00   0% ...
 *                          >>   00:03
 *                          >>   00:04
 *                          #SEC@00:05|      8      0      8      0|      86       0      86       0|   21.50   0.9   3 |     3.23 100% |     0.00   0% |     3.23 100% |     0.00   0% ...
 *                          >>   et.al.
 *                          #SEC@00:09|      7      0      7      0|     104       0     104       0|   29.71   1.0   1 |     3.43 100% |     0.00   0% |     3.43 100% |     0.00   0% ...
 *
 * 11.10.2024 + BUG  : [x]  A lot of events associated with kernel write/io barriers are also tagged as EXCEPTION.  Exception events are
 *                          won't be fully processed.  Write IO Barrier events are being flagged because things like 'Q WFS [procname]' with
 *                          no sector,length information wouldn't be matched to an existing io context.  So by flagging as an exception,
 *                          its declared a "known unusual event" that is ok to ignore.  That processing now needs to be removed in that
 *                          write IO (implicit) barrier event sequences is having additional code added to both identify and make best
 *                          effort matching of events to barrier io contexts.  Leaving in the EXCEPTION flagging is conflicting with that
 *                          new logic.
 * 11.02.2024 + RFE  : [x]  Refactor parse_event() so a full parse of the data is performed before examining relationships between the 
 *                          fields and setting flags.  The parse will set flags like "VALID_SECTOR" when parsing a sector number, but
 *                          won't determine if combo's of 128 + 0 means this is an implicit barrier or not.  The code convolutions 
 *                          present for the add-ons over time made the code unwieldy and hard to follow.  Try and condense it into 
 *                          something more readable.
 * 02.20.2024 + BUG  : [x]  The event flow expected merges (M|F) to merge io into existing contexts.  That is not happening for Discards,
 *                          at least discards for mdraid devices.  The stream is A,Q,G {A,Q)... D,C with the D having an entirely different
 *                          size for the starting sector in the first A event.  This creates three different sets of io context: the original
 *                          A,Q,G, the D,C and a set of A,Q events in pre-stage.  Only the second set (D,C) actually get out processed, the
 *                          rest just end up clogging the queues with unmatchable partial io contexts.  So first step is quick workaround, 
 *                          an a flag to ignore all discard type events.  This is a major break of "every event counts", but until a full
 *                          workaround can be added this will allow processing of discard event streams if necessary.  The full workaround
 *                          is, at least on the surface, straight forward: At Dispatch of a Discard, if there is no type,sector,size match
 *                          then repeat looking for a type,sector match where size < dispatch.size.  If found, then search the pre-stage 
 *                          queue for discards with sectors within the range of starting:ending sector per the Dispatch event.  Keep a list.
 *                          If at the end of the scan or pre-stage the list contains the full set of intermediate "missing" pieces, then
 *                          perform an ghost "M"erge event on each io context in the list.  This will move the missing pieces out of the
 *                          pre-stage queue into a known context that then the Dispatch can match against and the code can continue.  The
 *                          issue here is this isn't done until Dispatch time.  And that means we can have 10,000s A,Q disjointed contexts
 *                          sitting in the pre-stage queue for a loooong time waiting for the Dispatch event to take place.  That means the
 *                          pre-stage queue needs to be upgraded to a hash bucket scheme... and instead of a serial check across the whole
 *                          list of pre-stage contexts, the code will have to do a targetted serial sector hopping search.
 * 02.20.2024 + TMP  : [x]  Temporary workaround added using -D flag.  Ignores A,Q,G events for Discard type io.
 * 11.08.2023 + BUG  : [x]  The event state flow assumes Requeues only happen after a dangling Dispatch -- but within 4.18+++  with
 *                          dm-mpath devices you can see Q,I,R,R,R,D,R,D,C,C event flow -- not the Rs without a D prior D event.
 *                          Add creation of, and accounting for "ghost" D events when a Requeue happens without a prior dangling
 *                          D event (aka R == D means event flow is expecting a D not an R, as in D->R and now current event is 
 *                          another R? as in D,R,R or Q,I,R,R ... )
 * 11.07.2023 + RFE  : [x]  guess the number of lines in a file by using average from large files.  Most events are similar in size/
 *                          number of characters so using average is reasonable method.  Also, using bytes read, add %file processed
 *                          --bgn:124147897----------------------------------------- line.
 *
 *                          example #1 : --bgn:227569344----------------------------------------- 14807029052 bytes 65.066009295
 *                          example #2 : 14881329686 
 *
 *                          Add timestamps into the stdout at start and end of file processing and give a summary of bytes, lines, and
 *                          time times plus average chars per line and time per 10,000 lines even if you have to multiple up to get 
 *                          there.
 * 11.07.2023 + BUG  : [x]  most events are assigned to the oldest io context that qualifies for the event.  but this is not true for
 *                          requeues.  much as a 'D' corner-case/look-aside logic was added to choose best choice for outstanding unbalanced
 *                          requeues (I->D->R->I next D goes here not newest io).  Similar logic should be used for Requeues, a requeue
 *                          goes to the NEWEST io context than can accept one.  Add similar lookaside logic as added for D for R events.
 *                          Note, this only applies to "best match" corner cases -- that is to places where there are multiple io to 
 *                          the same sector:length and io type that exist at the same time.  The D and now R are corner cases within
 *                          this corner case.
 * 10.27.2023 + RFE  : [x]  upgrade the duplicate error messages from %W to %E.
 * 10.23.2023 + RFE  : [x]  work on quieting down the output of parsing through 1-4 -q stepdowns.  With goal being a %complete at -qqq
 *                          and total silence at -qqqq except for the initial header stuff (and -qqqqq removing that last bit of stuff).
 *                          See additional footnote info added to flag_quiet.
 * 10.23.2023 + RFE  : [x]  add base_seconds to config file, this is offset of seconds to display in SEC info block mm:ss to help with
 *                          ability to manually align with iostat data which is using wall clock time.
 * 03.15.2023 + RFE  : [x]  add flag_shortform to remove seek, description and later columns from merged.txt output file to shorten line
 * 03.06.2023 + BUG  : [x]  missing *1000. for d2c first/last times in secs/summary output result in await in per io being 100% but being
 *                          near zero in secs/summary lines.  Fixed.
 * 12.16.2022 + RFE  : [x]  changed tot.avg to display actual number of io vs hardcoded 1 - yes, the average is per 1 io, but we really
 *                          should be able to see how much io was present for that tot.avg line.
 * 12.16.2022 + RFE  : [x]  at every "bad" exit() sub _internal_exit() and output current maintainer to contact.
 * 12.16.2022 + BUG  : [x]  wr.max is output as wrong value on 1s boundaries:
 *                          #SEC: dTime(sec)         Q2I(ms)      Q2D(ms)      D2C(ms)      Q2C(ms;await) io_cnt avrq          KiB  reQ:       seeks prog flt
 *                          #SEC:    80 totals        62.003       71.543     4261.917 % 98      4333.460    219   30         3288    0:  1096775656    0   0
 *                          #SEC:    80 tot.avg        0.283        0.327       19.461 % 98        19.787      1   30           15    0:     5008108
 *                          #SEC:    80 writes         0.283        0.327     4261.917 % 98      4333.460    219   30         3288    0
 *                          #SEC:    80 wr.avg         0.283        0.327       19.461 % 98        19.787    219   30         3288    0
 *                          #SEC:    80 wr.max        51.741       51.753        4.274 %  7        56.028
 *                                                                              ^^^^^^ cannot have max of 4ms and average of 19ms (19 is correct)
 *                          Individual events showing D2C times of 55+ms!  This problem arises because we attempt to compute the max D2C
 *                          time at statistics output time of max Q2C - max Q2D, ... but that max values are not necessarily for the same io
 *                          as in this case.  This is done because of Requeues and the optional D2D column.  We need to push this back to the
 *                          individual io and caclculate/capture the actual max write D2C the two different ways and then allow stats to choose
 *                          which one of those max per io to report (D2C using last D or D2C using first D depending on whether D2D is separate
 *                          column) vs attempting to fudge it at the summary block time using the current logic of:
 *                              if (flag_negrequeue == 0)
 *                                  d2c = ((device_lvm==0)?( data->dt_max_writes.complete.time - data->dt_max_writes.dispatch<_last>.time):0.0);
 *                              else
 *                                  d2c = ((device_lvm==0)?( data->dt_max_writes.complete.time - data->dt_max_writes.dispatch_first.time):0.0);
  *                         Whereas other values are computed per io and then captured in the dt_max_ blocks, so at summary time they are just
 *                          simply pulled out:
 *                                  q2i = data->dt_max_writes.insert.time;
 *                                  q2d = data->dt_max_writes.dispatch.time;
 *                          Change the summary block to include both D2C maximums calculated on per io basis in order to get a "real" max await
 *                          value and fix this bug.
 * 10.18.2022 + BUG  : [x]  x-splits are creating io greater than the MAX_IO_SIZE (2048) if it starts with 4096 io and only removes
 *                          1024 sectors in primary/1st and 3072 in 2nd/split.  The io length is reset to 512 from 3072 resulting 
 *                          in the events getting lost as they no longer will match later events.  Up the MAX_IO_SIZE from 1M to 4M 
 *                          8192 sectors and also add a %Error event if the default size is applied as a heads-up to review the data
 *                          further.
 * 10.18.2022 + BUG  : [x]  x-splits calculated the evt_length (length of original io) correctly in one place but incorrectly in a 2nd
 *                          using (end_sector - bgn_sector) vs (end_sector - bgn_sector)+1.  This resulted in split io not being matched
 *                          off the pre-stage queue so orphaned there which in turn resulted in the final io of G,C,D being marked as 
 *                          a [GHOST] in that A|Q events were not present (and G event time is used as first.time vs the proper A|Q 
 *                          time.  Fixed and this seems to correct all but a few issues of pre-staged io getting stuck.
 * 10.12.2022 + BUG  : [x]  x360 has A,D,C event sequence, but because there is no Q event when a D happens, D gets assigned to 'first_time'
 *                          which it should not!  This will make first_time to D always be zero vs the true A2D value needed.
 *                           8,16   4        1     0.000000000   253  A   W 1653056 + 8 <- (253,0) 1653056
 *                           8,16   4        2     0.000001220   253  D  WS 1653056 + 8 [kworker/4:1H]
 *                           8,16   1        2     0.000298441  6665  C  WS 1653056 + 8 [0]
 *
 *                           #PS|Prg:Flt   Queue(s)     Q2I(ms)   Q2D(ms)       D2C(ms)            Q2C(ms)
 *                           #--|---:--- ------------- -------- ------------- -------------+---- ------------- 
 *                             1|   0:  1   0.000001220   0.0000      0.000000      0.297221 %100      0.297221
 *                                          ^^^^^^^^^^^ is D event not A event!
 *                                   Q      0.000001220             D  0.000001220  C  0.000298441
 *                             dtime            Q2     0.000000000 Q2D 0.000000000 Q2C  0.000297221 D2C  0.000297221
 *                                                                     ^^^^^^^^^^^ which results in a Q2D of zero in all cases
 *
 *                          This is another result of the io being marked GHOST (lack of expected prior events -- in this case its missing
 *                          the "required" Q event.  Really don't want to reduce/remove GHOST in this case as the expected Q event is indeed
 *                          missing. So at GHOST assignment, if we are at I|D .AND. 'A' event is present, do not overwrite first_time field
 *                          as set by 'A'.
 *
 *                          Also as part of this whole missing required 'Q' event is that one event is created for 'A' event, but then 
 *                          the search logic fails to find a match for the 'D' event because it cannot find one that has the required
 *                          requisite/required events so then creates a 2nd, GHOST, io for the 'D' (and then 'C') events so the staging
 *                          queue gets clogged with tons of orphan 'A' events.  So the basic find routine needs to change and have a 
 *                          second pass that allows A|Q or both in the basic match/find io context logic... if conf_x360_policy is 1.
 *                          This is getting complicated as the logic is built around the requirement for a Q event.
 *
 *                          The problem is if we just match on A|Q we *could*, in normal x86 blktrace, match on the wrong io context
 *                          that then has the 'Q' for it show up.  But as time goes on and we don't see any Q events at all, then the
 *                          logic to allow matching A|Q gains more confidence that it is correct.  So the logic needs to be very tentative
 *                          and log at least a %Warning when it is matching on io context with A but no Q.  But after say 10? 100? completing
 *                          io and we're only seeing A,D,C event sequence and never any Q events then we can stop the %Warnings.  This is
 *                          going to be messy so add another setting to conf_x360_polic (0=previous default need Q events, 1=allow A,D,C
 *                          matching w/%Warnings, and 2=allow A,D,C matching without warnings.  Also need a minimum io completion count whereby
 *                          warnings are disabled via conf_x360_completions number.
 *
 *                          Furthermore, 'D' events assume an 'G' or 'I' event moved the staged io to main io queue.  But that isn't the case
 *                          here, so we need to modify the search for matching events to go back and look at the staging queue.  This is wicked
 *                          dangerous. As we can have a new duplicate io incoming with A,Q and then an orphan io 'D' (i.e. this is near the
 *                          top of the blktrace data and this 'D' is for an older io not in blktrace).  So 'D' matches the A,Q event and bam,
 *                          we're broken -- later G,I,D,C events for the A,Q won't find a match. So if we do start matching A,D,C event sequences
 *                          then we need to set a state flage that tracks the number of times we're doing that.  And if/when a 'Q' event shows up
 *                          and we've done the above, then we have a couple choices -- if the number of such events are low, issue an error and 
 *                          force x360_policy to 0 to disallow further such matching, or if too high just fatal and exit with request to set
 *                          the x360_policy in local .conf file to zero to prevent the issue ... maybe open/add or create such a .conf file.
 *
 *                          So, added search_staged_x360() routine, that if the state and event qualifies, the staging queue is searched and
 *                          if a match found, it is moved to this mainio queue and used.  This seems to have solved the issue.
 *
 *
 *
 * 10.12.2022 + RFE  : [x]  x360 architectures do not provide the expected 'Q' event -- there is an abbreviated A,D,C event sequence which
 *                          ends up labeled as [GHOST] because of the lack of a Q event.  Verify that GHOSTS use A|Q for Q2C time and also
 *                          change the calculation of dtime at output to utilize an 'A' event if one is present (but not the expected/required
 *                          queue as in other architectures).  This is assuming the remap and queue events happen at the same time if Q is missing.
 *                          This change is mostly a workaround for now until its given more thought.  Also GHOST io do not participate in io
 *                          stats, but in this one case for x360 they should.
 * 10.06.2022 + RFE  : [x]  add barrier count to summary stats similar to requeue and sleep counts, report same within per second and finally
 *                          io stats output.
 * 10.06.2022 + ENH  : [x]  enhancement, with tons of overlapping io barriers, the GSegNo assert is failing and crashing the program, I
 *                          think this is because there are tons of io barriers that are all 0,0 sect:len io and the io context matching
 *                          gets confused or there is an extra G event or something so for that one assert added detection and further
 *                          debug output to understand the specific cause better. Turns out this was on identical read io whereby events
 *                          due to various code paths put G events in one duplicate read, but the I,D events in a different duplicate, then
 *                          the 2nd G event arrives but the first duplicate is disqualified as it already has a G event and the 2nd duplicate
 *                          is disqualified as it has I,D events which occur after G -- so it returned 1st found and assert() fails with
 *                          G event already present. Change logic to care about certain optional events, like G, which if present make 
 *                          a search for io ctx for I events choose the one with the optional G event already present.  This only is an issue
 *                          when there are duplicate io present, which should be rare.
 * 10.06.2022 + RFE  : [x]  detect new barrier syntax and add a trailing label of [Barrier] to the output line.  One of the main issues with
 *                          multiple overlapping barriers is that there is no reasonable method of matching the different event streams to
 *                          just one specific barrier, so it just first match.  In this case, this is the typical series for a io barrier
 *                          within the latest blktrace.txt output:
 *                            8,80   3       10     0.003882718 91168  A FWS 0 + 0 <- (253,4) 0   <== note there is a possible blktrace bug here.
 *                            8,80   3       11     0.003883318 91168  Q FWS [kworker/3:91]
 *                            8,80   3       12     0.003887018 91168  G FWS [kworker/3:91]
 *                            8,80   3       13     0.003887318 91168  I FWS [kworker/3:91]
 *                            :
 *                            8,80   3       14     0.005803528     0  C  WS 1610635608 + 16 [0]
 *
 *                          any io which has an explicit length of sect:len of has ioflags set to include IS_IOBARRIER flag.
 *                          bug: blktrace for a while incorrectly specified the target device at 'A' time which created an orpan
 *                               'A' event for a different device, aka:
 *                                   8,3    2       14     0.530536705  2645  A FWS 0 + 0 <- (253,10) 0 <----- this! ------------+
 *                                   8,0    2       15     0.530537205  2645  Q FWS [jbd2/dm-10-8]
 *                                   8,0    2       16     0.530538005  2645  G FWS [jbd2/dm-10-8]
 *                                   8,0    2       17     0.530538605  2645  I FWS [jbd2/dm-10-8]
 *                                   8,0    0        1     0.531892926     0  C  WS 0 [0]  <---------- this is a completion of --+
 *                               note that the 'A' event maps to 8,3 and there is no other 'A' event that maps from
 *                               8,3 to 8,0 because that mapping is built into this one 'A' event -- it just tags the
 *                               wrong target 8,3 device instead of 8,0.  So this change won't help in that particular case.
 *                               The barrier detect code is added to both 'A' and 'Q' events, but requires explicit sect:len
 *                               0:0 values be specified like in the above 'A' events.
 *
 * 10.06.2022 + BUG  : [x]  new barrier syntax is detected as overlapping io, but its not as its sector 0, length of 0.  Remove such
 *                          io from being declared as overlapping io as barriers typically will/can overlap, but they don't perform
 *                          any real data movement.
 *                           32|  46: 32   0.072156149   -.----      -.------     -.------- % --     13.030663   3   104275 FWS     0              0
 *                          %W[15822]-overlapping io in scheduler detected W:00000000.000000 @  0.072156149
 *
 *                          NOTE: the warning is inhibited if sect:len fields are zero whether by explicit setting of values or from
 *                          lack of values -- in either case its inhibited to mark such io as overlapping io.  Moreover, if the code
 *                          inhibits the setting of overlapping io due to sect:len = 0:0, then it force clears the flags if somehow
 *                          they were previously set.  Again this happens regardless of whether the fields were explicitly set to 
 *                          0:0 or where just default values.  Some barrier syntax only specifies 1 zero value and others supply none.

 * 07.12.2022 + RFE  : [x]  add staged io count into main output file, staged io is io that is present and so should be counted as
 *                          inProgress, but hasn't reached the point whereby it can so be counted (as opposed to be merged and therefore
 *                          not affecting the current inProgress count).  But its clear with 4.18 that knowing how much is building up
 *                          in the staged queue is important. Cap it at 999 though, but still this means we need 4 more characters on
 *                          an already very crowded line.  Reduce precision somewhere to get 4 char positions back.
 * 07.12.2022 + BUG  : [x]  prmtyp is unsigned char (enum) %d value not %c, find and eliminate all printfs that use %c for prmtyp.
 * 07.11.2022 + RFE  : [x], any time best_match() finds to qualified io and uses timestamp as tied breaker, then this is an overlapping
 *                          io, especially if at C time both have D events meaning they were both outstanding to storage at the same time.
 *                          So, if best_match() both qualify and both have D events (or are about to get D events), then flag both io as
 *                          overlapping io.  At completed io output time, if this flag is set issue a %Warning event for reads and an %Error
 *                          event for writes. Add SAMIOSCHED and SAMEIODRIVR flags in io->ioflags.
 * 07.11.2022 + BUG  : [x] found bug in best_match() I,D,C,R logic -- missing {} would allow else clauses to be associated with the
 *                         wrong if statements. 
 * 07.11.2022 + BUG  : [X] on 4.18 you can have double D and C events for the same io?  Isn't this logic already present? Maybe not
 *                         for overlapping D/C though? D due to Requeue and C due to there are often multiple C events for a single
 *                         io in some previous cases (where there is a C per bio plus a C for the whole IO).  It appears this was due
 *                         to the above bug in best_match(), fixed best match and it no longer is exiting upon inFlight > inProgress.
 * 07.11.2022 + RFE  : [x] suddenly started seeing 'm' events in blkparse output.  These turn out to be message events and should
 *                         always have an io type of N (none).  From blkparse_fmt.c from git:
 *                         case 'm':       /+ Message -/
 *                                  fprintf(ofp, "%*s\n", pdu_len, pdu_buf);
 *                                  break;
 *                         Examples:
 *                           8,0    3        5     0.000036877  1066  D  WS 45043728 + 4 [md2_raid1]
 *                           8,0    3        6     0.000154364     0  C  WS 45043728 + 4 [0]
 *                           8,0    3        0     0.000162443     0  m   N cfq1066SN / complete rqnoidle 1
 *                           8,0    3        0     0.000164859     0  m   N cfq1066SN / set_slice=100
 *                           8,0    3        0     0.000167496     0  m   N cfq1066SN / arm_idle: 8 group_idle: 0
 *                           8,0    3        0     0.000168013     0  m   N cfq schedule dispatch
 *                           8,0    8        1     0.000186949  1066  A FWFS 45043720 + 1 <- (8,5) 8
 *
 *                         Adding a 'message_event()' routine that will validate N io type, then just silently discard.
 *
 * xx.xx.2022
 * 06.09.2022 + bug  : [x] See FN.102 and https://bugzilla.redhat.com/show_bug.cgi?id=2095524
 *                          blktrace: remAp events specify wrong target device
 *
 *                         Track down the bug in the blktrace package wrt remap event output from same.  The remaps are now
 *                         always showing remap is to base (non-partitioned) device even when that is not true.  That is
 *                         output is not accurate.
 *                                    +---- this should be '7' as next remap is same sector remap
 *                                    V
 *                         08897    8,0    1     8148    10.492196176 28649  A  RA 16037566464 + 4096 <- (253,9) 16037564416
 *                         08897    8,0    1     8149    10.492196918 28649  A  RA 38965301248 + 4096 <- (8,7) 16037566464
 *                         This investigation is outside of this program's scope. [6/9/22] Ditto the following from case SF03115832
 *                             +----- this should be '21' as next remap is same sector remap from 8,21
 *                             V
 *                           8,16   7      389     1.013926459  1167  A   W 1449157120 + 8 <- (9,2) 1448892928
 *                           8,16   7      400     1.013984003  1167  A   W 1494200832 + 8 <- (8,21) 1449157120
 *                         **NOTE** these are 'harmless' as the 2nd remAp event creates a new io context.  The down side
 *                         is that 10s of thousands of 'A' only context end up trapped on the staged queue.
 *
 *                         Added workaround but had to really amp up the lines/time limits on a busy system for the fuzzy
 *                         remap matching logic.  Improved debug output including notification of skipped fuzzy matches.
 *                         Added -M option to turn off fuzzy matching, but its on by default atm.  Added a new evtflags
 *                         EVTFLG_REMAPSKIP -- if a fuzzy match is found **except** for line/time limits, then this flag
 *                         is added to the io context.  This then inhibits complaining about a fuzzy match later one for
 *                         a rewrite or reread from the same sector.  The current fuzzy limits are 5000 lines and 100ms
 *                         and that seems to satisfy the mdraid raid1/mirror io being issued.  I'm surprised that remapping
 *                         between layers is taking as long as it does.  But getting fuzzy matches into the mix -- with that
 *                         large of a delay between remapping -- gets tallied back into Q2C time.  80-100ms of remap time is
 *                         not insignificant!
 *
 * 06.09.2022 + bug  : [x] the normal case is a merge is between an io context on the staged queue vs one on the mainio queue.
 *                         however, there is a corner case of Front/Back merges on the same set of io such that the first merge
 *                         happens normally between a staged/mainio io, but then that merge fills a hole and upon insert of the
 *                         another io into the queue it detects a merge -- and that merge is between io that are both on the mainio
 *                         queue.  Change the logic to perform a secondary check of the mainio queue to see if there is a matching
 *                         io within a given timelimit and if so merge two mainio into 1.
 * 05.27.2022 + rfe  : [x] if orphan info messages are being output, ensure the header has already been pushed out first. The
 *                         header is only pushed after the first event so we can detect things like nvme and other types of
 *                         devices that affect what is included in the key header.
 * 05.27.2022 + bug  : [x] Unbounded internal staging queue growth is slowing down the merges, find out why. Appears that new 
 *                         blktrace utility remAp syntax is present?
 *                         08897    8,0    1     8148    10.492196176 28649  A  RA 16037566464 + 4096 <- (253,9) 16037564416     
 *                         08897    8,0    1     8149    10.492196918 28649  A  RA 38965301248 + 4096 <- (8,7) 16037566464       
 *                         Prior code had maj,min of the event match the target so in the past was:
 *                         08897    8,7    1     8148    10.492196176 28649  A  RA 16037566464 + 4096 <- (253,9) 16037564416     
 *                         08897    8,0    1     8149    10.492196918 28649  A  RA 38965301248 + 4096 <- (8,7) 16037566464       
 *                         So... in normal output (2nd set above) its clear the 2nd remap is 8,7 -> 8,0.  But in the "new" 
 *                         blktrace utility output the 253,9 says its remaping to 8,0 when it really is mapping to 8,7.  This
 *                         might be an overt change in blktrace or a bug that was later fixed (or newly introduced).  Either
 *                         way the output of blktrace is no longer as sane as it once was and we need to add fuzzy logic to 
 *                         remap events... if we're remapping from an maj,min that covers the current device (8,0->8,15 in this
 *                         case), then check to see if there is an merged io data structure for the main 8,0 device that had
 *                         a previous remap from dm or other space whose sector lba matches this event's remap from sector lba
 *                         and, as sanity, that prior event was "recent" in terms of time and line number.  Gawd I hope this
 *                         was a bug that got fixed in blktrace utility output! The new code is saying 253,9 was remapped to 8,0
 *                         when in fact it was remapped from 253,9 to 8,7!  With the new event stream out of blktrace utility
 *                         you cannot clearly/accurately detect the target of the remap.
 * 05.27.2022 + rfe  : [x] Update annotation header and information as not all fields seem to have header coverage
 * 04.15.2022 + rfe  : [x] Add tracking for all remap (A) events from:to and read/write cnt,sectors to be output at SUM time.
 * 			   note: we don't sort the output atm, its just whatever was encountered first etc.
 * 04.07.2022 + rfe  : [x] Change xx.avg per second output, currently:
 *                         #SEC:     0 writes         0.311        0.313    39964.582 % 99     40148.455    587 1018       299072    0
 *                         #SEC:     0 wr.avg         0.311        0.313       68.083 % 99        68.396      1 1018          509    0
 *                         but the wr.avg of reports io as 1 and KiB xfered as what was xferred, on average, per 1 io.  While factual
 *                         this is hiding important details that we then need to look at total 'writes' line to see but then loose the 
 *                         average timing values.  Output full io cound and total KiB in xx.avg lines as that is more useful.  We know
 *                         the average is per 1 io and the avg Kib is just sectors/2 so nothing is really lost going back to totals for
 *                         those two columns.

 * 03.25.2022 + rfe  : [ ] See notes "Orphan Barriers" at end of this file.  A WS 0 [0] end up not matched to FWS 0:0 [...] as
 *                         1) there is no sector supplied in C WS 0 [0], but we should allow infering a 0 length for sector 0 in this case
 *                         2) the WS != FWS available from the event stream
 *                         3) the original FWS was a mapping event from 253,10 to 8,3 **BUT** there is no companion
 *                            mapping of 8,3 to 8,0 within the event stream.  The first we find is the Q FWS with no sector
 *                            and no length.  We may need yet another special case that tries a different match on Q events
 *                            with no sector:lenght to a same major, different partition A event of 0:0 and same FWS... so
 *                            only FWS events.  **OR** special logic for C WS 0:[] events to look for Q events with no 
 *                            specified sector or length -- not C WS have been seen as "C WS [0]", "C WS 0+0 [0]", etc.
 *                            so need to 'generalize' an exception for C events.  Allow matching of sector:0 -> none|0 and
 *                            length:0|<none> -> none|0.  AND WS to FWS but only if 0:0 (sector 0, no length aka no data 
 *                            will actually be moved by this command.  
 *                           8,3    2       14     0.530536705  2645  A FWS 0 + 0 <- (253,10) 0 <----- this! ------------+
 *                           8,0    2       15     0.530537205  2645  Q FWS [jbd2/dm-10-8]
 *                           8,0    2       16     0.530538005  2645  G FWS [jbd2/dm-10-8]
 *                           8,0    2       17     0.530538605  2645  I FWS [jbd2/dm-10-8]
 *                           8,0    0        1     0.531892926     0  C  WS 0 [0]  <---------- this is a completion of --+
 *                     All of that is so the barrier is output in its proper place and we don't accumulate cruft in the 
 *                     active queue.  Note in this case the 'I' should have transferred this event from the pre-stage to 
 *                     active queue.  There is no 'D' event for barriers, or at least there does not have to be one output...
 *                     there could be one in certain kernels.  So. many. special. cases. here.
 * 02.28.2022 + rfe  : [ ] upon G that is matched to an event with SPCFLG_XPARENT2, verify that the
 *                     size of that event matches this size and if not we will need to modify the
 *                     parent (this should only happen on the 1st split!).  But search may not find
 *                     the io because G has a definitive size... for example we guess that 512 is being
 *                     used as the split size but it turns out to be 128 -- the G LBA+128 won't match
 *                     the X LBA+{512} and we're left in limbo -- a 2nd search would then be needed to 
 *                     see if we can find an lba match but not a size match, verify that its an XPARENT2
 *                     and then go from there.  All because X split type #2 does not provide an insight
 *                     into the split size.
 * 02.28.2022 + rfe  : [x] increase heatmap size as was getting messages the blktrace sector number exceeded
 *                     heatmap max, now default is:
 *                     max disk size supported    4398046511104 (sectors)          8,388,608GiB or 8+TiB vs just 1TB before.
 * 02.28.2022 + bug  : [ ] another X split event issue.  Prior splits were cascading:
 *                     Q/A 400 => Split 300 (leaving 100 in original Q/A)
 *                                          => Split 200 (leave 100 in the above split)
 *                                                       => Split 100 (leave 100 in the above split)
 *                     So in above 4 io, the original Q/A with 100, and three splits with 100 each.
 *                     But now the splits are linear and deplete the original Q/A in some cases:
 *                     Q/A 400 => Split 100 using starting LBA of 400
 *                                Split 100 using adjusted LBA of original Q/A
 *                                Split 100 using adjusted LBA of original Q/A
 *                                Split 100 using adjusted LBA of original Q/A
 *                     So the original Q/A could become fully depleted with 4 splits or might have some residual left over
 *                     at an adjusted LBA after each LBA pulls out some sectors.  Very different from the cacading splits 
 *                     above.  
 *
 *                     Need to support both models. So if the split has the lba matching the Q/A, update the Q/A's lba by the size
 *                     of the split.  2nd issue with this is prior splits had the size of the split in the event, this 348 kernel does
 *                     not, the X split has the starting LBA and then some other offset LBA... but the original Q/A does not have this
 *                     so the first split has no size until the following G event.  Fake it under these circumstances and the first 
 *                     split is set to 512 if original Q/A size > 512.
 *
 *                     Add new members to io, original lba/size and split offset lba specifically for the 348 style events.
 * 03.25.2022 + rfe  : change orpan complete event message which can be warning or error to be a warning only on "barrier" io
 *                     if the io is a barrier.  Barrier io on some kernel versions just pop up as C WS 0 [0] with sector 0, implied length 0.
 * 02.28.2022 + bug  : in getreq_event, events were being flagged as filtered off due to lack of secton+size 
 *                     which was incorrect -- event has both lba+length... the issue was when the new kernel version barrier
 *                     code was added it didn't change the else logic which then falsely flagged any non-barrier
 *                     io as non-io/missing lba|sector.
 * 02.28.2022 + bug  : if a X split happens against a non-existing io early in the input file it
 *                     assert() fails: 11595: split_event: Assertion `staged != NULL' failed.
 *                     because it cannot find the original event on the staged queue.  Add "standard"
 *                     code about that being ok if we're early in the input file and, for now,
 *                     toss the whole X event.  Eventually we should allow the creation of the split off
 *                     secondary event if at all possible as splits are 1:n and can end up creating 16, 
 *                     32, or more io from an original.
 * 02.21.2022 + rfe  : tweak compact header a bit more.
 * 01.31.2022 + rfe  : a fix in recent kernels changed the X splits so they had the proper sequencing as 
 *                     expected.  So we need to differentiate between splits prior to 4.18
 *                     which failed to have C and other events and 4.18+ and later which should
 *                     have everything. {ed: think this will require dead list use and recovery
 *                     from same?} Try tracking outstanding io with X events much like flight
 *                     counts, and if X outstanding io on staged exceeds some max number, assume
 *                     its a prior to recent kernel'ism (post 4.18) and flip a flag to allow the 1 time garbage
 *                     collection and by passing X events for matching on staged queue... but that
 *                     still is too dangerous in that I can have Q sector 1234 10 times on the
 *                     staged queue before this logic detects "oh, X splits have no C events" by
 *                     which time its too late.  So maybe moved them to the deadio list first and
 *                     then try staged and if no match, try again on the deadio list, and if a match
 *                     stop putting io on the deadio list?  Or just add a flag for now that toggles
 *                     4.18+'ism behavior related to X split events.  That's the most direct method
 *                     but requires the user to have knowledge.  If not set, then collect the number
 *                     of X splits that would have been matched, but aren't.  Still this *will* clutter
 *                     up the staged queue list with dangling X splits and slow processing down. Ok,
 *                     how about this.  We're skipping matches *if* XPARENT is set to avoid matching
 *                     on dangling X events.. but if then no match is found, allow the XPARENT to be
 *                     used as a match.  This still can have issues on blktrace prior to 4.18+ but we
 *                     can force the behavior one way or another with an explicit flag. -X=4.18(-) behavior
 *                     -XX means 4.18+ and later behavior and none means the above/best guess?.
 *
 * 01.21.2022 + bug  : at complete time, don't blindly --inFlight counter because the io may not
 *                     have had a D event... and no D event, no ++inFlight counter.
 * 01.21.2022 + rfe  : change error to warning when we detect different nvme 259,minor numbers in
 *                     same io stream.  This has been an error issue in prior event streams and we
 *                     cannot verify ,0 and ,1 are two different devices or the same device with 
 *                     partitions.  So until that can be resolved in terms of verification, issue
 *                     warning when that is detected.
 * 01.21.2022 + bug  : 4.18 device is ending up with negative summary of D2C and I2C when there are 
 *                     missing I or D events, likely something not initialized -- need to find and fix.
 *                     Remove dependency on state.device_nvme as this implies a give event sequent that
 *                     is not likely consistent across different kernels.  Instead, simplistically rely
 *                     on event.<type>.line not being 0 (LINENUM_UNKNOWN).  In all other cases there
 *                     should be a value present.
 * 01.21.2022 + rfe  : When there is a bug in In-Flight count tracking, when the count exceeds -1000,
 *                     then clamp to -999.
 * 01.19.2022 + bug  : At some point with X-splits on LVM C events stop.  Redo completion logic for 
 *                     when there is no match on mainio but a match is found on staged -- which implies
 *                     LV since they don't have I or D events.  In this case we have to find all IO matches
 *                     and if there is a both an X and Q event matches, with Q being later and X split level
 *                     being high, then choose Q and not X and complain about the whole thing with dump of the
 *                     full backtrace of X-splits.
 *
 *                     253,470 117        2     0.000908070 1305925  Q  RA 3427587104 + 128 [postgres]
 *                     253,470 117        3     0.000910162 1305925  X  RA 3427587104 / 3427587200 [postgres]
 *                     
 *                     253,470 117       27     0.001298067 1305925  C  RA 3427587200 + 32 [0]
 *                     
 *                     And 2 X
 *                     
 *                     253,470  5    32112    41.314900259 1349295  Q  RA 3671548864 + 256 [postgres]
 *                     253,470  5    32114    41.314921177 1349295  X  RA 3671548864 / 3671548928 [postgres]
 *                     253,470  5    32115    41.314942774 1349295  X  RA 3671548928 / 3671549056 [postgres]
 *                     
 *                     253,470  5    32141    41.315793274 1349295  C  RA 3671549056 + 64 [0]
 *                     
 *                     And 3 X
 *                     
 *                     253,470  5    32320    41.321796520 1349295  Q  RA 3671560128 + 352 [postgres]
 *                     253,470  5    32321    41.321805824 1349295  X  RA 3671560128 / 3671560192 [postgres]
 *                     253,470  5    32322    41.321818815 1349295  X  RA 3671560192 / 3671560320 [postgres]
 *                     253,470  5    32323    41.321834643 1349295  X  RA 3671560320 / 3671560448 [postgres]
 *                     
 *                     253,470  5    32344    41.322710758 1349295  C  RA 3671560448 + 32 [0]
 *
 *                     And...
 *                     253,470 60    38781    42.635500913 1305925  Q   W 3429478432 + 800 [postgres]
 *                     253,470 60    38782    42.641351643 1305925  X   W 3429478432 / 3429478528 [postgres]
 *                     253,470 60    38783    42.641358534 1305925  X   W 3429478528 / 3429478656 [postgres]
 *                     253,470 60    38784    42.641365250 1305925  X   W 3429478656 / 3429478784 [postgres]
 *                     253,470 60    38785    42.641372861 1305925  X   W 3429478784 / 3429478912 [postgres]
 *                     253,470 60    38786    42.641385225 1305925  X   W 3429478912 / 3429479040 [postgres]
 *                     253,470 60    38787    42.641389647 1305925  X   W 3429479040 / 3429479168 [postgres]
 *                     
 *                     253,470 48    22379    42.654440688 19690  C   W 3429479168 + 64 [0]
 *
 *                     But not...
 *                     253,470 122    14376    17.252119054 1343941  Q   W 307342496 + 2048 [kworker/u291:3]
 *		       253,470 122    14377    17.252122378 1343941  X   W 307342496 / 307342592 [kworker/u291:3]
 *                     253,470 122    14378    17.252124445 1343941  X   W 307342592 / 307342720 [kworker/u291:3]
 *                     253,470 122    14379    17.252126428 1343941  X   W 307342720 / 307342848 [kworker/u291:3]
 *                     253,470 122    14380    17.252128528 1343941  X   W 307342848 / 307342976 [kworker/u291:3]
 *                     253,470 122    14381    17.252129881 1343941  X   W 307342976 / 307343104 [kworker/u291:3]
 *                     253,470 122    14382    17.252131688 1343941  X   W 307343104 / 307343232 [kworker/u291:3]
 *                     253,470 122    14383    17.252132758 1343941  X   W 307343232 / 307343360 [kworker/u291:3]
 *                     253,470 122    14384    17.252134785 1343941  X   W 307343360 / 307343488 [kworker/u291:3]
 *                     253,470 122    14385    17.252136043 1343941  X   W 307343488 / 307343616 [kworker/u291:3]
 *                     253,470 122    14386    17.252138255 1343941  X   W 307343616 / 307343744 [kworker/u291:3]
 *                     253,470 122    14387    17.252139552 1343941  X   W 307343744 / 307343872 [kworker/u291:3]
 *                     253,470 122    14388    17.252149475 1343941  X   W 307343872 / 307344000 [kworker/u291:3]
 *                     253,470 122    14389    17.252151549 1343941  X   W 307344000 / 307344128 [kworker/u291:3]
 *                     253,470 122    14390    17.252154052 1343941  X   W 307344128 / 307344256 [kworker/u291:3]
 *                     253,470 122    14391    17.252156428 1343941  X   W 307344256 / 307344384 [kworker/u291:3]
 *                     253,470 122    14392    17.252158201 1343941  X   W 307344384 / 307344512 [kworker/u291:3]
 *                     
 *                     253,470 38    21193    38.169287370 980440  Q   W 307344512 + 32 [postgres]
 *                     253,470 111    27256    38.185971679 19690  C   W 307344512 + 32 [0]
 *                     
 *                      
 * 01.18.2022 + rfe  : request to rethink, redefine debug and verbose levels, maybe combined with
 *                     quiet so that we get the incremental output we need in a more controlled manner,
 *                     right not 1 -d or -v seems to open the floodgates to an avalanche of output.
 *                     {ed: not done, but leaving this as marker for now to circle back when have cycles}
 *                     [ed: notes -dv dumps all entries in staged and mainio queues -- too early for just 1}
 *                     {ed: no -d, nothing
 *                           1 -d, dprintf only
 *                           2 -d, dprintf + d2printf
 *                           3 -d, dprintf + d2printf + d2printf
 *                           et.al.
 *                           addresses in debug output are making it difficult to compare output, sub null
 *			     for address at one debug level, and add it at the next level.
 *			     1 dprintf - temporary debug
 *			     1 d1printf- State information or changes (like setting exception flag)
 *			     2 d2printf- 
 *			     3 d3printf- dump each list item w/ null ptr
 *			     4 d3printf- dump each list item w/ real ptr
 * 01.18.2022 + bug  : On a split, verify that the inprogress/inflight counts are properly adjusted.
 * 01.18.2022 + bug  : Well that didn't work out too well:
 *                     253,470 54      928     1.299139516 1305219  Q   W 3377654368 + 128 [postgres]  <----- this -----+  length=32 post X-split
 *                     253,470 54      929     1.299141269 1305219  X   W 3377654368 / 3377654400 [postgres]            |
 *                     253,470 14     5110     6.520720964  980311  Q   W 3377654368 + 32 [postgres]                    |
 *                     253,470 43     4264     6.566521899   19690  C   W 3377654368 + 32 [0]   ---- this matched to ---+
 *                     253,470 86    70494   109.121652374  976525  Q   W 3377654368 + 32 [postgres]
 *                     253,470 18    70247   109.137536759   19690  C   W 3377654368 + 32 [0]
 *                     Add another special case for 4.18'ism that skips Q events that are XPARENTS.
 *                     Normal io from 3.10, 2.6.32, 2.6.18 won;t have any splits and normal 4.18 io would have
 *
 *                     G events that move the Q onto the mainio queue before a C event can happen.

 * 01.18.2022 + bug  : 4.18'ism For LV devices instead of Q,X.C we get Q,X,nil which leaves the
 *                     original io orphaned on the staging queue where it can be matched again
 *                     later on resulting in multiple matches.. which should not be allowed.  The split
 *                     off io has a normal Q,X,C in that the split off io inherits the Q,X from its 
 *                     parent/original io and the C specifically targets the split io sector,length.
 *
 *                     There are several equally bad thing we could do.
 *                     1) change the search2 to skip io that are already marked as having an X event.
 *                        - problem, orig and split events have X event marker, so would have to introduce
 *                          a split state tracker to resolve that type of issue.  for example, tagging
 *                          all io with "this was parent that was split" as secondary flag say in specials.
 *                          It would be set in the parent *after* split and cleared in the secondary io
 *                          after split (to avoid splits of splits inheritance, although any one "parent"
 *                          io should be split only once.
 *                          downside: it leaves orphans on the staged queue and then can accumulate cruft
 *                          in the queue making searching of the list slow {ed: except this is a corner case
 *                          and how many Q,X,nil orphans will there really be?}.
 *                     2) change the C event processing for LV devices -- assuming we can correctly detect
 *                        such devices.  So if we complete an io that has the X split marker present, but
 *                        not the "this is parent" in specials, then search the staged queue for parental 
 *                        orphans.  Note this won't be just a single parent as splits can be stacked.  So
 *                        in addition to the "specials" flag, we'll need split time,sector,length,level 
 *                        information so we can walk back up the chain of split io and force complete them
 *                        all upon the C of the final non-pareent split. See notes for example, the 10,100
 *                        one -- 85,25 ends up at the final non-parent split of 10,25, et.al.
 *                        - problem, more state tracking... but only in split_event() which is corner case
 *                          plus additional memory for split state tracking for all io.
 *
 *		       For now, option #1, track parents of a X-split in specials flag entry.  Disallow
 *		       them to be a target of search within search2() routine.
 *
 * 01.12.2022 + bug  : 4.18's FWS is special case
 *                     FWS A,Q,G  -> FN D,C -> WS C
 *                     if FN w/o sector, look for an FWS 0,0 -- this will cover D,C events, but
 *                     occassionally if nested deep, there is no FN D,C events ... just C WS 0 at
 *                     the end.  C WS 0 will complete the io at that time (of first match).                Currently
 *                     253,89  101       23     0.001048104 19690  A FWS 0 + 0 <- (253,456) 0		<< added to stage
 *                     253,89  101       24     0.001048208 19690  Q FWS [mdX_raid10]			<< skipped, no sector/length
 *                     253,89  101       25     0.001048435 19690  G FWS [mdX_raid10]			<< skipped, no sector/length
 *                     253,89  101       26     0.001050268  2387  D  FN [kworker/101:1H]  Flush/None?  << skipped, no sector/length
 *                     >> writes flushed.
 *                     253,89  101       35     0.001365591     0  C  FN 0 [0]             Flush/None?  << skipped, no        length
 *                     253,89  101       36     0.001365731     0  C  WS 0 [0]             Write/Sync   << skipped, no        length
 *
 *                     These can be stacked/nested:
 *                     253,89  101       59     0.001563807 19690  A FWS 0 + 0 <- (253,456) 0
 *                     253,89  101       60     0.001563993 19690  Q FWS [mdX_raid10]
 *                     253,89  101       61     0.001564193 19690  G FWS [mdX_raid10]
 *                     253,89  101       62     0.001565379  2387  D  FN [kworker/101:1H]
 *
 *                     253,89  101       65     0.001642015 19690  A FWS 0 + 0 <- (253,456) 0      2nd
 *                     253,89  101       66     0.001642184 19690  Q FWS [mdX_raid10]
 *                     253,89  101       67     0.001642524 19690  G FWS [mdX_raid10]
 *
 *                     253,89  101       70     0.001675262 19690  A FWS 0 + 0 <- (253,456) 0	   3rd
 *                     253,89  101       71     0.001675448 19690  Q FWS [mdX_raid10]
 *                     253,89  101       72     0.001675727 19690  G FWS [mdX_raid10]
 *
 *                     253,89  101       75     0.001825737     0  C  FN 0 [0]			   1st
 *                     253,89  101       76     0.001826108     0  C  WS 0 [0]                     1st
 *                     253,89  101       77     0.001828048  2387  D  FN [kworker/101:1H]          2nd
 *
 *                     253,89  101       84     0.002063622     0  C  FN 0 [0]			   2nd
 *                     253,89  101       85     0.002063862     0  C  WS 0 [0]                     2nd
 *                     >> no writes to be flushed, complete the last stacked flush.
 *                     253,89  101       86     0.002064615     0  C  WS 0 [0]                     3rd < never dispatched!
 *                     Track FWS 0+0 placed onto staged queue, or removed.
 *                     If C FN 0 event, synthesize length as 0 so not skipped. Ditto for C WC 0,x events.
 *                     if D FN x,x event, syntesize 0,0 if count of FWS 0,0 is currently non-zero.
 *                     Short term workaround: If A FWS 0,0, fake no sector,length mask so it too gets skipped?
 *
 *                     A Barrier w/no writes to barrier is just A,Q,G, C/WS:
 * #Prg:Flt   Queue(s)     Q2I(ms)   Q2D(ms)       D2C(ms)            Q2C(ms)     CPU      PID Typ  Size         Sector         Seek  Description            reQ 
 * #---:--- ------------- -------- ------------- -------------+---- ------------- --- -------- ---- ---- -------------- ------------- ---------------------- --- ---
 *   4: -9   0.039784877   -.----      -.------     -.------- % --      0.029987  16    19690 FWS     0              0   -2331267136 [mdX_raid10]             0   0
 *
 *                     Whereas a Barrier w/ writes to barrier/flush is A,Q,G,D C/FN, C/WS, so has a dispatch event present
 *   2:-10   0.039759272   -.----      0.060682      0.130232 % 68      0.190914  16    19690 FWS     0              0             0 [mdX_raid10]             0   0
 *
 *                     
 * 01.12.2022 + rfe  : 'X' splitting io requests not currently implemented and can leave cruft hanging around.  Either implement
 *                     or figure out how to eliminate the cruft.  Also add tracking for number of splits.  Typically a split will
 *                     be due to crossing some type of device boundary. Without splits things like later merges also fail, so a 
 *                     ripple affect. And that ripple affect will cause orphans! A split will happen @Merge point before an @Insert
 *                     (at least in 4.18).
 *                     253,89  91      608     0.052544854 19690  A   W 3098880640 + 128 <- (253,457) 844399232
 *                     253,89  91      609     0.052545028 19690  Q   W 3098880640 + 128 [mdX_raid10]
 *                     253,89  91      610     0.052545426 19690  X   W 3098880640 / 3098880744 [mdX_raid10]   << 640 x 128 => 640 x 104 ; 744 x 24 [1]
 *                     253,89  91      611     0.052545779 19690  G   W 3098880640 + 104 [mdX_raid10]
 *                     253,89  91      612     0.052546103 19690  G   W 3098880744 + 24 [mdX_raid10]  		<< @3098880768
 *                     
 *                     253,89  91      627     0.052582747 19690  A   W 3098880768 + 64 <- (253,457) 844399360
 *                     253,89  91      628     0.052582925 19690  Q   W 3098880768 + 64 [mdX_raid10]
 *                     253,89  91      629     0.052583281 19690  M   W 3098880768 + 64 [mdX_raid10]		<< 24+64 = 88.
 *                     
 *                     253,89  91      653     0.052948941 19690  I   W 3098880640 + 104 [mdX_raid10]
 *                     253,89  91      654     0.052949199 19690  I   W 3098880744 + 88 [mdX_raid10]				<< where'd the extra blocks come from?
 *                     253,89  91      661     0.052962316 19690  D   W 3098880640 + 104 [mdX_raid10]
 *                     253,89  91      704     0.053334624 19690  C   W 3098880640 + 104 [0]
 *
 *                     Since io aren't moved off the pre-stage queue to main queue until insert time, the split *should* be
 *                     fairly each to perform, just clone the original io block but then change the sector,length of each
 *                     to reflect the split.  Since both split io will have the same originating time stamp, both should
 *                     be kept at the original queue position and q+1.
 *                     
 *			[1] 104 length is diff between 640 and 744, then remainder is what is left. 
 *			Assuming a split is 1:2 only.
 * 01.12.2022 + bug  : cnt_requeues_writes++ were not being properly counted, code was incrementing sleep writes++ instead.
 * 08.16.2021 + bug  : dm- detected io w/{F}WFS{M} get detected 1st as case 'F' (dm:Q,C only) and then set corner_case due to
 *                     io type.  That caused the io to drop into switch that didn't have an 'F' entry resulting in C events
 *                     being discarded. Added code to move these dm/WFS io to the postio queue.  That then caused a 2nd issue
 *                     whereby normal WS io -- which had simply been output/completed -- now had to be be put on the postio
 *                     queue because the postio queue was no longer empty as had been the case prior to adding the above code.
 *                     So had to add processing of non-corner F cases onto the postio queue also.  Since prior cases the io
 *                     for dm was simply moved to completed/done queue, we can also simply move these to the postio queue too
 *                     if  so needed.
 * 07/18/2021 + bug  : fix math bug in Eff calc.
 * 07/18/2021 + chg  : Add Eff column to iostat output, this is "svctm" in disguise, but svctm
 *                     isn't "service time" its effective io rate. So 'Eff'.  If I submit 100
 *                     io essentially together and in parallel and each one takes 100ms to complete
 *                     then await=100ms, but the effective io rate is 100ms / 100 io => 1ms, effectively
 *                     we're completing 1 io every 1ms.  Seeing long stalls in nvme devices when we
 *                     dump 100s of io into the device, following by all the io essentially immediately
 *                     completing.  So while the await time is high, the Eff. time is expected to be 
 *                     much lower.  Eff is computed by 1000ms-idle_time / #tot-io-completed; how much
 *                     time within the 1 second sample was the device busy with io and how many io were
 *                     completed.  
 * 07/09/2021 + bug  : The code fails to find a "best match" under the following circumstances:
 *                     252,3    4       29     0.001282812  3945  A FWS 0 + 0 <- (253,6) 0
 *                     252,0    4       30     0.001283202  3945  Q FWS [jbd2/dm-6-8]
 *                     252,0    4       31     0.001283861  3945  G FWS [jbd2/dm-6-8]
 *                     252,3    6       61     0.001295454  3936  A FWS 0 + 0 <- (253,1) 0
 *                     252,0    6       62     0.001295744  3936  Q FWS [jbd2/dm-1-8]
 *                     252,0    6       63     0.001296192  3936  G FWS [jbd2/dm-1-8]
 *                     252,0    4       32     0.001529912     0  C  WS 0 [0]             <<<< [1]
 *                     :
 *                     252,0    6       64     0.001925241     0  C  WS 0 [0]
 *
 *                     [1] there are two identical barrier io commands outstanding and it cannot
 *                         determine if the first complete is for the 1st barrier or 2nd barrier.
 *                         it should just choose the earliest io match in this case, but output
 *                         %%W or %%I info on its choice and why.
 *
 *                     For just this case, where case switch value is 15 (A,G both exist in both io),
 *                     choose oldest outstanding io to merge the event into.  This should restrict this
 *                     to a very limited set of known barrier cases at the moment.
 *                     
 * 07/09/2021 + fut  : future -- refactor out state.device_nvme from most/all logic points.  For example:
 *                     (events->insert.line         != 0)|state.device_nvme? ...
 *                     so if the event is present or its not a device_nvme..., really the logic should just be
 *                     is the event present, which is true if the .line is non-zero in all cases.  Go back and
 *                     add another special LINENUM, LINENUM_ZERO which would only ever be used if the input
 *                     lineno is zero so that we don't falsely thing there is no event value.  This really shouldn't
 *                     happen as the blktrace_parse.bsh script adds a header to the blktrace.txt file moving the first
 *                     event to line #3 -- but if someone uses this directly against a blktrace event output file without
 *                     the added header, then the first event info is likely to get skipped because .line == 0.
 *                     Currently device_nvme is only used in completed io output generation and accum capture.  A minor
 *                     use is a %I output about nvme event train behavior and that can stay as it helps explain why
 *                     Q2I is often missing for NVMe devices.
 * 07/09/2021 + bug  : LINENUM_SPEC1 case backfilled with I event if hit a C event with no D event (copied I->D),
 *                     for example in some barrier cases is A,Q,G,C sequence.  But the code didn't check to see
 *                     if I actually existed.  Change this code to check for I present, and if not wheter first.line
 *                     is present and use that instead and if neither then don't do anything at all.
 * 07/08/2021 + bug  : device_lvm assumes no I event = no D event.  this is old holdover from previous model
 *                     and was suppressing D2C times if there was no I event present.  That whole code isn't
 *                     needed anymore with the addtion of .line capture of input file line number .. we now
 *                     know if an I or D event was really present of not so just use the common noIns and noDis
 *                     flags vs device_lvm.  I suspect the same is true of nvme device detection.  Postpone further
 *                     cleanup by add to the todo list. This is a local only variable.
 *                      output_completed_io() ; force device_lvm = off
 *                     _stats_accum_output()  ; force device_lvm = off
 *                     Postpone re-factoring to remove completely.
 * 07/05/2021 + chg  : change merged.out to merged.txt
 * 07/05/2021 + chg  : add framework for avg queue depth calculation, track and report max queue depth
 *                     a) at first event (A|Q), dTime from last calculation x InProgress.tot, set Time to A|Q
 *                     b) at completion  (C  ), dTime from last calculation x InProgress.tot, set Time to C
 *                     note: perform before InProgress count change.
 * 07/02/2021 + bug  : blktrace data maps from a partition to the main device as here:
 *                     68,80   2      224     0.004346414 11926  A   R 28 + 1 <- (68,83) 28
 *                     68,80   2      225     0.004346779 11926  Q   R 28 + 1 [puppet]
 *                     68,80   2      226     0.004347069 11926  M   R 28 + 1 [puppet]
 *                     note-> all events after the remap is the main device as it should be, the lba after
 *                            remAp is the lba of the main 68,80 device ... not the 68.83 partition. But,
 *                            nvme is "different".
 *                     259,15  20       13     0.000126716 34533  A   W 8742769112 + 256 <- (259,24) 8742766976
 *                     259,24  20       14     0.000126931 34533  Q   W 8742769112 + 256 [kworker/u642:0]
 *                     259,24  20       15     0.000127066 34533  G   W 8742769112 + 256 [kworker/u642:0]
 *                     259,24  20       16     0.000127360 34533  I   W 8742769112 + 256 [kworker/u642:0]
 *                     259,24  20       17     0.000129411 34792  D   W 8742769112 + 256 [kworker/20:2H]
 *                     note-> all events, other than the remap, revert back to referencing the partition not
 *                            the main device, even though the lba after remap is for the main device.
 *                     Add code that detects if the device trace is for nvme partition, and capture the minor
 *                     number of the first A event as the main device minor number.  Change any subsequent
 *                     events that are not an A event to use this minor number.  Assert the following rules
 *                     when doing this: a) every A event is from the same maj,min number (this is then the
 *                     target of the minor number change), b) each non A event is for the maj,min from the
 *                     remap event (in the above case 259,24 is partition and 259,15 is main device),  These
 *                     rules are very restrictive and if there are multiple layers, say lvm to partition to
 *                     device remapping then the rules will complain and exit until yet more exceptions are
 *                     added to the rules.  That is the rules are very restrictive by design to cover just this
 *                     one case for now.
 * 07/02/2021 + bug  : with nvme WS there is no I events and I-Q results in negative value.  Change the output to be -.---- string for
 *                     Q2I if there is no I event present.
 * 07/02/2021 + chg  : change the iostat header, the use of |...| was a bit visually misleading.  Add further grouping of data columns.
 * 05/18/2021 + chg  : improve per second output, specifically the "iostat" summary/avg portion.
 * 05/17/2021 + chg  : add idle time tracking; added IEvtTime and idle_state.  When ever idle state changes, the current
 *                     event time is captured within IEvtTime.  This happens at M|Q events (idle->busy) and C events (busy->idle).
 *                     The Q_IS_IDLE is only set at C time if this event upon completion results in inProgress count going to zero.
 *                     1) @Complete events:
 *                        - added code to move_mainio_to_post() and move_mainio_to_done() where inProgress counters are decremented.
 *                        - if goes to zero, then idle queue and we need to set idle state Q_IS_IDLE .and. capture the event timeinfo as the start
 *                          of the queue idle period.
 *                     2) @A|Queue events:
 *                        - added code just after create_io() but before io is moved to staging or main io queue, added a callout to stats_check_boundary()
 *                          with added handle_idle flag set to 1.
 *                        - within stats_check_boundary(), added code that will add all idle time to summ accum block, and then will split idle time across
 *                          samp per second accum blocks as needed.  This will split idle time that occurred in the current sample accumulator, but if the
 *                          current Q time is later than sample end bounds, only up to the end boundary will be counted, that sample flushed and a new one
 *                          started.  This will be repeated until we end up with a per second accumulator for the current time period.  The either the full
 *                          amount if Q time is in the current per second timeframe or what remains if it had to be split, is added in to the per second
 *                          accumulator.
 *                          Note: that change in stats_check_boundary() means that it could spam a number of empty SEC blocks.  Later changes 
 *                          their will be necessary to prevent that.  We want the option to output idle csv per second data even though we want 
 *                          to supress idle SEC blocks within the normal merged output block.
 * 04/28/2021 + chg  : Update header (again) following the use of a event flow description within a case that is
 *                     incorrect.  (See "Recent Case Comments").  So re-did output file header to include a "compact"
 *                     state form that could be used -- along with additional details to help explain it, if needed.
 *                     But the "Compact State Form" should be a drop in replacement for the flawed state flow being
 *                     used in case comments currently.
 * 01/12/2021 + bug  : Allowing Q|C only events result in debug messages about D2C being larger than
 *                     Q2C.  Need to qualify that debug message not to output when there is no D event.
 *                     DBG[05135]: D2C   1.79658604 >   1.06245995 Q2C BAD BAD BAD @@@
 *                     Also, the Q->C only io is messing with the inflight data.
 *                     #Prg:Flt   Queue(s)     Q2I(ms)   Q2D(ms)       D2C(ms)            Q2C(ms)     CPU      PID Typ  Size         Sector         Seek  Description            reQ Merges:sectors,...
 *                     #---:--- ------------- -------- ------------- -------------+---- ------------- --- -------- ---- ---- -------------- ------------- ---------------------- --- ---:---------------------
 *                        1:  0   0.000000000   0.0000      0.000000      0.000000 %  0      0.683788  16    97549 R      32           3896             0 [ora_ckpt_wqj]           0   0
 *                        1: -1   0.000734126   0.0000      0.000000      0.000000 %  0      1.062460  16    97549 R      32           5720          1792 [ora_ckpt_wqj]           0   0
 *                        1: -2   0.001838873   0.0000      0.000000      0.000000 %  0      0.794346  16    97549 R      32           5784            32 [ora_ckpt_wqj]           0   0
 *                        1: -3   0.002679117   0.0000      0.000000      0.000000 %  0      0.883369  16    97549 R      32           5816             0 [ora_ckpt_wqj]           0   0
 *                        1: -4   0.003863907   0.0000      0.000000      0.000000 %  0      1.307742  16    97549 WS     32           3960         -1888 [ora_ckpt_wqj]           0   0
 *                        1: -5   0.006773517   0.0000      0.000000      0.000000 %  0      0.397584  17    97549 R      32           3896           -96 [ora_ckpt_wqj]           0   0
 *                        1: -6   0.007216560   0.0000      0.000000      0.000000 %  0      0.483256  17    97549 R      32           5720          1792 [ora_ckpt_wqj]           0   0
 *                        1: -7   0.007727837   0.0000      0.000000      0.000000 %  0      0.536959  17    97549 R      32           5784            32 [ora_ckpt_wqj]           0   0
 *                        1: -8   0.008289795   0.0000      0.000000      0.000000 %  0      0.271808  17    97549 R      32         291680        285864 [ora_ckpt_wqj]           0   0
 *
 * 01/12/2021 + bug  : 2.6.32++ dm- devices only have Q|C events -- there are no events that promote the
 *                     io from staged to active queue.  Add special case 'E' within complete_event()
 *                     for dm- devices: look for matching io on the staging queue and "activate" them
 *                     so normal completion handling code for io can do its thing.
 * 01/11/2021 + rfe  : change DBG to %I for any non-io types, .e.g. below as we're trying to remove
 *                     any DBG output from normal non-verbose/non-debug flagged output.
 *                     65,80   4      145   254.664659533  2261  G   N [(null)]
 *                     DBG[02949]: not in norm format per primary type, is IOTYP_NONE
 *
 * 01/11/2021 + bug  : if we have AIDC w.o a Q event, the Q time is assumed to be zero vs A time.
 * 		       this results in bad output.  Use 'first.time' instead of 'queue.time' where
 * 		       in all places as necessary.  The 'first.time' will be populated with either A or
 * 		       Q time in 99.999% of cases and in the other cases the event that triggers a ghost
 * 		       create_io() to be called.
 *
 * 		       For example, here is typical io in the 2.6.32++ blktrace output: A,I,D,C only.
 *
 *                     65,80   0       17   158.238410044     6  C   R 0 + 256 [0]
 *                     65,80   2        4   159.144622135  4680  A   R 68787420 + 24 <- (253,94) 68787420
 *                     65,80   2        5   159.144623227  4680  I   R 68787420 + 24 [kdmwork-253:94]
 *                     65,80   2        6   159.144624128  4680  D   R 68787420 + 24 [kdmwork-253:94]
 *                     65,80  85        1   159.203837939     0  C   R 68787420 + 24 [0]
 *                     65,80   2        7   159.204266134  4680  A   R 96804994 + 8 <- (253,94) 96804994
 *                     This is 2.6.32++.
 *                     	
 *                     Change to using 'io->info->events.first' which is populated at create_io() time 
 *                     instead of using 'Q' time for Q2X calculations.  The value in first will be from
 *                     the first (or earliest event in cases of merged io) event used in the call to
 *                     create_io().  In debug, use 'F:%12.2f' instead of 'Q:%12.2f' when first is used,
 *                     but otherwise replace events.queue.time with events.first.time as needed to 
 *                     avoid the AIDC type issues of using 0.0 as Queue (io base) time like below.
 *
 * 		       We need a 1st pseudo event that assumed A or Q time whichever comes first and then
 * 		       that is used for Q time.  Do this via a field (easiest) or macro that chooses A or
 * 		       Q which ever is present -- in that order.  There is already such a field 'first', 
 * 		       it just appears unused atm even though it was added just for an issue like this.
 * 		       It also looks like it is correctly populated with whatever first event results in
 * 		       the create_io() call being invoked.
 *
 * 		       What happens now is the output ends up wrong because no 'queue' event is present.
 *                     dDBG[04636]: dump mainio event 0000000000D637C0, merges=0(1 active, 0 completed)
 *                     dDBG[04639]:      sector, size, 'A' QIDC :     68787420:    24 A......IDC.  0.000000000 159.144623227 159.144624128 159.203837939
 *
 *                     note, no Q time as there is no 'Q' event, just the A event. And at line summary output
 *                     time, the Q2I uses 0.0 as queue time even though 'A' time is available.
 *
 * queue        insert        Q2I          dispatch    Q2D           completed     Q2C          cpu pid     iotyp    size           sector    name/string
 * 0.000000000 159.144623227/159.144623227 159.144624128/159.144624128 159.203837939/159.203837939    2  4680 R          24         68787420 [kdmwork-253:94]
 *
 * 01/11/2021 + bug  : prmtyp is an enum, not char -- was %c instead of %d in some debug printf() calls.
 * 12/09/2020 + chg  : move the debug/verbose logging added during debug behind a control, allow some "normal" output like 
 *                     input line output to be hidden behind a stacking -q(uiet) switch.  Change the default settings for what is or
 *                     isn't shown in default fashion if -DDEBUG compile switch added.
 * 12/09/2020 + chg  : add default to flag/toss events that the program cannot figure out matching for, output the events
 *                     to exceptions ... do this *instead* of internal logic fault assert failures.  Do this to try and prevent
 *                     the program from stopping before the end of the input file.  Hopefully these type of event situations are
 *                     getting fewer/farther between.  Add a summary to the end of the file as to how many events tried to trigger
 *                     internal logic faults.  There are two types of logic faults: programming faults and event "wth" faults.  
 *                     Programming faults are not affected by this change.  Typical programming fault: calling ghost_create() with
 *                     a A|Q event as those are io initiating events, not ghost initiators.  Whereas all event faults are related to
 *                     not being able to uniquely match the current input event with an existing io target structure.
 *                     I use a lot of defensive programming checks/exits to prevent issues associated with thinking the code did
 *                     one thing, but actually did something else -- some of the code paths/decisions are a bit wonky and so added
 *                     sanity checks to ensure that end state of the decision by the code is rational.
 * 11/12/2020 + chg  : redo plug/unplug event processing - should never assert() fail and coredump for this type
 *                     of model logic issue.  Deal with it differently with alerts instead.
 * 11/12/2020 + chg  : add back in individual count trackers for sleep/request x read,write which were present
 *                     in fork.2 code base.  The alert code @SEC,SUM use the individual counters so need that
 *                     info (currently alerts are not happening although sleep/requeues are processed correctly).
 * 11/04/2020 + chg  : add 'request' typ_io pointer to event.  When io context for the event is identified
 *                     fill this field out.  At annotation time if the field is still null, then this event
 *                     was discarded.  If the event is processed, and it is not a type that is related
 *                     to an typ_io/request context, then it is set to REQ_NOCONTEXT value to indicate it was
 *                     processed, but isn't an event type related to a request (like P,U,...) or other. If
 *                     it is a non-io, that is the io type is 'N', then it may be set to REQ_NONIO value.
 * 11/04/2020 + chg  : add [GHOST] and [BARRIER] tag explanations to the *.merged output file.  This
 *                     also changed the [SPECIAL CASE.1] tag to [BARRIER] tag.  The tags appear at the
 *                     end fo the summary line instead of merged data list.
 * 11/02/2020 + rfe  : add special case detection code for 0:0 io (barrier) type io sequence:
 *                     8,6    0       10     0.000619252 126042  A FWS 0 + 0 <- (253,2) 0  << note this is against device 4.18++ (dm-2 -> sda5)
 *                     8,0    0       11     0.000619652 126042  Q FWS [db2sysc]           << but this is against device  4.18!! (sda -- not sda5!)
 *                     8,0    0       12     0.000620552 126042  G FWS [db2sysc]
 *                     8,0    0       13     0.000621052 126042  I FWS [db2sysc]
 *                     8,0    0       14     0.000920178 108767  C  WS 0 [0]
 *                     previously Q,G,I, and C were discarded as they do not contain a sector:length needed
 *                     for context matching.  This results in a lot of abandoned requests in the staged queue
 *                     from the initial A event.  The special case code will match up the above set of events
 *                     as all related to one another so the event will get output and no events are extraneously
 *                     discarded.  There is no Dispatch event for this sequence since it is a 0 length data move.
 *                     Seems to act only as a barrier within the scheduling queue as I2C time is no trivial.  The
 *                     D time is ghosted to I time.  Upon output this event has [SPECIAL CASE.1] added to the end
 *                     of the line where bio list for merging would normally be.
 * 11/02/2020 + chg  : fix exception output that was overwriting the reason for flagging the event as an "exception"
 *                     (typically missing sector:length info).  Note and exception does not mean and actual discard.
 * 11/02/2020 + chg  : add better internal logic fault message format to include timestamp of event, prime type,
 *                     sector:length info in %%F output.
 * 11/02/2020 + chg  : reduce %X messages in main *.merged output file, move them to *exceptions if needed or
 *                     eliminate if these are somewhat duplication of exception event output (recode as xfprintf
 *                     or xprintf for example to reduce normal clutter but keep them in code base for future
 *                     debug use)
 *    *       add special case for checking for 0:0 on G,I,C... and if C 0 extended                  - done
 *     *       into 0:0, check to see if D event exists and if it doesn't extend I to D
 *      *       time/event wise and so mark the event as [SPECIAL CASE.1].  I suspect there
 *       *       could be multiple special cases in our future.
 *        *          - added special1 detection within parse_event()
 *         *          - need to change event processing for Q,G,I,C
 *          *
 *           *       add code to resolve multiple matches.  The best way to do this is at each Nth
 *            *       match, keep counters of n way matching.  Then validate doesn't have the current
 *             *       event already in either 1st (best tracker) or nth, that it has pre-requisiste 
 *              *       events, and is same full io type.  At that point with have a fully qualified
 *               *       match using more stringent checking, and hopefully only have 1 match.  But
 *                *       if we get to the point that 1st (best) is marked stringent qualified and the
 *                 *       nth one is to, then we select the one with earliest timestamp and note all this
 *                  *       in exceptions.
 *                   *
 *                    *       Add better internal logic fault messages to include input line number, prime type, sector:length info. - done.
 *
 * 10/29/2020 + chg  :  add function for detetion of 2nd hand merging.  The case we ran into was io submitted
 *                      for sector 3,1,2.  3 has A|Q|I as does 1 so two typ_io requests inserted into mainio
 *                      active list.  Then 2 has A|Q|M and it is merged into request for 2, 1:2 (sector:length)
 *                      after merge.  Then a dispatch happens with but its 1:3!  There was a 2nd hand merge
 *                      that occurred within the scheduler after 1+2 happened, the independent request for 3:1
 *                      was merged in.  There will be no event for this.  And we can't just go look for it 
 *                      ourselves at M|F time because not all schedulers will do such merging -- it depends on
 *                      having a by sector sort tree available (so 'noop' scheduler it might be possible if
 *                      the io were 3,1,2 but not if the io were 3,n,1,2 because then 'n' is at top of fifo
 *                      not the '3' request. So. many. special. cases.  New function io = check_2ndhand_merging();
 * 10/29/2020 + chg  :  add conf_merged_event_debug, if set then the list of events attached to the typ_io
 *                      is also output at the time the completed io is output to .merged (main output) file.
 *                      This option is only available if -DDEBUG is included at compile time.  That option
 *                      adds additional fields for the event list in typ_io.  This is intended for debug
 *                      purposes only to verify which events where associated with the io context (which
 *                      also implies some others that were not).  Typically used to verify that a change is
 *                      properly picking up all events correctly, like in the 2nd hand merge case.
 * 10/29/2020 + chg  :  add conf_exceptions_inihibit, this will inhibit exceptions events from being output.
 *                      note that the exceptions file includes 1-liners and just events.  Although, events
 *                      are likely the more prevelant.  May need to revisit this whole topic at a later time.
 *                      Prior to this set of changes, exception events were just cloned onto an internal exceptions
 *                      list, and typ_io marked as exception (inherited from events mostly), get output into 
 *                      exceptions when completed io is output to main .merged file.  Since some events are 
 *                      by necessity just discarded, can't switch over to tagging set of events to typ_io and
 *                      by the time an exception event happens in context, the other events in context leading
 *                      up to that point likely haven't been saved against the typ_io structure (except in the
 *                      new case of -DDEBUG above).  So for now the exceptions file is likely to be a bit messier
 *                      than I'd like.
 * 10/29/2020 + chg  :  If io is marked a "ghost", at output time for merged 1-liner, change out the list of 
 *                      merged sizes (if any) to just "[GHOST]" to flag this io as a ghost request, i.e. was
 *                      missing full lifecycle and we had to create ghost events to fill it out.  Such requests
 *                      do not participate in io stats, including inflight/inpgrogress counts, in any manner.
 *                      They are just a ghost, and do not exist as far as any statistics are concerned.  Any
 *                      other attempt at using them if fraught with uncertainty (e.g. a I without A|Q|S|G events
 *                      means I is an orphan event -- there is no pre-existing context to "absorb" this event
 *                      so we create a ghost request as a target for it, but we don't know if this insert was
 *                      A,Q,I,D or A,Q,I,D,R,I,D,R,I,D,R,...I which means the ghosted values for A,Q while 
 *                      probably very close to the I time we use as the ghost values maybe off by a large 
 *                      amount if there were requeues present priod to this I that are not present in the input
 *                      file).
 * 10/26/2020 + rfe  :  Adding "ghost" request creation (see notes at end "GHOST Requests").  These are created
 *                      when an orphan event is encountered.  For example a G event but there is no prior A|Q
 *                      event for some reason in the input file, so no request structure was previously created.
 *                      So the G event forces the creation of a "ghost" request with dummied up A|Q event times
 *                      so the G event isn't discarded.  The first event of G|I|M|F|D|R will force the creation
 *                      of a ghost request so the current event has a target to absorb the event (so the goal of
 *                      no event left behind is satisfied as much as possible).  However, C events will still just
 *                      be flagged with a %W or %E event and discarded. There just isn't anything else we can do
 *                      with C events.  Ghost requests will be tracked and, although will be output like normal
 *                      requests, will not participate in any stats -- no inflight/inprogress, no read/write counts,
 *                      etc.  All stats are unaffected by ghosts as they do not capture a complete io cycle.  While
 *                      we don't expect orphan events to happen outside of the top of the file, within test data
 *                      sets we have they do sometimes occur.  At output time a ghost request will be flagged in
 *                      a manner to indicate that this is a ghost request.  Also see the discussion on second hand
 *                      ghosts which are "worse" than creation of 1st hand or 1st generation ghosts.
 * 10/20/2020 + chg  :  Change filenames to be blktrace.merged instead of referencing parse or parsed for
 *                      any/all output files from this program.  It was confusing to reference blktrace parse
 *                      as there is standard utility blkparse.  This program really is about merging events for
 *                      a single request into a one-liner output so using 'merged' in all filenames should help
 *                      indicate the source of the file better (hopefully).  And while the source version name
 *                      is blktrace_parse.v4.c -- the compiled program will be renamed blktrace_merge for this
 *                      release and onward. Both the older blktrace_parse and blktrace_merge will be present in
 *                      the tar "kit", and the blktrace_parse.bsh script will include lines for either or use, but
 *                      default will be blktrace_merge going forward with failback to blktrace_parse available on
 *                      an as needed basis.
 * 10/14/2020 + rfe  :  See notes [V4.100] below.  With 6.9 and multipath device-mapper-multipath 
 *                      0.4.9-100.el6:
 *
 *                         253,3   28      129     0.517557144  9467  Q   W 24618870792 + 120 [flush-253:3]
 *                         253,3   28      130     0.517560307  9467  G   W 24618870792 + 120 [flush-253:3]
 *                         253,3   28      132     0.517562496  9467  I   W 24618870792 + 120 [flush-253:3] << io ends at 24618870912
 *                         253,3   28      133     0.517597303  9467  Q   W 24618870912 + 128 [flush-253:3]
 *                         253,3   28      134     0.517599157  9467  M   W 24618870912 + 128 [flush-253:3]
 *                         :
 *                         253,3   28      144     0.517696803  9467  D   W 24618870792 + 248 [flush-253:3]
 *                         :
 *                         253,3    3       18     0.520043757     0  C   W 24618870792 + 248 [0]           << the whole io dispatched marked completed
 *                         253,3    3       19     0.520049361     0  C   W 24618870912 + 128 [0]           << the 2nd BIO merged into above marked complete
 *
 *                      Nominal case is 1 D : 1 C.  However have seen 1 D: n C where n = number of bio and the 
 *                      two completions for above would be length 120, then length of 128 to cover the two individual
 *                      bio.  But in the new (above), we get a completion for whole io and then a completion for
 *                      2nd through nth BIO, but not the first BIO all the merges were done against.  So, for this
 *                      new wrinkle we need to hold a "completed" io on a post-queue and allow them to be a target
 *                      for follow-on completion events within a specific time/#event window.  The time window and
 *                      event window should be really short since a part of the io stack is taking the 1 completion
 *                      returned by storage and splitting into multiple completions -- and that should be done in
 *                      one place, all back-to-back.  But we now need the post-queue to detect this behavior so we
 *                      don't think we have random errant unmatched completion events. And... if we do detect this
 *                      output %Info or something at end of samples reporting how many -- or at least at end of file
 *                      with warning that due to the data, the btt iostat output may include negative avgqu-sz data
 *                      (which can be ignored).
 *
 * 09/09/2020 + orig : re-write for V4.
 *
 */

/* Notes:
 * V1.100 :
 * 2.6.32-696.el6.x86_64, only on dm- devices.
 *
 * #scsi_addr       Type      Vendor   Model            Rev    sdN           mpath name       dm- name Size      Lun-wwid
 * #--------------- --------- ------- ----------------- ------ ------------- ---------------- -------- --------- ---------------------------------
 * [0:2:0:0]        disk      Cisco    UCSC-MRAID12G    4.62   /dev/sda      -                -        599.0 GB  36f80bcbeac42be4022050b467c101ad4
 * [0:2:1:0]        disk      Cisco    UCSC-MRAID12G    4.62   /dev/sdb      mpathb           dm-0     2995.0 GB 36f80bcbeac42be402215aaac30f223f4
 * [13:0:0:0]       disk      MSFT     Virtual HD       10.0   /dev/sdd      XFS_LUN          dm-3     70368.7 GB 360003ff44dc75adc92ddcb66646d1c40
 * [13:0:0:1]       disk      MSFT     Virtual HD       10.0   /dev/sdg      EXT4_LUN         dm-2     17590.9 GB 360003ff44dc75adc9c4c3e0ec789bd64
 * [14:0:0:0]       disk      MSFT     Virtual HD       10.0   /dev/sdc      XFS_LUN          dm-3     70368.7 GB 360003ff44dc75adc92ddcb66646d1c40
 * [14:0:0:1]       disk      MSFT     Virtual HD       10.0   /dev/sde      EXT4_LUN         dm-2     17590.9 GB 360003ff44dc75adc9c4c3e0ec789bd64
 * [15:0:0:0]       disk      MSFT     Virtual HD       10.0   /dev/sdf      XFS_LUN          dm-3     70368.7 GB 360003ff44dc75adc92ddcb66646d1c40
 * [15:0:0:1]       disk      MSFT     Virtual HD       10.0   /dev/sdh      EXT4_LUN         dm-2     17590.9 GB 360003ff44dc75adc9c4c3e0ec789bd64
 *
 *
 * Module : kernel
 *          [4] 'Oct 12 10:26:26 ' 'Tainted: G           '
 *          [6] 'Sep 23 12:08:31 ' 'TECH PREVIEW: fscache may not be fully supported.'
 *
 *          XFS_LUN (360003ff44dc75adc92ddcb66646d1c40) dm-3 MSFT,Virtual HD
 *          size=64T features='0' hwhandler='0' wp=rw
 *           `-+- policy='round-robin 0' prio=1 status=active
 *             |- 15:0:0:0 sdf 8:80  active ready running
 *             |- 13:0:0:0 sdd 8:48  active ready running
 *             `- 14:0:0:0 sdc 8:32  active ready running
 *
 *          device-mapper-multipath-0.4.9-100.el6.x86_64                Tue Feb 13 19:32:06 2018
 *          device-mapper-multipath-libs-0.4.9-100.el6.x86_64           Tue Feb 13 19:31:59 2018
 *
 *
 *          current?
 *          device-mapper-multipath-0.4.9-106.el6_10.1.x86_64
 *          device-mapper-multipath-libs-0.4.9-106.el6_10.1.x86_64
 *          Name        : device-mapper-multipath      Relocations: (not relocatable)
 *          Version     : 0.4.9                             Vendor: Red Hat, Inc.
 *          Release     : 106.el6_10.1                  Build Date: Tue 11 Sep 2018 01:26:46 PM EDT
 *
 *
 *          253,3   28      129     0.517557144  9467  Q   W 24618870792 + 120 [flush-253:3]
 *          253,3   28      130     0.517560307  9467  G   W 24618870792 + 120 [flush-253:3]
 *          253,3   28      132     0.517562496  9467  I   W 24618870792 + 120 [flush-253:3] << io ends at 24618870912
 *          253,3   28      133     0.517597303  9467  Q   W 24618870912 + 128 [flush-253:3]
 *          253,3   28      134     0.517599157  9467  M   W 24618870912 + 128 [flush-253:3]
 *          :
 *          253,3   28      144     0.517696803  9467  D   W 24618870792 + 248 [flush-253:3]
 *          :
 *          253,3    3       18     0.520043757     0  C   W 24618870792 + 248 [0]           << the whole io dispatched marked completed
 *          253,3    3       19     0.520049361     0  C   W 24618870912 + 128 [0]           << the 2nd BIO merged into above marked complete
 *
 *          Previous wrinkle was each BIO was completed individually, so a 120 block BIO complete and then 128 bio which then accounts
 *          for the whole io (248) that was dispatched as completed.  As in:
 * 
 *          253,3    3       18     0.520043757     0  C   W 24618870792 + 120 [0]           << the first BIO
 *          253,3    3       19     0.520049361     0  C   W 24618870912 + 128 [0]           << the 2nd/final BIO, which then "covers" the whole dispatch and we recycle the tracking structure for this io, done!
 *
 *
 *          Above is whole request completed and then the sub-bio merged onto the first bio has a separate complete ... and this causes negative queue count.
 *
 *          As I said this is new wrinkle I'll have to account for, as of right now the io @0.520043757 completes the whole io as the length
 *          covers the whole io.  At that point the tracking structure to this io is recycled and gone.  But now I need to place this on an
 *          "almost done" queue to allow a window of time and/or events that can happen against sub-io within the io.  I need to delay the
 *          recycle so I have a valid target for the sub-bio so it gets "absorbed" and not kicked out as "what the hell is this"... because
 *          when that happens my program exits with "feature not available" fatal error :-)
 *
 *          Design notes:
 *          At the first completion event, create and link in a data structure that has 2 x the number of BIO in the request. Track the
 *          number of completion events applied to this request, the first C time and event sequence number and the last/latest C time and
 *          event sequence number.  Define the deadline time and max event count value after which time this io should be considered "dead"
 *          and done.  This is instead of freeing/recycling the event data.  The structures will be freed once the deadline time and #event
 *          count have both been exceeded (and the whole io request and all parts are marked complete).  For this purpose we need two new
 *          flags:
 *              * whole_completion: set if a C event of the whole request length is processed, and
 *              * bio_completion  : set if a C event of the individual bio is processed.
 *              * bio_completed   : counter, reflects the number of BIO that have been covered by C events, only valid in top request
 *
 *          As the bio_completion flag is set for the first time in a bio, the bio_completed count is bumped.  When bio_completed is equal
 *          to number of merged bio, then the whole_completion flag is set if not already set.
 *
 *          If a bio C event happens and the whole_completion is set, then this flags both the io personality and bumps a state counter for
 *          "detected C-whole plus C-bio" behavior.  Which is different from "detected C-bio behavior", where there is a bio C but not a whole
 *          request C event.  The former is tied to btt generating negative avgqu-sz events.
 *
 *          While the whole_completion flag is on the main request structure, both are present in each individual bio linked under
 *          the main request. So if "C-whole" for request happens, then whole_completion flag on each bio (and request) is set.  If
 *          whole_completion is already set on the request then generate warning.
 *
 *          As each completiong event happens, this post-queue specific data structure has the basics captured: line number, time, 
 *          sector, length.  Once the whole io has completed, either due to detected series of C events that match pattern for C-whole/n-1 bio
 *          or otherwise, then the request information .AND. each C event details are dumped out to a file.  I'm just not sure how often this
 *          happens and this side file dump will help understand and illustrate the issue for users of the blktrace data.
 *
 * #Prg:Flt   Queue(t)    Q2I(dt)     Q2D(dt)     D2C(dt)          Q2C(dt)    CPU   PID Typ       Size          Sector        Seek Description             reQ  Merges:sectors,...
 * #---:--- ----------- ----------- ----------- -----------+---- ----------- ---- ----- --- ---------- --------------- ------------ ---------------------- ---- ---:--------------
 *   37:  0   0.5175571   0.0000054   0.0001397   0.0023470 % 94   0.0024866   28  9467 W         248      24618870792   4760806280 [flush-253:3]             0   2:120,128.
 * [  1]  A   0.5200437                                                                           248      24618870792
 * [  2]  1   0.5200493                                                                           120      24618870912
 *            C-Whole plus 2nd-Nth BIO or
 *            Individual   1st-Nth BIO or
 *            unknown behavior detected
 *
 *    A   B   C                                                                                   D        E
 *
 *    A - index of C event, 1...N in time ordered output
 *    B - A=all or covers whole request
 *        n=number of bio this C covers or partially covers
 *    C - time of C event
 *    D - length of C this event
 *    E - sector of C this event
 *
 *    The trailing line is behavior detected, followed by at least 1 blank line to separate out each instance of non 1 D : 1 C detected
 *    behavior.
 *
 *    The post queue is time ordered, with oldest at the top of the queue and new requests post first C event added to the end of the
 *    post-queue.  Each time find fails to find the companion io on the main/active queue, a series of passes will be needed in this
 *    order
 *        0) check to top of the post-queue to see if the request parked there is "dead" - aka past its time/event holding window and
 *           if so, move the io to pending free queue (or set a status), repeat until you get to undead entries.
 *           	- what do we do with "dead" partial completed io? output them along with an %W that this io was only partially completed?
 *        1) check the post queue for any io that has whole_completion set, then search for one this C fits entirely within the io
 *           doesn't match the 1st BIO, but matches 2nd-Nth bio.  Mark that bio as "bio_completion". or until you reach the end of
 *           queue. If all BIO end up marked completed (except grandfathered 1st), then io is officially complete and is output.
 *        2) check the post queue for any io that has whole_completion not set, then search for one this C fits entirely within 
 *           and matches against one or more BIO and those BIO are not marked complete. Mark the bio as "bio_complete" and bump the
 *           bio_completed count on the request.  If, as a result, bio_completed = merge count, then io is complete, dump out and
 *           place onto pending free queue.  
 *        3) still no match, ok rescan the active queue as this could be first BIO complete against active io with multiple merged
 *           BIO.  Since such a check will only happen on first BIO and our expectations is that the post-queue staging area will 
 *           be small .and. because behavior detection of C-whole+BIO should be looked for first. 
 *
 *    However, given all the above, I'm still kind of shakey on get a BIO completion event (a whole event will always match first
 *    against an io in the active queue) but its on an io in the active queue and not the post-queue but the code matches it up to
 *    an io on the post queue.  The scenario I'm thinking of is C-Whole only are happening because of no merging.  But the BIO shows
 *    up as C-1st-n case but its against an io on the active queue. ... and the logic matches it incorrect against the wrong io.  I'm
 *    just not sure of the mechanics where that could happen.
 *
 *    Stuff placed on the free queue is given a delay time of n seconds, meaning it won't get recycled until that amount of time
 *    elapses. New entries are placed at the end of the queue and top of queue it checked at each malloc time to see if current
 *    event time is later than the timeout on the top of queue data, if so, then it and its attendent structures are freed.  Then
 *    we malloc new data structures.
 *
 *    And yes, this is kind of a convoluted process
 *
 *    Addendum.  1st pass code "assumed" the a C per BIO was happening, but it turns out the C events may be on a range of
 *    BIO: 1-n, 2-n, 3-n, ... etc until last C event is n-n covering just the last BIO.
 *
 *    DBG[12227]: part 'C' - postio sub-bio match only
 *    DBG[12228]: check postio list for match 24619237736:   264...{sub-BIO only coveraged}
 *    :
 *    DBG[12232]: postio list  0x1a08b10 24619237704:   296...(sub-BIO=4)
 *    DBG[12245]: postio list  0x1a08b10 24619237704:   296...possible match...)
 *    DBG[12251]: postio list  0x1a08b10 24619237704:   296... passed other filters!
 *    DBG[12255]:  subio list  0x1a09450 24619237704:    32...
 *    DBG[12255]:  subio list  0x1a08fb0 24619237736:    24...
 *    DBG[12255]:  subio list  0x1a09910 24619237760:   104...
 *    DBG[12255]:  subio list  0x1a09b70 24619237864:   136...
 *
 *    it didn't find a singular match but did note that the sector:length is within this io.  So we need to add a second
 *    pass through the code or change the main checking function to allow accumulation of a set of BIO that a) haven't been
 *    previously been marked BIO_COMPLETE, and b) are fully covered/masked by the C sector:length... search all BIO and at
 *    the other end we should come up with enough BIO that the specified length within the C event has been fully covered.
 *    So changing 'C' code path to allow not full coverage of *a* BIO but full coverage of a set of BIO.. and we need to be
 *    able to back this out so we're going to have to either keep a side list of matching BIO and only if we do get full coverage
 *    revisit that list to set BIO_COMPLETE -or- loop twice which is kind of inefficient, but will do that way for now.  Still
 *    assuming make single io is 4M / 4k BIO would seem to yeild the static list length that should satisfy caching BIO addresses
 *    so as to avoid re-iterating over the list... although another way is bit mask of which subio indices got a match -- this again
 *    would eliminate double comparison during 2nd pass.
 *
 *    Addenum #2 - multiple completions are "normal" (in some kernels with some device types)
 *    
 *    There is a request that consists of 4 BIO. The request is 24619237704:296 sector:length.  We can see a dispatch event for this
 *    io and then 4 completions.
 *
 *    253,3   28      463     5.523625246  9467  Q   W 24619237704 + 32 [flush-253:3]   << bio[0]
 *    253,3   28      466     5.523628568  9467  I   W 24619237704 + 32 [flush-253:3]   
 *    253,3   28      468     5.523659215  9467  M   W 24619237736 + 24 [flush-253:3]   << bio[1] merged in
 *    253,3   28      473     5.523753463  9467  M   W 24619237760 + 104 [flush-253:3]  << bio[2] merged in
 *    253,3   28      475     5.523813779  9467  M   W 24619237864 + 136 [flush-253:3]  << bio[3] merged in
 *    :
 *    253,3   28      482     5.523877338  9467  D   W 24619237704 + 296 [flush-253:3]  << 1 dispatch for request with all bio
 *    :
 *    253,3   29      142     5.526574263  5614  C   W 24619237704 + 296 [0]  << whole request length or bio[0-3] if you will
 *    253,3   29      143     5.526583011  5614  C   W 24619237736 + 264 [0]  << bio[1-3]
 *    253,3   29      144     5.526586470  5614  C   W 24619237760 + 240 [0]  << bio[2-3]
 *    253,3   29      145     5.526592451  5614  C   W 24619237864 + 136 [0]  << bio[  3]
 *
 *    My program does not expect/allow double completions but it does differentiate/allow for the case of whole completion followed by one or more bio completions.
 *    But in this case the 3rd and 4th completion events are duplications of the bio completion event (#2).  Arrggghhh.  The issue is that I can have io
 *    against the same lba active within the queue at the same time.  I need to hold a "completed" io for a given amount of time until all bio are marked
 *    complete or the whole io is marked complete to deal with the 1st two completions above. But holding it past that means that I could erroneously match
 *    duplicate completions for a later active request against this request -- because different kernels issue blktrace events differently.  Another variation
 *    is one C per bio.
 *
 *
 *    DBG[12257]: check postio list for match 24619237736:   264...{sub-BIO only coveraged}
 *    :
 *    DBG[12261]: postio list  0xa04810 24619237704:   296...(sub-BIO=4)
 *    DBG[12274]: postio list  0xa04810 24619237704:   296...possible match...)
 *    DBG[12280]: postio list  0xa04810 24619237704:   296... passed other filters!
 *    DBG[12291]:  subio list  0xa05150 24619237704:    32...
 *    DBG[12297]:  subio list  0xa04cb0 24619237736:    24... 1 matched, 24 sectors covered!
 *    DBG[12297]:  subio list  0xa05610 24619237760:   104... 2 matched, 128 sectors covered!
 *    DBG[12297]:  subio list  0xa05870 24619237864:   136... 3 matched, 264 sectors covered!
 *    DBG[12326]:  subio list fully covered; 3 bio match for 264 of 264 sectors, match!
 *    DBG[12327]: 24619237704:296 set IS_BIO_COMPLETE, both postio and 3 subio
 *
 *    Add config to allow duplicate completions, just issue warnings attached to the request, 
 *    if allowed output %W in both normal output and exceptions to flag the one-liner output.
 *    Ideally in this type of case don't move the tmo line value to keep things tight.  If duplicate
 *    completions are an issue, add the config parmeter to prevent continuing once detected. Aka don't 
 *    extend the tmo info which I normally do to make sure the request hangs around in the post queue
 *    long enough to absorb all the dangling C events that might dribble in.  But as far as I know from
 *    experience these shouldn't dribble but get slammed in one after another.  So the time tmo should be
 *    very short, but the line based tmo is much more variable and dependent on other activity on the device.
 *    Adding output to exceptions as to measured tmo information first to last line and first to last time for
 *    C event stream against the individual request.
 *
 *    --- End V1.100 -------------------------------------------------------------------------------------------------
 *    ----------------------------------------------------------------------------------------------------------------
 *
 * NOTE V1.101 extraneous completions w/o length
 *
 * 253,3   21      516     9.634259613  6471  Q FWFS 68721747696 + 64 [xfs-cil/dm-3]
 * 253,3   21      517     9.634261789  6471  G FWFS 68721747696 + 64 [xfs-cil/dm-3]
 * 253,3   21      519     9.634265544  6471  I FWFS 68721747696 + 64 [xfs-cil/dm-3]
 * 253,3    3      698     9.635034753   373  D WFS 68721747696 + 64 [kblockd/3]
 * 253,3    8      866     9.635713558     0  C WFS 68721747696 + 64 [0]
 * 253,3    8      867     9.635721954     0  C WFS 68721747696 [0]
 *
 * The last C event is being tossed because there is no length associated with it.  Also note in this case the "mode"
 * changed from FWFS to just WFS but the program already accounts for this.  But the output is a bit wordy:
 *    9:  2   9.634259613   0.0059      0.775140      0.678805 % 46      1.453945  21     6471 FWFS   64    68721747696   42948630264 [xfs-cil/dm-3]           0   0
 *    %E[02677]-Missing location and/or process name data when same was expected, add to exceptions.
 *    %I[02678]-Input '253,3    8      867     9.635721954     0  C WFS 68721747696 [0]'
 *
 * If there are lot of FWFS type io like this, then the output is broken up.  Also, I think the seek is wrong -- a bug? --
 * triggered by this type of event.  So we've already filtered off non-normal formats for P,U,T which won't have a sector
 * or length, I think we need to add "special" case code for this particular event also -- ones without a length, as long
 * as;
 *     1) we can match the sector to an existing request, and
 *     2) the request is already marked IS_WHOLE_COMPLETE (or at least IS_BIO_COMPLETE)
 *     3) the request is has the IS_POSTIO ioflag set (which implies 2 above)
 * And if both of those conditions are met, add this C event to ctracker on the request on the postio queue
 * (so is that another condition? The IS_POSTIO flag is set.  Adding the ctracker event, we set the length to 
 * -1 to indication there is no length on the input line.  Maaaybe add a pointer to ctracker so that we can capture
 *  the actual event line itself?  Add special processing to the exception file output if the length is -1 then this
 *  was a non-normal C event, most likely a (F)WFS io type?
 *
 *  Leave the DBG output to stdout though.  The above is only being applied to the merged.out file to help clean it up
 *  from things that we (at least partially) understand and expect or have seen and recognize the pattern of.
 *
 *  Ugh! 
 *  This break current POSTIO processing.  Currently if we get a C event against a request that has no merged then we 
 *  just output the completion and we're done.  The io is directly freed and not move to the postio queue.  Its 1 BIO,
 *  how can we have multiple C events against 1 BIO?  Well, in this case.  Which means attempting to match the supplied
 *  sector address in the 2nd C event will fail -- the typ_io block is gone from staged/main/post queues.  So we either
 *  complicate *all* C events forcing *all* io to transition from mainio -> postio (but with a really short tmo in this
 *  particular case).  Or we create yet another list with "freed" io with their own reclaimation tmo before actually being
 *  freed to allow trailing events, specifically C events of this type to have a target request.  But a problem with that
 *  is we want to output such "exceptions" to the exceptions file so we can see the types of event flow that result in
 *  duplicate C events (for example).  Exception output is only done when an io has its one-liner output and the case of
 *  1 BIO w/1st completion that has already happened. Soooo, that would mean even more special case code to possibly 
 *  perform a 2nd output of the request to exceptions file.  Double ugh.  That means the most straight forward answer
 *  is to force *all* completing io, even simple case ones to transition to the postio queue first.  Albeit in this case
 *  with a very short tmo.  It also means just because the whole io has been covered by a set of completion events we really
 *  need to tmo before output.  We do that now on either tmo having lapsed.  Is that enough for this type of double completion?
 *  And how do we match on this io since we match sector+length and this has zero length.  This completion won't cover a whole
 *  request or bio with length=0.  So more special case code on both finding the request to target and the BIO it is against.
 *  Really want every event accountable to a sector to target/mate to a request but this one is really causing heartburn in
 *  terms of convoluted logic/corner case additions to make it happen.  sigh.  onward.
 *
 *  Note this is a lot easier in the kernel since its passing around context.  Outside we've got to guess when that context
 *  is no longer needed and how to match to it since each event itslef is kind of stateless until matched against some common
 *  criteria that allows gathering a set of events as all belonging to the same (request) context.
 *
 *    --- End V1.101 -------------------------------------------------------------------------------------------------
 *    ----------------------------------------------------------------------------------------------------------------
 *
 *  V1.102
 *
 *  $ grep -n 30406728 xvdj.blktrace.txt
 *  184:202,144 15      182     0.300016292     0  D  WS 30406728 + 8 [swapper/15]
 *  217:202,144 15      215     0.409930384     0  C  WS 30406728 + 8 [0]
 *
 *  While orphan events are expected/possible near the beginning of the file there is the question as to what to
 *  do with them.  If its just a trailing C event, then discarding it is the only option.  There are no other events
 *  to compare them with and create dTime values.  But if there is at least a D event first, then dummy'ing up a 
 *  request context makes sense.  This gives the C event someplace to land against so instead of discarding two
 *  events we can create a merged line showing D2C time at least.  Such dummied events should not participate in
 *  iostat type behavior (we can get queue depths going negative for example).  So at C time we need to look at
 *  a flag or something in the io context to see if we should or shouldn't update inprogress/inflight info.
 *  While its tempting to update inprogress/inflight for a dummied io at D time, that is going to skew a lot of
 *  the other statistics -- for example there is no real Q2C await time.  It is safer just to consider these
 *  partial/dummied io as "ghosts" -- we create a context to absorb events, we output a partial merged summary,
 *  but they otherwise are treated as if discarded.  So no inprog/inflight, and not other iostat type stats.
 *  They should not even be counted as completed read/writes becuase they are ghosts (otherwise again the iostat
 *  type statistics are skewed by partial context information.  Whereas the /proc/diskstats is an ongoing set of
 *  stats from bootup and beyond, with blktrace we're jumping into an ongoing stream of events and any partials
 *  just need to be ignored vis-a-vis stats.
 *
 *  Note a combination of the above and multiple completes per io result in btt iostat with neg queue values:
 *       Device:       rrqm/s   wrqm/s     r/s     w/s    rsec/s    wsec/s     rkB/s     wkB/s avgrq-sz avgqu-sz   await   svctm  %util   Stamp
 *       (253,  3)       0.00     0.00  190.47  100.72 191021.06   1364.21  95510.53    682.10   660.68    -4.89    3.80    3.80  99.37    4.01
 *       (253,  3)       0.00     0.00  182.94  124.96 182286.41   1735.45  91143.21    867.73   597.66    -4.81    3.89    3.89  99.36    5.01
 *       (253,  3)       0.00     0.98  188.34  111.83 182096.29   1561.68  91048.15    780.84   611.84    -5.08    3.86    3.88  97.75    6.03
 *       (253,  3)       0.00     0.00  190.68  116.81 189213.26   1621.30  94606.63    810.65   620.62    -5.79    3.99    3.99  99.35    7.03
 *       (253,  3)       0.00     8.97  183.32  301.89 179682.40   6647.52  89841.20   3323.76   384.02   -10.71    3.92    4.00  99.51    8.03
 *
 */

/*
 * Refactor notes:
 * - code is constantly checking floating point being assigned a value by checking if > 0.00001 or
 *   whatever.  Even checking for 0.0000000 is not likely actually good enough because the event
 *   could have actually started at that time.  In other words checking the value to see if field
 *   has had a value assigned is not 100% foolproof - it would be better to have a flag set that
 *   indicates field has been assigned and check that, faster, more efficient and more 
 *   accurate in *all* cases.
 * - make sure events are *fully* initiatized to something.  For efficiency purposes, create a 
 *   dummy static event then can simply be bcopy() over newly allocated event rather than assigning
 *   each individual field each and every time.
 * - add function code log printf on entering and exiting a routine, have several "levels" of 
 *   functions, main, aux, debug, etc. and be able to on command line enable deeper and deeper
 *   function tracing function logging printfs.
 * - add standard function headers with name, args, description, function, notes, etc.
 * - there has been need in the past to trigger debug logging only on a specific lba or range of
 *   lba.  Add a general mechanism and flag for same, say a .conf file to read lba and flag to
 *   actually turn on reading .conf and applying triggers to track lba inside of range of interest.
 *   maybe it bumps up function and internals logging upon first parse of the event and is always
 *   turned off at main loop when next io read in, or .conf could have an event stretch count, 
 *   which is by default 1 (just this event) but could be n so the deeper logging is left enabled for
 *   n events before being turned off.
 */

/* TODO
 *       note in the following, the sector # is 0 in first 'A' event and not listed again until the 'C'
 *       event.  Makes matching really hard, especially since a multiple of these commands were queue'd
 *       up and then completed.  The matching software will consider them just 1 io and keep replacing 
 *       the io over and over and driving up the inflight count as it should but first complete, will complete
 *       the only io on sector 0 present resulting in bad inflight and other issues.  At least special case this
 *       and toss the io out if its a FWC and 0+0 aka sector 0, 0 length.
 *       8,97  25       31     0.000244187 29074  A FWS 0 + 0 <- (253,2) 0
 *       8,96  25       32     0.000244444 29074  Q FWS [(null)]
 *       8,96  25       33     0.000247287 29074  G FWS [(null)]
 *       8,96  25       34     0.000247373 29074  P   N [(null)]
 *       8,96  25       35     0.000248195 29074  I FWS [(null)]
 *       8,96  25       36     0.000248314 29074  U   N [(null)] 1
 *       :
 *       8,96  27        1     0.005730559     0  C  WS 0 [0]
 *       There is already code that deep sixes at least the FWS 0+0 case, not sure about the other events
 *       other than they'd likely follow since we don't have a sector number. And that is probably why, the
 *       first sector this will operate on is <none> because of the 0 lenght.
 *
 *       Create a "dumped" events log file where we dump unmatched or special cased events that we
 *       normally would process for some reason, like above, cant or wont.
 *
 *       create separate awaits for reads and writes (plus them together)
 *
 *       %E-unknown action ',' '  8,0    8     5673     4.278109050  8,0   11   143937    13.872930385  5166  P   N [fio]'
 *       %E-unknown action '8' '  8  8,0   13    83741    13.876421214  5163  Q   R 13683720 + 8 [fio]'
 *       %E-unknown action '1' '  8,0    8,0   10   171096    14.808609211  5165  G   R 12884304 + 8 [fio]'
 *         8,0    8     5671     4.278074423  5134  P   N [fio]
 *         8,0    8     5672     4.278108889  5134  A  WS 19205632 + 512 <- (8,1) 19203584
 *         8,0    8     5673     4.278109050  8,0   11   143937    13.872930385  5166  P   N [fio]    << here
 *         8,0   15   139082    13.872931424  5164  A   R 18904504 + 8 <- (8,1) 18902456
 *         8,0   15   139083    13.872931611  5164  Q   R 18904504 + 8 [fio]
 *
 *         8,0   11   143951    13.872963629  5166  P   N [fio]
 *         8,0   11   143952    13.872964000  5166  I   R 15597248 + 8 [fio]
 *         8  8,0   13    83741    13.876421214  5163  Q   R 13683720 + 8 [fio]                       << here.  this is blktrace on 2.6.32 but may be binary data?
 *         8,0   11   144344    13.876421439     0  C   R 14897360 + 8 [0]
 *         8,0    0    46849    13.876421890  5166  I   R 4693312 + 8 [fio]
 *         8,0    0    46850    13.876422321  5166  U   N [fio] 1
 *         8,0   15   139724    13.876422624     0  C   R 1215352 + 8 [0]
 *
 *         Need to profile this again on large files.  The per second output gets slower and slower indicating 
 *         sometype of issue.
 *
 *         Add a actual timestamp on "DBG[03571]: SEC     76" event output.
 *
 *
 *       
 */
/* NOTES:
 * on Linux 3.10.0-327.36.2.el7.ppc64  -- no 'A' events, just 'Q', but could be configuration as no lvm in use
 */
 
/*
  Dev   CPU      Seq    Time        PID    E  Ty
  8,4   18        1     0.000000000 30916  A  WS 86730056 + 8 <- (253,1) 44785480
  8,0   18        2     0.000000923 30916  A  WS 173237576 + 8 <- (8,4) 86730056
  8,0   18        3     0.000001721 30916  Q  WS 173237576 + 8 [mysqld]
  8,0   18        4     0.000004895 30916  G  WS 173237576 + 8 [mysqld]
  8,0   18        5     0.000006937 30916  P   N [mysqld]
  8,0   18        6     0.000007879 30916  I  WS 173237576 + 8 [mysqld]
  8,0   18        0     0.000011862     0  m   N cfq30916S / insert_request
  8,0   18        0     0.000013135     0  m   N cfq30916S / add_to_rr
  8,0   18        7     0.000019898 30916  U   N [mysqld] 1
  8,0   18        0     0.000022715     0  m   N cfq workload slice:100
  8,0   18        0     0.000024446     0  m   N cfq30916S / set_active wl_prio:0 wl_type:1
  8,0   18        0     0.000026738     0  m   N cfq30916S / fifo=(null)
  8,0   18        0     0.000027820     0  m   N cfq30916S / dispatch_insert
  8,0   18        0     0.000030090     0  m   N cfq30916S / dispatched a request
  8,0   18        0     0.000031289     0  m   N cfq30916S / activate rq, drv=1
  8,0   18        8     0.000031626 30916  D  WS 173237576 + 8 [mysqld]
  8,0    6        1     0.000115301     0  C  WS 173237576 + 8 [0]

          Q           I           D           C CPU   PID Type Size  Sector        Name
0.000001721 0.000007879 0.000031626 0.000115301 18* 30916 WS      8  173237576 + 8 [mysqld]
*/

/*
 * NOTES:
 *   On 2.6.32 - 3.10 you get Q,I A,Q,M(erge into previous I), AQM... AQM... D of all the merged io.
 *   so need to process M by looking for existing event that this M can abut into end or front 
 *   merge.  Right now, the A action triggers a separate event creation. I'm ignoring the A->Q
 *   time and just starting from Q time.  The M time is then the insert time for the io and A->M
 *   accounts for sort/merge time, adding this io to the existing event.
 *
 *   This *might* be different on 2.3.* - 2.6.18
 */

/* 
 * Known bugs
 * BUG: if 'C' happens as first event, program crashes!
 *      workaround: edit input file, change C to U which is skipped
 * BUG: in-progress count ok, but in-flight counter is not reliable at this time -- likely
 *      not out processing individual io within merged io context correctly as count
 *      keeps increasing rather than cycling back to zero at idle.
 * BUG: in-progress count may be off on heavy load in that first part of blktrace file
 *      can have a lot of events that don't get "consumed" properly by D and C events
 *      inflating the initial count with a high baseline value. Needs more controlled
 *      testing and a way to weed out early what-will-become orphans.  Maybe a delayed
 *      "inclusion" list setting so the early events are held on the list on a provisional
 *      basis and we buffer dumping out completing events through some type of fifo allowing
 *      the program to proactively fix things by removing early orphans.  The fix is complicated
 *      to the point that not likely to get implemented.
 */


/* 
 * History:
 * 08.24.2020 + chg: set cpu and pid to -1 at event allocation time.  Need to be able to figure out whether
 *                   these fields captured a value previously or not.  First event's cpu number is captured,
 *                   whether A or Q.  Ditto with pid.  Except for pid, it is also captured when a pid name
 *                   is available too -- typically at Q but not at A (remAp).
 * 08.24.2020 + bug: 'UT' events weren't being handled in a fully correct manner.  The code did not expect
 *                   anything but a single character action code.  Added 'UT' detection.  This is set to a 'T'
 *                   event rather than a 'U' event.  The 'T' event will force se UnplugCount = PlugCount - 1.
 *                   With the expectation the another 'U' event is right after to reduce this this 0.  At least
 *                   that appears to be what is happening.  Although we'd have to look at the kernel code itself
 *                   to be sure.  Also, there are cases such as P/U/U that the unplug count appears to be going
 *                   negative.  Or trying to.  This may be some type of failsafe within the kernel.  When that happens
 *                   instead of a %Error being output, downgrade that to a %Warning.  And downgrade the %Warning for
 *                   events detected early in the input file to a %Informational.
 * 08.20.2020 + rfe: at parse.out closure, end the file with %I-success, eof message so we know parsing 
 *                   complete.  Need to key off of something in blktrace_parse.bsh so it knows it was 
 *                   a successful parse -- too many %Fatal exists or core.* dumps happening without 
 *                   visibility into same.
 *                   Added a message at all fclose(outf) as to what program is closing for.
 
 * ----------------- blktrace_parse.c-2020.07.27.215413 (end)
 * ----------------- ==============================================================================================================
 * ----------------- ==============================================================================================================
 * ----------------- This set of patches includes major changes including the new "state" machine for 
 * ----------------- tracking inprogress and inflight io.  I'd like to say this set of patches is stable
 * ----------------- but that remains to be seen.  This is the first checkpoint that we need to seriously
 * ----------------- apply QA with a line by line comparison of per event output between F1.7 and F1.6 and
 * ----------------- earlier created parse.out files. This will be the last checkpoint until full QA process
 * ----------------- is written and applied.         
 * 07.29.2020 + bug: find_event() fails to properly locate/match and event to a 'C' event in 
 *                   the following case for some reason.  Since there is no match, the statistics
 *                   aren't properly updated and result in off by 1 assertion failure.
 *
 *                     8,16  15    36400    29.967766436     0  C  WS 3081696 + 64 [0]
 *                     DBG[06934]: choice = check_event_mask( new 0x6330e0, event 0x10b0910, last (nil) )
 *                     DBG[06935]: choice        (nil) ...........:           0,       0
 *                     DBG[06936]:    new     0x6330e0 .........C.:     3081696,      64
 *                     DBG[06937]:  event    0x10b0910 .Q.....ID..:     3081696,      64
 *                     DBG[06938]:   last        (nil) ...........:           0,       0
 *                     DBG[01619]: assert fail( mainio_on_list 2 != 3 state.inProgress)
 *
 *                   it should have matched on 'event' above but didn't.  This is only happening
 *                   when overlapping io are detected, otherwise find_event() works which means this
 *                   is issue in the check_event_mask() logic which is attempting to find "best" match
 *                   and prevent selection of the wrong event -- but there are two types of overlapping
 *                   io, and this is 2nd auxiliary type.  The first type is exact match sector N,len
 *                   and the 2nd is one which has a different starting sector and length but does overlap
 *                   another active io.  In the 2nd case we should still be able to do a a "fast" first
 *                   match logic in find_event().  Still, the above is a bug and needs to be understood
 *                   and fixed.
 *
 * 07.29.2020 + bug: event->rw can has subtle type (rw) changes for same io across events,
 *                   specifically seeing FWFSM change to .W.SM in later events.  This change
 *                   in type may cause find_event() issues in that rw only end up capturing
 *                   last type -- WSM... but if that changes to WS later then type would be
 *                   simply flagged as 'W' vs prior it was of main type 'M'.  This isn't happening
 *                   in the case of FWFSM -> WSM changes, but there could be some cases where
 *                   if might.  So, if a scan of active list fails to find an event match, retry
 *                   with relaxed rules to see if a second pass can find a match.
 *
 *                   @@@TBD
 *
 * 07.18.2020 + rfe: in stdout count the number of %W and %E type events and output summary
 *                   of number and type at end.
 *                   --bgn------------------------------------------------
 *                     8,16   9   110972    34.411551921  6876  Q  WS 6395232 + 64 [dd]
 *                     %W[02119]-event for 6395232:64 {[dd]} not found in mainio_list
 *                     --end------------------------------------------------
 *                   As these can indicate orphans.
 *
 *                   @@@TBD
 *
 * 07.18.2020 + bug: the checking logic for typ_events is pretty much wrong order, the 
 *                   correct order for efficiency is to check the lba (sector) first,
 *                   then size, then major,minor as maj,min will typ be a match but
 *                   key info to match on is the lba first and foremost.  Since the
 *                   code now has to check all active io for best match, check key
 *                   differentiators first.  Also, take a look at detecting overlapping
 *                   io each time you add an io to the main list?  That way if there
 *                   are no overlapping io can just do the first match.  That case will
 *                   be by far the most common, especially in production io load environments.
 *                   Typically only seeing overlapping io pop up in fio and other artificial
 *                   load benchmark/testing circumstances.  Also try to add detection or
 *                   at least flagging of suspected "orphan" io -- io that is outstanding
 *                   for more than 4x, 5x? the max completed io time.  Only do this 
 *                   tracking after some N number of io have completed so you have a reasonable
 *                   view on max io time.  When you first hit that magic number, and for every
 *                   X io after that, re-look at the list and re-mark suspected orphans.  If an
 *                   io completes that is an orphan, mark its event output in some manner to 
 *                   visually flag it as same.  At end of run, output the active io list.. but
 *                   only actually output orphans unless some additional flag of "all io at end"
 *                   is set.  Orphans can happen for a number of reasons include bad input within
 *                   the blktrace.txt file.
 *
 *                   Example: (different starting lba, but overlap detected), note the double 'C' events
 *                   on these io (on 2.6.18).  These appear to be serialized in that the FWFSM io are only
 *                   allowed one at a time past 'D'ispatch? Right after the 2nd 'C' event on this io, the
 *                   next FWFSM io is released.
 *                     8,16   1     1387    29.913918681  4754  Q FWFSM 757449258 + 3 [kworker/1:1H]
 *                     8,16   1     1388    29.913921777  4754  G FWFSM 757449258 + 3 [kworker/1:1H]
 *                     8,16   1     1390    29.913923777  4754  I FWFSM 757449258 + 3 [kworker/1:1H]
 *                     8,16  10    53578    29.963915184  4923  Q FWFSM 757449261 + 3 [xfsaild/sdb]
 *                     8,16  10    53579    29.963915840  4923  G FWFSM 757449261 + 3 [xfsaild/sdb]
 *                     8,16  10    53581    29.963916469  4923  I FWFSM 757449261 + 3 [xfsaild/sdb]
 *                     8,16   0   698611    30.168558133     0  D WSM 757449258 + 3 [swapper/0]
 *                     8,16   0   698612    30.168630799     0  C WSM 757449258 + 3 [0]
 *                     8,16   0   698613    30.179660392     0  C WSM 757449258 [0]
 *                     8,16  15    36995    30.179663116  6876  D WSM 757449261 + 3 [dd]
 *                     8,16  10    53583    30.179744298     0  C WSM 757449261 + 3 [0]
 *                     8,16   0   698614    30.190764807     0  C WSM 757449261 [0]
 *
 *                     # . Typ = 'R'ead, 'W'rite, 'D'iscard, 'B'arrier, or 'N'one (!write & bytes!=0:ioctl?).
 *                     #         'F'lush, but only if this is BEFORE the R|W|D|N letter code
 *                     #         'F'ua,   but only if this is AFTER  the R|W|D|N letter code
 *                     #         'S'yncronous, 'M'eta, or Read'A'head 
 *                     #         note: the above codes are set within the binary data within the kernel before data is exported.
 *                     #         note: 'B'arrier seems to have been dropped from latest upstream blkparse utility.
 *                     So, this io is 'F'lush, 'W'rite, 'F'ua (force write through), 'S'ync, 'M'eta. How special. ... so at
 *                     least on 2.6.18 we should cache recent FWFSM io after completion so we can find/match the "expected"
 *                     2nd completion event.... *and* verify that only one FWFSM io is at/past D at any given time (again,
 *                     might only be a 2.6.18'ism). Upon completion, the F.F.. is missing in the event.
 *
 *                     @@@TBD
 *
 *
 *
 * 07.14.2020 + bug: overlapping io to same sector/same size...
 *                   8,0    3    26308    13.359710367  5164  A   R 1071088 + 8 <- (8,1) 1069040
 *                   8,0    3    26309    13.359710578  5164  Q   R 1071088 + 8 [fio]
 *                   8,0    3    26310    13.359712780  5164  G   R 1071088 + 8 [fio]
 *                   8,0    3    26312    13.359714273  5164  I   R 1071088 + 8 [fio]
 *                   8,0   10    26547    13.359775676  5165  D   R 1071088 + 8 [fio]              < 1st io to this sector
 *                   8,0   14    33903    13.359948433  5166  A   R 1071088 + 8 <- (8,1) 1069040   < 2nd io to this sector, 1st one not done yet
 *                   8,0   14    33904    13.359948603  5166  Q   R 1071088 + 8 [fio]	
 *                   8,0   14    33905    13.359953861  5166  G   R 1071088 + 8 [fio]
 *                   8,0   14    33907    13.359957133  5166  I   R 1071088 + 8 [fio]
 *                   8,0   15    46747    13.360023190     0  C   R 1071088 + 8 [0]		   < assuming this is 1st one, its only one with D event
 *                   8,0   10    27023    13.362259357     0  D   R 1071088 + 8 [swapper/1]	   < immediately dispatch 2nd io to same sector
 *                   8,0    7    54066    13.362394795  5166  C   R 1071088 + 8 [0]		   < complete 2nd io
 *
 *                   In the above case, with various overlapping amounts of io from different threads to same block, 
 *                   not much we can do except a) make sure match up is to first and best which is first/oldest io
 *                   .and. one that has the requisite dispatches.  The 2nd 'A' above may or may not create a 2nd event
 *                   ditto for Q,G,I et.al.  if it does a find_event() it will find one and try and reuse it.  Check the
 *                   event_mask to see if this.action is already present in the event -- if so then for 'A' and 'Q' events
 *                   the program needs to realize it needs to create a new event.
 *
 * 07.14.2092 + rfe: more tweaks to state tracking, added counters for 'M' and 'F', fixed fmerge_io() to match
 *                   bmerge_io().
 * 07.14.2020 + rfe: added needed merge (M,F) code tracking for state/annotated file.  Update D and C events
 *                   to work with merged main events as previously if merge_count was non-zero, they skipped
 *                   state update, but that left Q events accounting for incoming io, but since they never
 *                   outprocessed within the state, the inprogress counts accumulated drift.
 *
 *                   Reduce ticket output size from %12lu to %10lu, add q2d and d2c bias at end of line.
 *
 *                   If 'D' event .and. plug state set, then flag this event with @ after ; in annotation
 *                   to indicate oddity.  This can happen if the 'D' is one one CPU but the plug event was
 *                   processed on different CPU... there is a timing race window in which 'D' events on other
 *                   CPU that are already past the plug check gate can squirt through.  A post processor could
 *                   verify this type of race and quantify how big it is based emperically on the data available.
 *
 *                   There is a problem with the way the state is used on A,Q,M... io.  A ticket is assigned at
 *                   first A/Q event, then at merge the io is added to subio and the I,D,C master ticket numbers
 *                   advanced to indicate that this ticket "completed" - a ghost completion.  The problem is then
 *                   bias q2d calculation will be off by these ghost completions.  The main event has the first
 *                   assigned ticket, but the ticket for D will be after these ghost io seemily showing a bias
 *                   that isn't really there. So, maintain a QSeqNo_Ghost value in event.  This will be same as
 *                   first assigned Q ticket, but then updated if any subio are merged in.  The QGhost will be
 *                   the largest Q ticket assigned to any subio in the set.  Then q2d bias will use this number
 *                   to compute the sort bias for the io event (0=no scheduler sort order, + values indicate
 *                   delayed io, - values indicate the io jumped the line on other io within the scheduler due
 *                   to sorting.
 *
 *                   A similar issue is present for Requeues, theoretically, but we're not assigning new D ticket
 *                   numbers on requeue.  Or shouldn't be.  The original dispatch ticket should remain.  However,
 *                   if needed (tbd), can capture current state.DSeqNo in a event.DSeqNo_Ghost at requeue -- this
 *                   isn't a ticket assignment/use of the ticket but just a snapshot of its value.  But I'm not
 *                   sure that really is a good idea -- will need to postpone looking into that with more real
 *                   world examples, but am adding this to event structure for a TBD/future use just in case.
 *                   This will be a reminder to look into this in future.
 *
 * 07.13.2020 + rfe: state tracking code getting closer, you can have nested plugging, account for this.
 *               
 *    8,16   0      761    16.327508788   982  P   N [jbd2/sdb1-8]                              ; 
 *    8,16   1      410    16.327510011 13581  Q  WS 77048 + 32 [ora_ckpt_stop1b]               ; P1         405            0            0|  14:   0,  14|   0:   0,   0
 *    8,16   0      762    16.327511504   982  A  WS 935781712 + 8 <- (8,17) 935779664          ; P1         406            0            0|  15:   0,  15|   0:   0,   0
 *    8,16   0      763    16.327511821   982  Q  WS 935781712 + 8 [jbd2/sdb1-8]                ; P1         406            0            0|  15:   0,  15|   0:   0,   0
 *    8,16   0      764    16.327514564   982  M  WS 935781712 + 8 [jbd2/sdb1-8]                ;
 *    8,16   0      765    16.327515704   982  A  WS 935781720 + 8 <- (8,17) 935779672          ; P1         407            0            0|  16:   0,  16|   0:   0,   0
 *    8,16   1      411    16.327516004 13581  G  WS 77048 + 32 [ora_ckpt_stop1b]               ;
 *    8,16   0      766    16.327516048   982  Q  WS 935781720 + 8 [jbd2/sdb1-8]                ; P1         407            0            0|  16:   0,  16|   0:   0,   0
 *    8,16   0      767    16.327516758   982  M  WS 935781720 + 8 [jbd2/sdb1-8]                ;
 * #  8,16   1      412    16.327516881 13581  P   N [ora_ckpt_stop1b]                          ;
 *    8,16   0      768    16.327517504   982  A  WS 935781728 + 8 <- (8,17) 935779680          ; P2         408            0            0|  17:   0,  17|   0:   0,   0
 *    8,16   0      769    16.327517834   982  Q  WS 935781728 + 8 [jbd2/sdb1-8]                ; P2         408            0            0|  17:   0,  17|   0:   0,   0
 *    8,16   0      770    16.327518521   982  M  WS 935781728 + 8 [jbd2/sdb1-8]                ;
 *    8,16   1      413    16.327519411 13581  I  WS 77048 + 32 [ora_ckpt_stop1b]               ; P2         405            0            0|  17:   0,  17|   0:   0,   0
 *    8,16   1      414    16.327520531 13581  U   N [ora_ckpt_stop1b] 1                        ;
 *    8,16   1      415    16.327522014 13581  D  WS 77048 + 32 [ora_ckpt_stop1b]               ; P1         405          407            0|  17:   0,  17|   1:   0,   1
 *    8,16   0      771    16.327527674   982  I  WS 935781704 + 32 [jbd2/sdb1-8]               ; P1         404            0            0|  17:   0,  17|   1:   0,   1
 * #  8,16   0      772    16.327528884   982  U   N [jbd2/sdb1-8] 1                            ;
 *                                                                                              ; U
 *
 * 07.10.2020 + rfe: add P/U counter, add A/Q, D, C counters -- at least initially for any non-merged io.
 *                   output an annotated file with just A/Q, D, C counters showing sched io reorder amount
 *                   and storage reorder amount if any.  Also measure/report delta event count and time
 *                   at A/Q to previous D,C.  Looking for things like a bunch of C events happen but no
 *                   queued/pending io is pushed out via D events.  As well as, in a full io sched queue
 *                   with pending io, what is the C->D delta.  We think of this as being close to zero, but
 *                   is it really sub-ms or longer? and if longer how often and why?
 *                   Output orphan (pending) io count, difference between D and C counts, difference between Q and D,
 *                   difference between Q and C,
 *                   whether P or U status
 *                   difference between D and D' (ticket # captured at Q) reorder amount in scheduler
 *                   difference between C and C' (ticket # captured at D) reorder amount in storage
 *                   for Q, the amount could be seek amount between adjacent Q events?
 *                   event count and delta time for Q, D, and C. for example @C, since last C, 0 C events #ms, N D/Xms, N Q/Xms...
 *                   if there are a bunch of C,C,C,C,... same events in a row, then the base time is first C event and on 2nd-nth C events
 *                   in chaing the count keeps going up and recent to first in sequence is the delta time output.  So count = 0, dTime
 *                   is to last event of same type, if count non-zero its to first in this sequence chain.  For example, Q, C,c,c,c,c...
 *                   then Q, te C count is large number and at 2nd Q event. We're interested specifically in D event relationship to C
 *                   when there are alarge number of pending io in the scheduler queue.
 *                   On 3.10, the sequence for an IO will be A,Q,G or A,Q,M ... (except for NVMe which will be just A,Q or Q?)
 *                   Anyway, assigning a sequence ticket number to a subio is "bad" in that, at least in 3.10, there is only 1
 *                   dispatch and 1 complete event for the whole request vs one per subio as in 2.6.32. Soooo.... in 3.10,
 *                   don't assign QSeqNo until 'M' or 'G' event?  But with per CPU queues, this means an io queued on one cpu
 *                   before a 2nd on another cpu can be given an out of order ticket service number... what to do, what to do...
 *                   Maybe create a registration fifo for sequence numbers, and when you want one you need to commit at G or M
 *                   or worse case at I time.  But aren't actually given one until all io before you in the fifo also commit...
 *                   Really kinda more complicated than at first blush. A cheaper "cheater" method would be to toss the sequence
 *                   number for a 'M' event which also means advancing I,D, and C sequence numbers as if the 'M' bio queued,
 *                   inserted, dispatched,completed immediately at least for ticket number purposes.
 * ----------------- ==============================================================================================================
 * ----------------- ==============================================================================================================
 * ----------------- blktrace_parse.c-2020.07.27.215413 (bgn)
 *
 * ----------------- blktrace_parse.c-2020.07.10-090649 (end)
 * ----------------- no changed. source code same per diff -PurN
 * ----------------- blktrace_parse.c-2020.07.10-090649 (bgn)
 *
 * ----------------- blktrace_parse.c-2020.07.10-084912 (end)
 * ----------------- several event types were not being processed, like 'Sleeps' and we added processing
 * ----------------- of them but didn't tag events with a sleep count like we did with requeues.  
 * 07.10.2020 + rfe: add sleep count output along with requeue count on individual io event line output
 * 07.09.2020 + rfe: skip comment lines encountered (lines beginning with '#').  A header was added
 *                   to the blkparse output file by the parse script and this program needs to skip
 *                   those lines.
 * 07.08.2020 + rfe: add Slp companion (sleep) column to Req (requeue) as these are showing up in
 *                   greater and greater numbers in perf case.  And although I log the count at the
 *                   end of the event, I don't see 'S'leeps on individual io so can't tell when they
 *                   start and/or when they stop.  The 'S'leep should only happen once per io so 
 *                   adding an 'S' on requeue count should do it. But add an assert/warning if the cnt_sleep
 *                   is > 1 per io just in case. I suppose there is a timing hole that could cause
 *                   multiple sleeps, but shouldn't be very likely.
 * ----------------- blktrace_parse.c-2020.07.10-084912 (bgn)
 *
 * ----------------- blktrace_parse.c-2020.06.04-193248 (end)
 * ----------------- no changes, code is same/same per diff -PurN
 * ----------------- blktrace_parse.c-2020.06.04-193248 (bgn)
 *
 * ----------------- blktrace_parse.c-2020.05.23-082951 (end)
 * ----------------- minor changes in summary/accumulator alert output formats
 * 05.23.2020 + chg: tweak output of alerts in SEC/SUM blocks, fix spelling.
 * ----------------- blktrace_parse.c-2020.05.21-082951 (bgn)
 *
 * ----------------- blktrace_parse.c-2020.05.21-130753 (end)
 * ----------------- accumulator changes & bug fixes, like boundary is a double not integer!
 * ----------------- these include critical bug fixes
 * 05.21.2020 + bug: in merging SEC/SUM code, didn't change all references from accum to summ where
 *                   appropriate so that actually summary data was *not* being output.
 * 05.21.2020 + chg: add "to_be_continued" to dump to help inhibit header after SUM: section, 
 *                   since now the two SEC/SUM are merged.
 * 05.21.2020 + bug: accum boundary is a double and it was being treated as integer, change printf
 *                   so they work correctly with double value. Added debug output to stdout.
 * 05.21.2020 + bug: in some cases on a 1s boundary, there were no actually data movement read or write
 *                   commands.  Protect against this corner case.
 * ----------------- blktrace_parse.c-2020.05.21-130753 (bgn)
 *
 * ----------------- blktrace_parse.c-2020.05.21-123000 (end)
 * ----------------- added show_config() and similar config weaks.
 * 05.21.2020 + chg: changed around the option letter values and case for different options.  Don't allow
 *                   an alignment check of 0, force at least 4k (8 sector) if set to zero (implies used
 *                   default).  If you want 1 sector alignment checking(?) then use 1 rather than 0 or 
 *                   just turn off alignment checking altogether.
 * 05.21.2020 + chg: the SEC and SUM output sections merged into one main routine rather than basically
 *                   two copies of the same print/formatting.  Having just 1 copy will keep them in sync.
 * 05.21.2020 + chg: add output of current configuration parameters to the header of the output file.
 *                   change default location for account config from ~/.blktrace to ~/.config/blktrace
 * 05.21.2020 + bug: added missing summ.cnt_inserts++ bump, was only tracking in 1s accumulator and not
 *                   total run summary stats struct. Ditto with cnt_dispatches.
 * 05.21.2020 + bug: removed smerge info from bucket output, really does not belong on that line
 * ----------------- blktrace_parse.c-2020.05.21-123000 (bgn)
 *
 * ----------------- blktrace_parse.c-2020.05.20-225629 (end)
 * ----------------- set of patches adding d2d tracking and output, revamped output line format
 * 05.20.2020 + rfe: revamp the per event output line to include D2D column if specified.  Whether
 *                   included or not, this splashed over to change a number of field widths and 
 *                   change the Q2x(dt) fields to now be displayed in ms as opposed to previously
 *                   in seconds.  This range change allows some column field output size reductions,
 *                   specifically in the D2D and Q2I fields which typically are of very short duration
 *                   (aka had a lot of leading zeros that was just taking up valuable line space).
 *                   As part of this output overhaul the max cpu field was reduced from 9999 cpus to
 *                   just 999 and the size field was reduced from 9,999,999,999 sectors to just 9999 sectors,
 *                   which is enough for 4MB per io transfers (hopefully that is good for almost all
 *                   configurations unless something tweaks per io transfer max to 8MB or larger).
 *                   Sector field reduced by 1 in width, supports 999TB drives, and seek increased by
 *                   1 to account for sign in negative seeks across large drives.  Added accounting
 *                   checks to the fields which will output complaints if the new default field widths
 *                   are too small for current data set.  This is only checked on individual event level.
 *                   The result of all the tweaks is the per event line is 4 characters less in length
 *                   when the D2D column is added.  Without the D2D column, 2 extra digits of resolution
 *                   are added back into Q2x columns -- the 2 digits were removed when the %d2c time
 *                   field was added a while ago. The cumulative changes above allows the extra resolution
 *                   to be added back when D2D column isn't preset.  This still is a 2-3 characters shorter
 *                   output line than before (and these per event lines are loooonggg so managing them is
 *                   important).
 * 05.20.2020 + bug: recently introduced bug erroneously incremented cnt_requeue on and event only
 *                   on first requeue as opposed to on any requeue.  Don't this this hurt anything
 *                   at summary level as separate read v write requeue counts are being tracked, but
 *                   on individual events the reQ count would only ever show 0 or 1.
 * 05.20.2020 + rfe: add 'noreset_on_requeue' and 'include_d2d' configuration file options, parse and
 *                   set.  The noreset_on_requeue is same as -R flag but including it in the conf file
 *                   allows both user and specific data set settings to be established without having
 *                   to change the blktrace_parse.bsh script.  The include_d2d forces a separate D2D
 *                   output column between Q2D and D2C to separately account D2D times associated with
 *                   requeues.  The noreset_on_requeue and -R flag is ignored if the include_d2d config
 *                   option is set.
 * 05.19.2020 + rfe: for grins, add a flag to calculate d2c' using first dispatch time vs last 
 *                   dispatch time.  With the new flag set, the first_requeue struct field is used
 *                   to capture the original/first dispatch to storage so we can see what q2d time
 *                   really shoulda been.  Right now when a ton of requeues happen the derived q2d
 *                   time from the report q2d = (avg await(q2c) - avg storage(d2c)) looks really big
 *                   but in fact its faked out because of the constant requeues that are happening.
 *                   Look into the possibility of showing this 2nd time in some meaningful way permanently
 *                   like maybe a (+00.00)ms at the end of d2c to reflect the d2r2r2r2d times.  Something
 *                   so that we have a been explicit view of the Q2D^1 time (Q to first dispatch).  This
 *                   is real corner casey in that requeues as so bad they really should be addressed...
 *                   but "really bad" is a subjective quantity and we need to assign a specific value to
 *                   "really bad".  Can't absolutely as requeues indicate an issue with other consequences
 *                   other than just we we're seeing in the blktrace data, but can measure what we see 
 *                   and present the data at least.
 * 05.19.2020 + rfe: add requeue count to end of device summary line in group output.  This will just
 *                   allow a quick assimilation of q2c v d2c times ... if they d2c seems smaller than
 *                   usual % of q2c and requeue count non-zero then that may explain that behavior.
 * ----------------- blktrace_parse.c-2020.05.20-225629 (bgn)
 *
 * 05.19.2020 + bug: never added parsing in read_event() for 'R' or 'S' events, so this just added those
 *                   to the current event -- which created bad d2c among other things.
 * 05.18.2020 + rfe: some files being fed into the parser do not have any D or C events, just Q events,
 *                   100,000s of them.  This causes the program to build/juggle bigger and bigger active
 *                   data sets that it really never was designed to do.  So, if we reach N lines of input
 *                   (some arbitratily large number) and no C events have occurred then just give up. Add
 *                   a flag to force it to continue, just in case -- but the flag is off by default.
 * 05.11.2020 + rfe: output events to *.buckets file with bucket # @bgn of line
 * 05.11.2020 + rfe: add key to hotlba for %io %xfer %await and %d2c
 * 04.20.2020 + rfe: expand SUM: and per io transfer table to be wider, longer blktrace is creating accumulated
 *                   total values that don't fit into 14.6.
 * 03.29.2020 + rfe: add "group" code. This requires the program output data it prints out to a binary file
 *                   format of <devicename>.blkparse.bin or something.  Each run on a device at the end closes
 *                   its binary file then reads in, adds to the data any other paths provide and outputs a 
 *                   <groupname>.blkparse.out file.  After running over all the devices, groupname should be
 *                   a full merged set of summary data.  Do this just for summary data for now, but should 
 *                   extend this to the individual device data too. Starting with the hotspot data as proof
 *                   of concept.
 * 03.36.2020 + rfe; add "hotspot" code.  It tracks each io within a "bucket" of sectors, how many, how much
 *                   how long, what type, how many "seeks" into/outof the bucket etc.  Bare bones is working
 *                   so committing the change.  Needs tweeking/pretty print/percentages but right now its 
 *                   provides a rough overview of where the io hit on disk in relationship to other io.
 * 03.24.2020 + rfe: add read,write buckets for distribution of request size, %data and %time in 
 *                   each bucket.
 * 02.26.2020 + bug: found and fixed a bug associated with remap events.  New events were always
 *                   created for 'A' events.  Except in the following case two events were created
 *                   but the first is never ultimately used.
 *                   8,97   1        1     3.874638150  8828  A   W 1524403448 + 48 <- (253,2) 60129600760 << creates new event
 *                   8,96   1        2     3.874638648  8828  A   W 1524405496 + 48 <- (8,97) 1524403448   << should reuse/update the above event
 *                   So inflight (events on events_list) says 2, but really there is only 1 io.  The
 *                   original 253,2 remap to 8,97 and then that same io is remaped to 8,96.  This solves
 *                   the issue for this case.  But if there is 253,10 -> 253,4 -> 8,97 -> 8,96 then that
 *                   still could be a problem where there are two io present.  We'll need to see more practical
 *                   data to see if that occurs and what other combos.
 * 02.25.2020 + rfe: change [(null)] to [(nul):pid not found] meaning the pid lookup failed within
 *                   blkparse utility.  This can happen because the process exists before blktrace
 *                   captures the pid table.  This is different from [0] where the pid. Typically 
 *                   will see this on C events -- its just the stuckee pid for the completion interrupt.
 *                   The process that was running at C interrupt time isn't likely the process that
 *                   pushed to io to the device. Another common one is the flusher thread, its stuckee
 *                   to do the dirty work but wasn't the one actually creating the io.
 * 02.25.2020 + bug: add parsing of RWBS field's additional (and somewhat undocumented) other flags of F, A,
 *                   M, N, ... Added notes at end of file for these.
 * 02.25.2020 + bug: assumption that 'R' or 'W' would be first in RBWS field, but it may be 2nd, fixed.
 * 10.24.2019 + bug: there were two, nearly back to back, dump_event(main) calls which generated
 *                   double event output that was weird and just weird. Commented out 2nd call.  I've
 *                   no recollection of doing this or why if there was a why or was it just a cut/paste
 *                   snafu.  It was done via blktrace_parse.c-16072019-141938.patch which added the 
 *                   first dump_event(main) above accum and summ functions.  I *think* this was done
 *                   so accum wouldn't trigger a DBG 1 second sample dump until the current event
 *                   was output which means its was suppose to be a function move from below to above
 *                   those two functions, but ended up just adding a duplicate callout causing double
 *                   event output.  Commenting out the 2nd callout as it is redundant.
 * 09.03.2019 + chg: if 245 or 259 major device detected, then these events are from nvme devices
 *                   and so note within the output near the top/header.
 * 09.03.2019 + chg: add notes about nvme devices not having I or D event types.  
 * 09.07.2018 + rfe: performance,
 *              Each sample counts as 0.01 seconds.
 *               %   cumulative   self              self     total           
 *              time   seconds   seconds    calls  ms/call  ms/call  name    
 *              87.78    620.65   620.65   122096     5.08     5.08  check_in_progress
 *              12.09    706.15    85.50    86745     0.99     3.89  find_event
 *              0.04    706.46     0.31   5949240     0.00     0.00  strskip
 *              0.01    706.55     0.09   2661210     0.00     0.00  getdecnum
 *
 *              find_event() needs to hashed bucket lists, hashed by starting sector.  One
 *              for the whole io and one for sub-io.  Include a flag that allows brute force
 *              search (which is what is being done now) for sub-io ; the brute force should
 *              always fail if the hash bucket method failed.  When an io is deactivated 
 *              (completed), then it and each of its sub-ios need to be removed from the hash
 *              bucket.
 *
 *	        The check_in_progress() routine is a debug/validation checker for the event list
 *              to try and flag when the inprogress counter goes awry.  Since its really only
 *              for debug, it should be turned off by default.  Added flag_check_inprogress with
 *              default value 0.  'D' switch enables.
 *
 * 05.25.2017 + bug would output NaN if counts within transfer sector "bin'd[n]" array was zero. For
 *              example in the following output no io transfers were made with a size exceeding 31 
 *              sectors.  Fixed.
 *               #  Transfer
 *               #  Sectors      count
 *               #   0 -   7        42 Q2I:    0.001058980/ 0.000025214 Q2D:    0.000000000/ 0.000000000 Q2C:    0.005113125/ 0.000121741
 *               #   8 -  31         3 Q2I:    0.000005238/ 0.000001746 Q2D:    0.000100257/ 0.000033419 Q2C:    0.000757326/ 0.000252442
 *               #  32 - 511         0 Q2I:    0.000000000/        -nan Q2D:    0.000000000/        -nan Q2C:    0.000000000/        -nan
 *               # 512 -1023         0 Q2I:    0.000000000/        -nan Q2D:    0.000000000/        -nan Q2C:    0.000000000/        -nan
 *               #     >1023         0 Q2I:    0.000000000/        -nan Q2D:    0.000000000/        -nan Q2C:    0.000000000/        -nan
 *
 * 05.25.2017 + at completion event time, we're expecting I and D events to be present if
 *              there was a Q event.  It turns out that is not true for emcpowerpath devices.
 *              There is a Q and C events, but I and D aren't showing up in the blktrace data from
 *              the current customer.  Likely powerpath hooks the dispatch to use its own code 
 *              and blktrace events aren't part of that code.  Anyway, the bug was entries like:
 *
 *              DBG: dTime(sec)           Q2I(ms)        Q2D(ms)        D2C(ms)     Q2C(ms;await) ...
 *              DBG:     19 totals   -18273.970992 -350940.644046  350943.677692       3.033646   ...
 *              DBG:     19 avg        -870.189095  -16711.459240   16711.603700       0.144459   ...
 *
 *              This is due to the dTime math: dTime = event->actions.dispatch - event->actions.queue
 *
 *              Wne actions.dispatch is not present, that value is 0.0 so dTime becomes 0.0 - queue time
 *              aka negative seconds. Fixed this by always checking the the action is not 0.0.
 *              
 * 04.17.2017 + ignore for now any Q events that do not specify a sector as in:
 *                   253,178 23        2     0.126800189 16999  Q FWS [ora_ckpt_dumucm]
 *              versus expected:
 *                   253,178 23        1     0.126790341 16999  Q  WS 29638816 + 32 [ora_ckpt_dumucm]
 * 01.19.2016 + fixed bug whereby it "matched" sub-events only based upon sector/size and should have
 *              been matching on sector/size/major/minor number.  Doing the whole match as is done in
 *              find_event() within the sub-io matching fixed a bug where program became confused, matched
 *              on a partitions io for sub-io then rejected it as wrong device later on and thus didn't find any
 *              match. Should correctly find sub-io in those circumstances now.
 * 10.06.2016 + add handling for 'R'equeue events.  Not normally seen, but when they are the program
 *              goes a bit whacko in terms of the numbers it displays.  Add 'reQ' column in the output
 *              and output a %W- warning message at second boundary dump times.  Although the program
 *              will track read v write R actions/events within blktrace data, it will treate and output
 *              the two separate values as a summed value only ... at least for now.
 * 06.29.2016 + code not handling dispatch well in 2.6.32, see [1] example at end of file
 *              change dispatch code to find all events from starting sector to ending sector
 *              of dispatch that cover this dispatch.
 * 06.29.2016 + fix bug in find_event() when current_event=NULL
 * 11.27.2015 + applu lvm detect logic to 1 sec accum and total summ data. remove idle time from output
 * 11.20.2015 + detect lvm io and prevent lack of I and D events from causing whacky output.
 *              lvm dm- devices only have Q/C events, no I,D events which are associated within
 *              io scheduler... which the lvm device doesn't have.  So upon C for a lvm, the 
 *              inprogess counter is decremented making it go waaay negative due to no D event
 *              which would have incremented it.  Also Q2I and Q2D and D2C times will be negative
 *              because there are no I or D times for lvm io. 
 * 11.18.2015 + as part of the track merged io logic, also track Inserted io vs Completed io for
 *              a queue depth.  Start the queue depth at 0.  Any completing io that isn't matched
 *              in our event list elicits a %Warning output, but will not be counted against the
 *              running Q count.  Also the Q count should have two components, a queue count (which
 *              is really inserted count) and queue count, so in the example below, at insert time
 *              the count would be 1:5.
 * 11.18.2015 + currently merges aren't tracked and creates "orphan" io at completion.  For example:
 * 253,2    1        7     0.031298545 21925  Q   R 13470840352 + 96 [dd]
 * 253,2    1       10     0.031402981 21925  A   R 13470840448 + 128 <- (253,30) 107766707584
 * 253,2    1       11     0.031403285 21925  Q   R 13470840448 + 128 [dd]
 * 253,2    1       12     0.031404942 21925  M   R 13470840448 + 128 [dd]
 * 253,2    1       13     0.031488483 21925  A   R 13470840576 + 128 <- (253,30) 107766708608
 * 253,2    1       14     0.031488741 21925  Q   R 13470840576 + 128 [dd]
 * 253,2    1       15     0.031489379 21925  M   R 13470840576 + 128 [dd]
 * 253,2    1       16     0.031573222 21925  A   R 13470840704 + 128 <- (253,30) 107766709632
 * 253,2    1       17     0.031573531 21925  Q   R 13470840704 + 128 [dd]
 * 253,2    1       18     0.031574091 21925  M   R 13470840704 + 128 [dd]
 * 253,2    1       19     0.031647683 21925  A   R 13470840832 + 32 <- (253,30) 107766710656
 * 253,2    1       20     0.031647919 21925  Q   R 13470840832 + 32 [dd]
 * 253,2    1       21     0.031648390 21925  M   R 13470840832 + 32 [dd]
 * 253,2    1       22     0.031671221 21925  I   R 13470840352 + 512 [dd]
 * DBG[00416]
 * %W-event for 13470840352:512 not found in [dd]
 *    event 13470840832:32
 *    event 13470840704:128
 *    event 13470840576:128
 *    event 13470840448:128
 *    event 13470840352:96
 *              5 io were Q'd, but after merge only 1 was inserted.  Adding logic to detect merged
 *              io at I time and create a two tiered list.  A main list of inserted (and possibly merged) io
 *              and then any Q'd io associated with the Insert removed from main list and attached off the
 *              inserted/merged io.  Upon completion of the merged/Inserted io, all subparts hung off the merged
 *              io are completed too.
 */



/*
 *   Dev   CPU      Seq    Time        PID    E  Ty
 *   8,4   18        1     0.000000000 30916  A  WS 86730056 + 8 <- (253,1) 44785480
 *   8,0   18        2     0.000000923 30916  A  WS 173237576 + 8 <- (8,4) 86730056
 *   8,0   18        3     0.000001721 30916  Q  WS 173237576 + 8 [mysqld]
 *   8,0   18        4     0.000004895 30916  G  WS 173237576 + 8 [mysqld]
 *   8,0   18        5     0.000006937 30916  P   N [mysqld]
 *   8,0   18        6     0.000007879 30916  I  WS 173237576 + 8 [mysqld]
 *   8,0   18        0     0.000011862     0  m   N cfq30916S / insert_request
 *   8,0   18        0     0.000013135     0  m   N cfq30916S / add_to_rr
 *   8,0   18        7     0.000019898 30916  U   N [mysqld] 1
 *   8,0   18        0     0.000022715     0  m   N cfq workload slice:100
 *   8,0   18        0     0.000024446     0  m   N cfq30916S / set_active wl_prio:0 wl_type:1
 *   8,0   18        0     0.000026738     0  m   N cfq30916S / fifo=(null)
 *   8,0   18        0     0.000027820     0  m   N cfq30916S / dispatch_insert
 *   8,0   18        0     0.000030090     0  m   N cfq30916S / dispatched a request
 *   8,0   18        0     0.000031289     0  m   N cfq30916S / activate rq, drv=1
 *   8,0   18        8     0.000031626 30916  D  WS 173237576 + 8 [mysqld]
 *   8,0    6        1     0.000115301     0  C  WS 173237576 + 8 [0]
 * 
 *  Q           I           D           C CPU   PID Type Size  Sector        Name
 *  0.000001721 0.000007879 0.000031626 0.000115301 18* 30916 WS      8  173237576 + 8 [mysqld]
 */

/*
 * NOTES:
 *   On 2.6.32 - 3.10 you get Q,I A,Q,M(erge into previous I), AQM... AQM... D of all the merged io.
 *   so need to process M by looking for existing event that this M can abut into end or front 
 *   merge.  Right now, the A action triggers a separate event creation. I'm ignoring the A->Q
 *   time and just starting from Q time.  The M time is then the insert time for the io and A->M
 *   accounts for sort/merge time, adding this io to the existing event.
 *   
 *   This *might* be different on 2.3.* - 2.6.18
 *   
 */


/* 
 * Example #1 2.6.32
 * 253,1    0       37     0.001657115 30598  Q   R 13470872576 + 128 [dd]
 * 253,1    0       39     0.001658511 30598  I   R 13470872576 + 128 [dd]  << io 1
 *
 * 253,1    0       42     0.001759557 30598  M   R 13470872704 + 128 [dd]  <<    2nd, but 'M'erged into 1st above
 * 253,1    0       45     0.001855986 30598  M   R 13470872832 + 128 [dd]    
 * 253,1    0       48     0.001954240 30598  M   R 13470872960 + 128 [dd]
 * 253,1    0       51     0.002056999 30598  M   R 13470873088 + 128 [dd]
 * 253,1    0       54     0.002151445 30598  M   R 13470873216 + 128 [dd]
 * 253,1    0       57     0.002244665 30598  M   R 13470873344 + 128 [dd]
 * 253,1    0       60     0.002341004 30598  M   R 13470873472 + 128 [dd] <<     8th which are all merged into 1st above ...
 *                                                                         <<     Note: one Insert, 7 Merges, 1 Dispatch... but 8 Completions.
 *
 *
 * 253,1    0       92     0.003281266 30598  D   R 13470872576 + 1024 [dd]<<     and dispatched as 1 io... but then complete as 8(?)
 *
 * 253,1    0      884     0.078525372 30598  C   R 13470872576 + 1024 [0]    << completion of merged io
 * 253,1    0      885     0.078537160 30598  C   R 13470872704 + 896 [0]     << " " of subpart of merged io
 * 253,1    0      886     0.078542559 30598  C   R 13470872832 + 768 [0]     << ""       ""
 * 253,1    0      887     0.078547942 30598  C   R 13470872960 + 640 [0]     << ""       ""
 * 253,1    0      888     0.078553100 30598  C   R 13470873088 + 512 [0]     << ""       ""
 * 253,1    0      889     0.078570213 30598  C   R 13470873216 + 384 [0]     << ""       ""
 * 253,1    0      890     0.078574444 30598  C   R 13470873344 + 256 [0]     << ""       ""
 * 253,1    0      891     0.078578173 30598  C   R 13470873472 + 128 [0]     << ""       ""
 *
 * so, while the 8x128 sector io are merged into 1x1024 and dispatched as 1, they end up in blktrace
 * as 8 different 'C'ompletion events with decreasing size (subtracting off the size of the subio - 128 sectors -
 * after each completion.  This is a non-zero time sum, taking 0.05ms from start to end.  For now we're only
 * accounting for the first completion event and using that as 'C' time for all of them.  Something to tackle for
 * later on.
 *
 * Right now, the program ends up ignoring the 2nd-8th completion in that the 1st completion matched up with the
 * merged event and was removed from the mainio_list.  So 2nd-8th couldn't find a match.  Even if the 1st was left
 * on the list it wouldn't match because 2nd completion is for size 896 sectors, but 2nd io that was merged was 128 
 * sectors in size.
 */

/* Example #2 3.10.0
 *
 * 253,2    1        6     0.031297662 21925  A   R 13470840352 + 96 <- (253,30) 107766706592
 * 253,2    1        7     0.031298545 21925  Q   R 13470840352 + 96 [dd]  				[1]
 * 253,2    1        8     0.031302552 21925  G   R 13470840352 + 96 [dd]
 *
 * 253,2    1        9     0.031303758 21925  P   N [dd]
 *
 * 253,2    1       10     0.031402981 21925  A   R 13470840448 + 128 <- (253,30) 107766707584
 * 253,2    1       11     0.031403285 21925  Q   R 13470840448 + 128 [dd]				[2]
 * 253,2    1       12     0.031404942 21925  M   R 13470840448 + 128 [dd]
 *
 * 253,2    1       13     0.031488483 21925  A   R 13470840576 + 128 <- (253,30) 107766708608
 * 253,2    1       14     0.031488741 21925  Q   R 13470840576 + 128 [dd]
 * 253,2    1       15     0.031489379 21925  M   R 13470840576 + 128 [dd]
 *
 * 253,2    1       16     0.031573222 21925  A   R 13470840704 + 128 <- (253,30) 107766709632
 * 253,2    1       17     0.031573531 21925  Q   R 13470840704 + 128 [dd]
 * 253,2    1       18     0.031574091 21925  M   R 13470840704 + 128 [dd]
 *
 * 253,2    1       19     0.031647683 21925  A   R 13470840832 + 32 <- (253,30) 107766710656
 * 253,2    1       20     0.031647919 21925  Q   R 13470840832 + 32 [dd]
 * 253,2    1       21     0.031648390 21925  M   R 13470840832 + 32 [dd]
 *
 * 253,2    1       22     0.031671221 21925  I   R 13470840352 + 512 [dd]				[3]
 *
 * 253,2    1       23     0.031671546 21925  U   N [dd] 1
 *
 * 253,2    1       24     0.031671976 21925  D   R 13470840352 + 512 [dd]				[4]
 * 253,2    1       25     0.035647855     0  C   R 13470840352 + 96 [0]				[[5]
 * 253,2    1       26     0.035652707     0  C   R 13470840448 + 128 [0]
 * 253,2    1       27     0.035655721     0  C   R 13470840576 + 128 [0]
 * 253,2    1       28     0.035658757     0  C   R 13470840704 + 128 [0]
 * 253,2    1       29     0.035661274     0  C   R 13470840832 + 32 [0]
 *
 * [1] first io arrives, mAp event, and Queue but no insert (yet).
 * [2] a bunch of 4 other io arrive that can be Merged into this first one.
 * [3] finally the competed merged io is reported as Inserted into the sort queue.
 * [4] the merged io is dispatched
 * [5] and then 5 separate completions associated with each subio under the merged io is
 *     reported.  The dTime from 1st to 5th is .02ms, so program will adopt reporting on 
 *     completed io in this case only when finally io is drained off from the main event.
 *     That is, when the merge_count goes to zero.  Otherwise, the stats computed at io
 *     done time will seem to reflect much lower io request size, etc.
 *
 */

/* Example #3: 2.6.18
 * 253,384  3      238    54.151546687 25192  A   R 51588480 + 128 <- (253,385) 51588352   (vdy1)
 * 253,384  3      239    54.151546946 25192  Q   R 51588480 + 128 [(null)]
 * 253,384  3      240    54.151551145 25192  G   R 51588480 + 128 [(null)]
 * 253,384  3      242    54.151553723 25192  I   R 51588480 + 128 [(null)]
 * 253,385  3      243    54.151691142 25192  A   R 51588480 + 128 <- (252,15) 412705664   (dm-15)
 * 253,384  3      250    54.155267784   213  D   R 51588480 + 128 [(null)]
 * 253,384  5       49    54.157417721     0  C   R 51588480 + 128 [0]
 *
 * note that the 2nd 'A' remap event is not for vdy (253,384) but is a remap from dm-15 to vdy1
 * -- check the major,minor number at the beginning of the line.  These 2nd 'A' events need to
 *  be dropped so as to confuse the logic into thinking its missed D/C events for the 1st 'A'
 *  event.  Not sure I've seen the same behaviour in 2.6.32 - 3.10.0 blktraces (aka including not only
 *  the remap events from partition/dm devices to the whole physical device but including sub-
 *  events associated with the partitions too as full on events.
 *
 *  There's no easy way to determine what the major,minor number is for the base device, but
 *  for now assume first event specifies that.
 */



#include <stdio.h>
#include <string.h>
#include <strings.h>
#include <malloc.h>
#include <unistd.h>
#include <stdlib.h>
#include <math.h>
#include <execinfo.h>
#include <errno.h>
#include <stdarg.h>
#include <limits.h>
#include <time.h>
#include <dirent.h>
#include <signal.h>
#include <assert.h>
#include <fcntl.h>
#include <ctype.h>
#include <sys/timeb.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/prctl.h>


#include "trace.h"
#include "typ_blktrace.h"
#ifdef    SIGLIB
#include "siglib.h"
#endif 

#define ORIGINAL_RECIPE		/* Original Recipe includes expanded 12.9f format for event timing */ /* testing/validation purposes only */
#undef  ORIGINAL_RECIPE

#define nprintf
#define xprintf          				/* e'x'tra information		*/ /* compile time only */
#define tprintf    if  (flag_tracing != 0) printf	/* process 't'racking printf    */
#define dprintf    if ((flag_debug   != 0) && (flag_quiet == 0)) printf
#define d1printf   if ((flag_debug   >= 1) && (flag_quiet == 0)) printf
#define d2printf   if ((flag_debug   >= 2) && (flag_quiet == 0)) printf
#define d3printf   if ((flag_debug   >= 3) && (flag_quiet == 0)) printf
#define d4printf   if ((flag_debug   >= 4) && (flag_quiet == 0)) printf
#define dxprintf					/* never compile, placeholder for debug code we don't want to delete */
#define q0printf   if  (flag_quiet   <  1) printf
#define q1printf   if  (flag_quiet   <  1) printf
#define q2printf   if  (flag_quiet   <  2) printf
#define q3printf   if  (flag_quiet   <  3) printf
#define logIprintf if  (flag_quiet   <= 1) printf
#define logWprintf if  (flag_quiet   <= 2) printf
#define logEprintf if  (flag_quiet   <= 3) printf
#define logFprintf if  (flag_quiet   <= 4) printf
#define logHprintf if  (flag_quiet   <  3) printf 
#define logRprintf if  (flag_quiet   <  4) printf 
#define   dfprintf 
#define   xfprintf 
#define _DBG  printf( " DBG      : %s(%05d)\n", __func__, __LINE__ ); fflush(stdout)  
#define _FDBG printf( "FDBG      : %s(%05d)\n", __func__, __LINE__ ); fflush(stdout);  sleep( 1.5 )

/*
 * Footnotes
 * 1) -q, flag_quiet
 *        0 = normal, with lots of debug output
 *        1 =              , all debug printfs turned off
 *        2 = %I turned off, all normal event echo turned off
 *        3 = %W turned off, all normal header output turned off
 *        4 = %E turned off
 *        5 = %F turned off
 *        So q1printf are used to quiet down additional things other than header, event echo, and %I,W,E,F messages (if any)
 *           q2printf are used only for normal event echo printfs (0.000000000 594767  Q  WS 265392 + 3864 [fio])
 *           q3printf are used only for normal header event echo stuff, this includes any configuration settings
 *           q4printf <not defined, not used>
 *        Ideally when we're at -qq we should start using a %completed in terms of total bytes read from the file vs its fstat size.
 *        But then that is turned off if we are at -qqqqq (total quiet)
 *
 *        Note the 'q0printf' is a crutch.  Its used on printf() calls that should be somewhere in the d*printf() spectrum, but isn't
 *        so using a q0printf() is just a source code notification at this point that we should eventually decide what type of d*printf
 *        is appropriate.
 */

/* Special inProgress and inFlight printfs, normally off */
#define cnt_printf 
#define cnt_fprintf 

#ifdef DEBUG
#undef  dprintf
#undef  d1printf
#undef  d2printf
#define dprintf    printf
#define d1printf   if (flag_debug   >= 1) printf
#define d2printf   if (flag_debug   >= 2) printf
#endif

#define MAXBUF 256
#define MAXFILENAME 256
#define MAXPATHLEN  256

#define MAX_IO_SIZE      8192 		/* in sectors				       */
#define MAX_IO_SPLIT_SIZE 512		/* in sectors, the maximum split size expected */
#define MIN_IO_SPLIT_SIZE 128		/* in sectors, the minimum split size expected */

#define skip_whitespace(_arg ) strskip(_arg, " \t\n" )

unsigned char evtformat_io[256];	/* which event characters associated with main format type #1   */



/* IOTYP (RWBS) field:
 * 
 * from blkparse utility: 
 *     (note the action field is binary set in kernel and passed out, this is just parsing that data)
 *
 * static inline void fill_rwbs(char *rwbs, struct blk_io_trace *t)
 * {
 *         int f = t->action & BLK_TC_ACT(BLK_TC_FLUSH);    'F' 1st plus
 * 
 *         int d = t->action & BLK_TC_ACT(BLK_TC_DISCARD);  'D' or
 *         int w = t->action & BLK_TC_ACT(BLK_TC_WRITE);    'W' or
 *                 t->bytes != 0                            'R' or
 *                                                          'N' none of those for 2nd plus
 * 
 *         int u = t->action & BLK_TC_ACT(BLK_TC_FUA);      'F' 3rd plus   {yikes 'F' is positional, will always be right after D|W|R|N
 * 
 *         int a = t->action & BLK_TC_ACT(BLK_TC_AHEAD);    'A' 4th        {this io is or includes readahead, so only should be with 'R'}
 *         int s = t->action & BLK_TC_ACT(BLK_TC_SYNC);     'S' 5th        {typically direct io                                         }
 *         int m = t->action & BLK_TC_ACT(BLK_TC_META);     'M' 6th
 * 
 * 
 * Example #1:
 * 8,97  25       31     0.000244187 29074  A FWS 0 + 0 <- (253,2) 0
 * 8,96  25       32     0.000244444 29074  Q FWS [(null)]
 * 8,96  25       33     0.000247287 29074  G FWS [(null)]
 * 8,96  25       34     0.000247373 29074  P   N [(null)]
 * 8,96  25       35     0.000248195 29074  I FWS [(null)]
 * 8,96  25       36     0.000248314 29074  U   N [(null)] 1
 * :
 * 8,96  27        1     0.005730559     0  C  WS 0 [0]
 *
 * Example #2:
 * 8,96   2     1438   118.503083470  5483  I  WM 3672202488 + 32 [(null)]
 * 8,96   2     1439   118.503083709  5483  I  WM 3672202808 + 32 [(null)]
 * 8,96   2     1440   118.503083974  5483  I  WM 3672216408 + 32 [(null)]
 */

/*
 * *  Trace categories
 * *  
 * enum {
 * BLK_TC_READ     = 1 << 0,       /- reads -/
 * BLK_TC_WRITE    = 1 << 1,       /- writes -/
 * BLK_TC_FLUSH    = 1 << 2,       /- flush -/
 * BLK_TC_SYNC     = 1 << 3,       /- sync -/
 * BLK_TC_QUEUE    = 1 << 4,       /- queueing/merging -/
 * BLK_TC_REQUEUE  = 1 << 5,       /- requeueing -/
 * BLK_TC_ISSUE    = 1 << 6,       /- issue *-
 * BLK_TC_COMPLETE = 1 << 7,       /- completions -/
 * BLK_TC_FS       = 1 << 8,       /- fs requests -/
 * BLK_TC_PC       = 1 << 9,       /- pc requests                  -/
 * BLK_TC_NOTIFY   = 1 << 10,      /- special message              -/
 * BLK_TC_AHEAD    = 1 << 11,      /- readahead                    -/
 * BLK_TC_META     = 1 << 12,      /- metadata                     -/
 * BLK_TC_DISCARD  = 1 << 13,      /- discard requests             -/
 * BLK_TC_DRV_DATA = 1 << 14,      /- binary driver data           -/
 * BLK_TC_FUA      = 1 << 15,      /- fua requests                 -/
 *
 * BLK_TC_END      = 1 << 15,      /- we've run out of bits!       -/
 *                                                                                                                                           };
 */


/* there will be two accumulators: one for the current time sample, and a summary one for all time */
#define MAXCPUS 2048
typedef struct typ_accumulator
{
    double      boundary;		/* when to flush next *//* no init */

    long        cnt_queues;             /* # Q events         */
    long        cnt_sleeps;             /* # S events         */ 
    long        cnt_getreqs;            /* # G events         */
    long        cnt_inserts;		/* # I events         */
    long        cnt_dispatches;		/* # D events         */
    long        cnt_requeues;           /* # R events         */
    long        cnt_completes;          /* # C events         */
    long        cnt_bmerges;            /* # M events         */
    long        cnt_fmerges;            /* # F events         */
    long        cnt_messages;		/* # message events   */
    long        cnt_others;
    long	rqm_reads;		/* # read merges      */
    long	rqm_writes;		/* # write merges     */
    long	cnt_reads;		/* # reads  completed */
    long	cnt_writes;		/* # writes completed */
    long        cnt_discards;           /* # discards complete*/
    long        cnt_vmerges;
    long        cnt_vmerges_holes;
    long	blks_read;		/* # blocks read      */
    long	blks_written;		/* # blocks written   */
    long        blks_discarded;         /* # blocks discarded */
    long        seek;			/* total seek amount  */
    double      dt_idle;		/* total idle time between io requests C->A/Q */ /* and in_progress is 0 ? */
    double      avgqu_weighted;         /* area under io x dTime (/ busy time = avgqu-sz)			   */
    double      avgqu_lasttime;
    int         avgqu_max;		/* Max inProgress @weighted time	      */
    typ_actions dt_tot_read;
    typ_actions dt_max_read;		/* max   Q->I, Q->D, Q->C times (reads)       */ /* one io, the slowest    */
    typ_actions dt_min_read;		/* total Q->I, Q->D, Q->C times (reads)       */ /* one io, the quickest   */
    typ_actions dt_tot_writes;		/* total Q->I, Q->D, Q->C times (writes)      */
    typ_actions dt_max_writes;		/* total Q->I, Q->D, Q->C times (writes)      */
    typ_actions dt_min_writes;		/* total Q->I, Q->D, Q->C times (writes)      */
    typ_actions dt_tot_discards;	/* total Q->I, Q->D, Q->C times (discards)    */
    typ_actions dt_max_discards;	/* total Q->I, Q->D, Q->C times (discards)    */
    typ_actions dt_min_discards;	/* total Q->I, Q->D, Q->C times (discards)    */
    double      util;                   /* time any io was present on device          */
    double      avgqu_sz;		/* weighted average for avgqu_sz              */
    long	inflight;		/* inflight count (Q or A w/o C )             */ /* Essentially number of events on list at the moment */ /* no init */

    long	cnt_requeues_reads;	/* 'R'equeue events on Reads		      */
    long        cnt_requeues_writes;	/* 'R'equeue events on Writes		      */
    long        cnt_requeues_discards;  /* 'R'equeue events on Barriers               */
    long        cnt_sleep_reads;        /* 'S'leep events on Reads                    */
    long        cnt_sleep_writes;       /* 'S'leep events on Writes                   */
    long        cnt_sleep_discards;     /* 'S'leep events on Barriers                 */
    long        cnt_barrier_writes;     /* 'W' 0:0 io				      */
    long        cnt_barrier_reads;      /* 'R' 0:0 io -- should be none.              */ /* ...but just in case	    */
    long        cnt_barrier_discards;   /* 'D' 0:0 io -- should be none.              */ /* ...but just in case	    */

    int         cnt_requeues_samples;	/* number of 1s samples with any requeues     */
    int         cnt_sleeps_samples;     /* number of 1s samples with any sleeps       */
    int         cnt_discard_samples;    /* number of 1s samples with any barriers     */

    int         cpu_bgn[MAXCPUS];	/* number of io started on a cpu N	      */
    int         cpu_end[MAXCPUS];	/* number of io finished on  cpu N	      */
    int         cpu_crx[MAXCPUS];	/* number of io started on one cpu/end onother*//* really need to look at numa cpu map as cpu 0,1 maybe "same numa" */
} typ_accumulator;

typ_accumulator samp;					/* current 1 second sample		*/
typ_accumulator summ;					/* whole file summary			*/
   
int        free_count       = 0;
int        staged_on_list   = 0;
int        mainio_on_list   = 0; 
int        postio_on_list   = 0;
int        deadio_on_list   = 0;
#define    BADEVT __LINE__, "parsing of the event failed or detected an issue such that we cannot use"
typ_io    *staged_list      = (typ_io    *)NULL;
typ_io    *mainio_list      = (typ_io    *)NULL;
typ_io    *postio_list      = (typ_io    *)NULL;
typ_io    *postio_last      = (typ_io    *)NULL;
typ_io    *deadio_list      = (typ_io    *)NULL;	/* used to collect lv Q/X/X/X/C deadwood */
typ_io    *free_list        = (typ_io    *)NULL;
typ_io    *curr_mainio      = (typ_io    *)NULL;	/* singular item, last mainio referenced */
typ_event *cxrr_event       = (typ_event *)NULL;	/* singular item		         */
typ_event this_event;
typ_event temp_event;
typ_io    this_io;
typ_io    temp_io;
#define   STAGED_QUEUE 1
#define   MAINIO_QUEUE 2
#define   POSTIO_QUEUE 3
#define   FREEME_QUEUE 4

typedef struct typ_eventdata
{
        long    count;     /* A/Q -> S -> G -> I -> D -> {R -> I -> D}... -> C */
        double  Q2I;       /*   |------------> |                               */
        double  Q2D;       /*   |-----------------> |                          */
        double  D2D;       /*                       |-------------> |          */ /* non-zero only if requeues present */
        double  D2C;       /*                                       |------> C */ /* D2D enabled for output, otherwise what gets charged the D2D time? */
        double  Q2C;       /*   |------------------------------------------> C */ /* iostat's await time               */
} typ_eventdata;

typ_eventdata eventdata[6];
#define EVENTDATA_SUBPAGE ((1*8)-1)
#define EVENTDATA_SMALL   ((4*8)-1)
#define EVENTDATA_MEDIUM  ((9*8)-1)
#define EVENTDATA_LARGE   ((33*8)-1)
#define EVENTDATA_JUMBO   ((129*8)-1)
#define EVENTDATA_XTRA    (EVENTDATA_JUMBO+1)

char eventdata_desc[6][64] =
{ {"Subpage (    <   1 4k page )" },
  {"Small   (  1 -   3 4k pages)" },
  {"Medium  (  4 -   8 4k pages)" },
  {"Large   (  9 -  32 4k pages)" },
  {"Jumbo   ( 33 - 128 4k pages)" },
  {"Xtra    (    > 128 4k pages)" } };


/* ----------------------------------------------------------------------------- */
/* ---BGN:HOTSPOT Defines------------------------------------------------------- */
/* ----------------------------------------------------------------------------- */

/*
 * There are 'MAX_SEGMENT_ENTRIES' at the top level, these are preallocated pointers in the header
 * that are null, but when allocated point to a 2nd level structure of 'MAX_SEGMENT_ENTRIES'.
 * And these pointers, when allocated, point to a disk "stripe" -- a range of LBA addresses.
 * The range of LBA within each "stripe" is 'MIN_STRIPE_SIZE' in KB * conf_disk_stripe_multiplier
 * (both of which are 128, so each "stripe" is 16MB (32768 sectors) -- which really is kind of on
 * the small side). So max allowed sector, by default, is 2^15 x 2^12 x 2^12 or 2^39 or 2^9 (512) GB.
 */
#define DBG_HOTSPOTS               0		/* If '1', then add addition debug tracking data info in structures           */
#ifdef  DEBUG
#undef  DBG_HOTSPOTS
#define DBG_HOTSPOTS               1
#endif
#define MAX_SEGMENT_ENTRIES 4096
#define MAX_BUCKET_ALLOC    0x1FFFFF            /*  2M buckets allowed to be alloc'd in map, this corresponds to 256G of disk */
#define MAX_BUCKET_INDEX    0xFFFFFF            /* 16M buckets allowed to be represented (4096*4096)                          */

#define MAX_STRIPE_MULT        0x10000 		/* Need to allow a really big multiplier for those really big filsystem groups */
#define MIN_STRIPE_SIZE            128
/* the lowest reasonable value for the following is 128k                 */
/* but given a lot of io is that size lets use a multiple of that, say   */
/* 128*128k... so if there is locality of reference we'll see upwards of */
/* 128 io in a "stripe".. should we go higher?                           */

/* ------------------------------------------------------------------------------------ */
/* --- CONFIG AND FLAGS---------------------------------------------------------------- */
/* ------------------------------------------------------------------------------------ */
 int conf_disk_count_threshold       = 1;		/* only print out bucket with this or high number of io       */ /* individual disks */
 int conf_disk_group_count_threshold = 1;		/* only print out bucket with this or high number of io       */ /* "grouped" disks  */ /* aka a multipath pseudo device */
long conf_disk_stripe_multiplier     = 128*8;         	/* in io count if 256k per io is present (512 sectors per io) */
 int conf_include_d2d                = 0;		/* when set, include any D2D time as separate column in ouput */
 int conf_noreset_on_requeue         = 0;		/* see -R, moves D2D time from Q2D (default) to D2C time      */ /* turned off is include_d2d set */
long conf_alignquanta                = 8;	        /* 4k sector alignment check, if enabled */
 int conf_orphan_check               = 0;		/* check for potential orphans every once in awhile @insert   */
 int conf_overlap_detect             = 0;		/* check for overlapping/conflicting io @insert into active   */
 int conf_allow_duplicate_completes  = 1;               /* if duplicate completion events for request detected        */ /* 1=allow with warning, 0=disallow, fatal             */
long disk_stripe_size_in_kb          = MIN_STRIPE_SIZE; /* default minimum w/mult=1, in KiB                           */ /* calc'd @init() x conf_disk_stripe_multiplier        */
long  max_disk_sector;					/* max sector number heat map can track ; calculated @init()  */

int  conf_orphan_event_policy        = 1;		/* 0 = stop if we detect an "orphan" event beyond top of file */
						        /* 1 = continue, assume all program logic is correct and did  */
						        /*     not miss anything and this is just a long delayed event*/
							/*     **log event** into outf                                */
							/* 2 = same as 1 except does not log the event in outf        */
int  conf_ghost_policy               = 1;		/* 0 = don't allow, will _exit(1)			      *//* debug  */ /* Note1 */
							/* 1 = default: allow creation if ghost_create() called       *//* default*/
int  conf_merged_event_debug         = 0;		/* 0 = default: don't output individual events after merged   *//* debug: requires -DDEBUG compile time option		*/
							/* 1 =          output list of events "absorbed" into this io */
int  conf_exceptions_inhibit	     = 0;		/* 0 = default; output "exception" events into *.exceptions   */
							/* 1 =          inhibit output of such events                 */
int  conf_barrier_match_policy       = 0;		/* 0 = default; if best_match_special1() cannot find a match  *//* exit with fatal internal logic fault			*/
							/* 1 =          return null as best match                     *//* least distasteful of choices if want to continue     */
							/* 2 =          return 'io' as best match                     *//* this can have unintended consequences!               */
							/*0-2= best to worse choices, but non-zero permits continuing */
int  conf_x360_completions           = 2;               /*     turn off any A,D,C matching warnings after this # io   */
int  conf_x360_policy                = 1;		/* 0 = default; expect Q events in all cases                  */
	                                                /* 1 =          allow A,{I},D,C sequence w/warnings           */
							/* 2 =          allow A,D,C sequence w/o warnings             *//* set this if you know its x306 blktrace               */
							/* 3 =          **expect** A,D,C sequences, no warnings       *//* complain in this case if you do hit a 'Q' event!     */
int  conf_base_seconds               = 0;		/* Time base offset in seconds, to be added to queue time     *//* In SEC output only					*/
int  conf_default_xsplit_size        = 1024;
int  conf_no_annotation              = 0;		/* 0 = annotated file written				      */
							/* 1 = annotated file off				      */

                                                        /* if any of the following are set to non-zero, then program will exit upon detection of the fault                     */
							/* unless CTL_FAULT_IGNORE is specified within the specific spot that the fault occurs.                                */
#ifndef DEBUG
int conf_terminate_onfault_notarget  = 0;		/* discard due to no typ_io match found for event	      */ /* default: ignore[2]				       */
int conf_terminate_onfault_nofeature = 0;		/* discard due to no feature support for this event	      */ /* default: ignore[3]                                 */
int conf_terminate_onfault_discard   = 0;		/* discard due to some other reason other than above two      */ /* default: ignore[4]                                 */
int conf_terminate_onfault_dataproc  = 0;		/* fault   due to data processing deadend w/o target match    */ /* default: force [5]                                 */
int conf_terminate_onfault_progproc  = 0;		/* fault   due to "something" in program not making sense     */ /* default: force [6]                                 */
#else 
int conf_terminate_onfault_notarget  = 1;		/* discard due to no typ_io match found for event	      */ /* default: force exit[7]                             */
int conf_terminate_onfault_nofeature = 1;		/* discard due to no feature support for this event	      */ /* default: force exit                                */
int conf_terminate_onfault_discard   = 1;		/* discard due to some other reason other than above two      */ /* default: force exit                                */
int conf_terminate_onfault_dataproc  = 1;		/* fault   due to data processing deadend w/o target match    */ /* default: force exit                                */
int conf_terminate_onfault_progproc  = 1;		/* fault   due to "something" in program not making sense     */ /* default: force exit                                */
#endif

int flag_debug   = 0;
int flag_verbose = 0;
int flag_quiet   = 0;           /* quiet logfile output, allow: 0= all, 1=background off, %Info+ 2=%Warn+ 3=%Error+, 4=%Fatal (critical) only */
int flag_alignchk= 0;
int flag_tracing = 0;
int flag_function= 0;
int flag_check_inprogress = 0;  /* run debug/validation routine to check mainio_list vs inprogress counter */
int flag_negrequeue=0;          /* Don't change 1st 'D'ispatch time, count requeue time against storage */
int flag_processbad=0;          /* if set, continue to process file even though we're not finding any 'C'ompletion events       */
int flag_showconfig=1;          /* if set, output config setup/details at end of parse_args()                                   */
int flag_xsplits   =0;		/* 0 = best guess, 1=4.18'isms in kernels up to 4.1(?), 2=isms in 4.18++ kernels and later      */
int flag_remap_bug =1;		/* 0 = default   , 1=disable minor device matching for remap targets                            */
int flag_shortform =0;		/* 0 = default   , 1=drop seek, description, and later columns					*/
int flag_unplugs   =0;		/* 0 = default   , 1=disable %I P/U/UT messages as they can be noisy                            */
int flag_estimates =0;          /* 0 = default   , 1=show estimates of events/time then exit.					*/
int flag_discards  =0;		/* 0 = default   , 1=disable discard events for everything except D and C (temp:workaround)     */

int conf_xsplits   =0;		/* set method in use, either explicitly or implicitly						*/
#   define CFG_XSPLITS_BESTGUESS 0  /* code show try doing the right thing, until a min of MIN_XSPLITS_MATCHES happen           */
#   define CFG_XSPLITS_MISSING   1  /* code should assume 4.18'ism with missing I,D,C et.al. events for splits                  *//* was prior 4.18'ism default   */
#   define CFG_XSPLITS_PRESENT   2  /* code should assume 4.18'ism doesn't exist for X splits and all expected events present   *//* true of 4.18++ and later kernels */
#   define MIN_XSPLITS_MATCHES  20



int chk_use_include_d2d=0;

/* ------------------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------------------ */


/**
 *
 * NOTES: fault behavior
 *
 * [1] 
 * When a fault is detected, whether the program treats this as an error (continue after) or fatal (exit program) depends on two factors.
 * The general logic is designed to flag as error, if at all possible, and continue processing when -DDEBUG is not present.  With -DDEBUG
 * flag present at compile time then the default behaviors are all force on exit *unless* overridden by the specific instance of the fault
 * macro at the point of failure.  There are some faults that just should not be continued from, like internal data structures or queue
 * inconsistencies that really shouldn't happen.  Prior to adding this fault logic to control whether to exit or not, any fault would always
 * force exit.  This mechanism is specifically design to address things like best_match() failing, or things like bounce_event() not being
 * implemented yet.  
 *    First : the ctl flag passed in at the fault point within the program, this flag is always evaluated first and can be:
 *              0: default, defer to second factor below
 *              1: ignore the fault (error) and continue
 *             -1: force an exit in all cases
 *    Second: if the ctl flag is 0, then the second conf_terminate_onfault_* applies.  If the corresponding config is 
 *              0: ignore fault, treat as error and try to continue processing
 *              1: force exit on fault.
 *
 * [2]  ignore ontarget faults, this means if the code could not find a typ_io target match for the current event, discard it and try and
 *      continue;
 * [3]  similar to [2] but this is a nofeature fault, link bounce_event() which has no code to support it or some obscure branches in the code
 *      that should create a ghost but currently doesn't have code to do so.
 * [4]  similar to [2] but this is a plain discard for some other reason other that 2 or 3.
 * [5]  a data processing error, by default, should exit. But in this case the specific fault location and details may wish to override that 
 *      with an ignore.  An overridden by ignore ctl setting means it will also be ignored in -DDEBUG version.  We should be careful setting 
 *      such ignores unless we fully understand the likely consequences.  One such path is trying to do a best match.  There continue to be 
 *      data sets that end up without a best match.  We really want to continue from those.  So if we set the conf_terminate_onfault to exit,
 *      we only can undo that with a ctl of ingore.  Which then is ignored in -DDEBUG version.  But if we set it to default of ignore, then
 *      specific instances (most?) can override and set forced exit at the point those occur.  This allows things like best_match() when it
 *      fails not to stop processing except in the -DDEBUG version -or- in specific identified instances where we have made an explicit 
 *      decision that the program cannot continue and must exit on fault.
 * [6]  ditto [5] except for program processing faults.  Here we expect a clear majority to always force exit via ctl.A
 *
 * [7]  if -DDEBUG specified then the exit on fault logic should revert to the prior behavior of always faulting out except in those cases
 *      that explicity set IGNORE.
 *
**/

/* Note1: ghosts, see ghost_create(), but a ghost is when the program reads in a post A|Q event and there is no prior
 *        event found as target to absorb this event. So we create a "ghost" io.  Ghost io are simply an io target 
 *        created so we don't discard this or later related events.  Ghost io are not output and do not affect statistics.
 */

/*
 * A sector is bin'd into a 'bucket', there are 4096 buckets per segment, and 4096 segments.  So once you have 
 * an absolute bucket number, its determined which segment that bucket belongs in and a relative 0..4096 bucket
 * number within that segment is created.  
 *
 * So sector / "disk stripe" quanta = absolute bucket number, then
 *           absolute bucket number = segment:relative_bucket number.
 *
 * disk segment[4096] -> disk segment[4096] -> disk stripe [portion of disk] into which io stats are accumulated 
 *
 * disk_segment[   0] -> disk_segment[   0] -> LBA range 0...n stats
 *                       disk_segment[   1] -> LBA range n+1...x status
 *                       :
 *                       disk_segment[4095] -> LBA range...
 * :
 * :
 * disk_segment[4095] -> disk_segment[   0] -> LBA range...
 *                       :
 *                       disk_segment[4095] -> LBA range (max disk size supported)
 */

/* --- Struct:                 --------------------------------------------------- */


/* --- Struct: typ_disk_stripe --------------------------------------------------- */
typedef struct typ_disk_stripe
{
    int    seeks_in;
    int    seeks_out;

    int   read_cnt;
    int   read_req;		/* requeues */
    long  read_sec;
    float read_q2c;
    float read_d2c;

    int   write_cnt;
    int   write_req;		/* requeues */
    long  write_sec;
    float write_q2c;
    float write_d2c;

#ifdef DBG_HOTSPOTS
    long bgn_sector;
    long end_sector;
#endif
} typ_disk_stripe;

/* --- Struct: typ_disk_segment --------------------------------------------------- */
typedef struct typ_disk_segment
{
    void *ptr[MAX_SEGMENT_ENTRIES];
} typ_disk_segment;

typedef struct typ_disk_hotspots
{
    int last_segment;
    int last_bucket;
    typ_disk_stripe  *last;

    typ_disk_segment  segments;		/* MAX_SEGMENT_ENTRIES points                                */

    int segment_cnt;			/* number of ptr's in above segments that point to something */
    int bucket_cnt;			/* number of buckets allocated across all segments	     */
    int min_bucket;			/* first bucket number = smallest LBA on  disk accessed      */
    int max_bucket;			/* last  bucket number = largest  LBA on  disk accessed      */

    int flags;
#   define DISK_SIZE_EXCEEDED         0x0001
#   define DISK_BUCKET_ALLOC_EXCEEDED 0x0002

    /* Always include these in the disk hotspots main */
    /* struct -- but they will only have data if the  */
    /* DBG_HOTSPOTS is defined at compile time        */
    /* By including always, we make it easer to deal  */
    /* with the binary output file @read time.        */
    /* Will never have two sizes of structure         */
    long min_sector;
    long max_sector;

} typ_disk_hotspots;

/* --- GLOBALS ----------------------------------------------------------------- */
typ_disk_hotspots    diskHotSpots;


/* Pre-configured signatures							 */
typ_event_sigconf    config_signatures[32] =  
{
{ (void *)-1L, 0, STATEMCH_CFG_IMB1,    1, "i;A/FWFS,S0;Q/FWFS,--;G/FWFS,--;D/FN,--;C/FN,0-;C/WFS,S-" 		},

{ (void *)0L, -1, -1,-1,"" }
};

/* Look-aside cache for active implicit io barrier io contexts 			 */
#define MAXARRAY_IMB_ACTIVE_CACHE 31
typ_io *imb_active_cache[MAXARRAY_IMB_ACTIVE_CACHE+1];
int     imb_active_inuse    = 0;
int     imb_active_freed    = 0;
int     imb_active_maxdepth = 0;
int     imb_active_adds     = 0;


/* ----------------------------------------------------------------------------- */
/* ---END:HOTSPOT Defines------------------------------------------------------- */
/* ----------------------------------------------------------------------------- */

#define MAX_ARRAY_REMAPS 256 
typ_remaps remaps[MAX_ARRAY_REMAPS];
int        remaps_used = 0;


/* This is for "bin'ing" information like io size, q2c, ...         */
/* There are typically only 16 "bins" to sort the io into           */
/* output of same results in a high level view of the io profile    */
int   bin_total_samples;
int   bin_total_readreq;
int   bin_total_writreq;
float bin_total_data[4];
#     define XFER_TOTAL    0            /* Total data transferred */
#     define XFER_READS    1            /* Total data read        */
#     define XFER_WRITES   2            /* Total data written     */
/* --- Struct: typ_bucket ----------------------------------------- */
typedef struct typ_bucket
{
        int   sample_count;		/* number of samples in this bucket             */
        float data[4];			/* up to 4 accumulators, depends on bucket type */
} typ_bucket;
/* --- Three bins/bucket lists, await, kbs, q2c ------------------- */
#define MAXBUCKET 16
typ_bucket await_bucket[MAXBUCKET+1];
#    define AWAIT_TOTAL  0
#    define AWAIT_TIME   1

typ_bucket kbs_bucket[MAXBUCKET+1];
#    define KBS_TOTAL    0
#    define KBS_TIME     1

typ_bucket rrq_bucket[MAXBUCKET+1];
#    define REQ_TOTAL    0              /* total/sum of all io request sizes */
#    define REQ_AWAIT    1              /* total/sum of all q2c times        */
                                        /* should extend this to track D2C   */

typ_bucket wrq_bucket[MAXBUCKET+1];
#    define REQ_TOTAL    0              /* total/sum of all io request sizes */
#    define REQ_AWAIT    1              /* total/sum of all q2c times        */
                                        /* should extend this to track D2C   */


/* 
 * 'Events'
 * 'Event' data is each main event as output to the parse file.
 */
/*
 * 'Bins' or 'Buckets'
 * 'Buckets' are a limited set of bin'd parts, typically 16 bins into which io
 * samples are sorted.  For example, all io < 1k might go in bin[0] of the bucket
 * etc. There are flexible headers defined for each bucket that defined what goes
 * into the a specific bin[n].  At the end of sucking in all the events, we output
 * all the 'Bucket' contents which provides an io profile of all the captured data.
 * The number of buckets if fixed by version (which hasn't changed in awhile), so
 * in reading in the header for this file we know how many buckets follow.
 */
/* 
 * 'HotSpot' or What IO hits within which on-disk LBA ranges ("stripes")
 * 'Hotspot' data is a series of disk stripes defined across a disk.  The hotspot
 * code tracks the number, size, time taken for io that is from that stripe on disk.
 * The code also tracks io that seeks into the stripe and seeks out of the stripe as
 * based upon previous io completing.  The data is filled over time as data is read
 * in.  When we're rady to output the data we have all the buckets and know how many
 * etc.  Which is not true of individual io events.  So we include the size/number 
 * in the header.
 */

/* === Binary: Events      ====================================================================== */
typedef struct typ_evtbinary_header
{
    int         rectyp;
    int         version;

    float	temp;
} typ_evtbinary_header;

/* --- Struct: typ_evtbinary record ------------------------------- */
typedef struct typ_evtbinary_record
{
    float	temp;
} typ_evtbinary_data;

typ_evtbinary_header evt_header;
typ_evtbinary_data   evt_entry;

/* === Binary: Bucket/Bins ====================================================================== */
typedef struct typ_binbinary_header
{
    unsigned int rectyp;
#   define       RECTYP_BIN_HEADER 0xDCB3021
    int          version;
#   define       RECVER_BIN_HEADER 0x0100

    int   bin_total_samples;		/* Total samples read       */ /* samples in buckets      */
    int   bin_total_readreq;		/* Total samples = read  io */ /* subset of total samples */
    int   bin_total_writreq;		/* Total samples = write io */ /* subset of total samples */
    float bin_total_data[4];
#     define XFER_TOTAL    0            /* Total data transferred   */ /* sectors total           */
#     define XFER_READS    1            /* Total data read          */ 
#     define XFER_WRITES   2            /* Total data written       */

    int   maxbucket;			/* MAXBUCKET                */
} typ_binbinary_header;

/* --- Struct: typ_binbinary record ------------------------------- */
typedef struct typ_binbinary_data
{
    unsigned int rectyp;
#   define       RECTYP_BIN_DATA 0xDCB3022
    int		 numb_bins;

    int         bucket_type;
#   define      BIN_LIMITS  1		/* float kbs_bins[MAXBUCKET], for example */
#   define      BIN_AWAIT   2
#   define      BIN_KBS     3
#   define      BIN_Q2C     4

    typ_bucket  bins[1];
} typ_binbinary_data;

typ_binbinary_header  bin_header;
typ_binbinary_data    bin_entry;



/* === Binary: LBA HotSpots ===================================================================== */
typedef struct typ_hotbinary_header
{
    unsigned int rectyp;
#   define       RECTYP_HOT_HEADER 0xDCB3031
    int          version;
#   define       RECVER_HOT_HEADER 0x0100

    int          dbg_hotspots;

     int conf_disk_count_threshold;
     int conf_disk_group_count_threshold;
    long conf_disk_stripe_multiplier;
    long disk_stripe_size_in_kb;
    long  max_disk_sector;

    typ_disk_hotspots diskHotSpots;
} typ_hotbinary_header;

/* --- Struct: typ_hotbinary record ------------------------------- */
typedef struct typ_hotbinary_data
{
    unsigned int rectyp;
#   define       RECTYP_HOT_DATA 0xDCB3032

    int             bucket_number;		/* so we know where to allocate/place this data */
    typ_disk_stripe bucket;
} typ_hotbinary_data;

typ_hotbinary_header hot_header;
typ_hotbinary_data   hot_entry;

/*
 * STATE (general) information
 * includes:
 * 	"deli counter" tickets for Q, D, and C events - monotonically increasing ticket number as each event is encountered
 * 	    - difference in ticket Q->D is io scheduling reorder amount 
 * 	    - difference in ticket D->Q is io device     reorder amount (controller/disk reordered)
 * 	    - the differences must be relative rather than absolute as previous Q->D reordering then can affect D->C math,
 * 	      so we grab the absolute Q ticket number at D time, and absolute Q number at C time, etc.  Always back looking.
 * 	plug state
 * 	    - the io drain to the device from the scheduler is plugged to prevent io from leaving the scheduler "too soon"
 * 	      where "too soon" is a relative amount of time but without plugging the drain back-to-back IO that could be
 * 	      merged into a larger more efficient io wouldn't be if the underlying lun queue had space, that is:
 * 	         .            sched                device
 * 	         . not this 1 4k             
 * 	         .          2            ->        4k
 * 	         .          3 4k
 * 	         .          4            ->        4k
 * 	         . but this 1 4k (plug)
 *               .          2 4k (merge)
 *               .          3    (unplug) some dTime later
 *               .          4            ->        8k
 */
typedef struct typ_state
{
    long	  totl_filebytes;
    long          read_filebytes;
    long          next_filebytes;
    long          diff_filebytes;
#   define        NEXT_BYTES_QUANTA  100000000
    long          next_line;
#   define        NEXT_LINES_QUANTA    4100000
    long          est_lines;
#   define        EST_LINE_AVGSIZE   65.066009295
    long          est_seconds;
#   define        EST_TIME_PERQUANTA 41000.0		/* lines per time quanta			*/
#   define        EST_LINE_AVGTIME   1.0		/* seconds per line quanta			*/
    unsigned long bgn_seconds;
    unsigned long cur_seconds;

    int           total_io;		/* total io completed						*/
    int           total_aligned;	/* total io aligned (diff from above = unaligned io)		*/

    unsigned long serialnumb;           /* serial number used by program, unique for each event created */

    unsigned long line;		        /* current line number of input file being parsed		*/
    double        time;		        /* current event time, last event time pulled from event stream */
    
    char inpline[MAXBUF];		/* current raw event line input					*/
    char lstline[MAXBUF];		/* previous raw event line input				*/

    int  device_nvme;                   /* nvme device detected within file 				*/

    unsigned long xSeqNo;		/* ticket number for '*' events (all/any events)		*/ 

    unsigned long ASeqNo;		/* ticket number for 'A' events					*/
    unsigned long QSeqNo;		/* ticket number for 'Q' events					*/
    unsigned long XSeqNo;		/* ticket number for 'X' events					*/
    unsigned long SSeqNo;               /* ticket number for 'S' events                                 */
    unsigned long GSeqNo;               /* ticket number for 'G' events                                 */
    unsigned long ISeqNo;		/* ticket number for 'I' events					*/
    unsigned long DSeqNo; 		/* ticket number for 'D' events					*/
    unsigned long RSeqNo;               /* ticket number for 'R' events                                 */
    unsigned long CSeqNo;		/* ticket number for 'C' events					*/

    unsigned long   PlugCount;		/* 'P' event count, number of total 'P' events encountered	*/
    unsigned long UnplugCount;		/* 'U' event count						*//* or 'UT' or 'T' */
    int           isPlugged;		/* -1 = unknown (@start), 0=unplugged, 1=plugged		*/
#   define PLUGSTATE_UNKNOWN  -1	/* at start/init, state set to -1				*//* treat as unplugged */
#   define PLUGSTATE_UNPLUGGED 0	/* unplug events have wound nested plugs back to zero           */

    int  	   kwiobarrier;		/* Number of Kernel implicit write io barriers open/active      */ /* Not 'B'arrier io type, but write/sync of length=0 */

    /* Tracked/raw event counts within input file 							*/
    unsigned long event_count_remap;    /* 'A'							        */
    unsigned long event_count_queue;    /* 'Q'								*/
    unsigned long event_count_sleep;    /* 'S'								*/
    unsigned long event_count_getrq;    /* 'G'								*/
    unsigned long event_count_xsplit;   /* 'X'								*/
    unsigned long event_count_merge;	/* 'M' 								*/
    unsigned long event_count_front;	/* 'F'								*/
    unsigned long event_count_insert;   /* 'I'								*/
    unsigned long event_count_dispatch; /* 'D'								*/
    unsigned long event_count_requeue;  /* 'R'								*/
    unsigned long event_count_complete; /* 'C'								*/
    unsigned long event_count_plug;     /* 'P'							        */ /* this is just raw event count, *PlugCount above are stateful  */
    unsigned long event_count_unplug;   /* 'U', 'UT', 'T'				                */ /* this is just raw event count, *PlugCount above are stateful  */
    unsigned long event_count_timer;    /* 'T'                                                          */
    unsigned long event_count_message;  /* 'm'								*/
    unsigned long event_count_other;    /* 'x'								*/ /* unrecognized event types? */
    unsigned long allocated_memory_total;
    unsigned long allocated_memory_events;
    unsigned long allocated_memory_io;	/* this counts all typ_io and all data structures off of same	*/
    int           allocated_events;
    int           allocated_io;		/* this counts all typ_io structs only: mainio and subio	*/

    unsigned long ghosts_created;
    unsigned long ghosts_completed;
    unsigned long ghosts_2nd_hand_m_created;	/* The reason for separate M|F counters is that if F    */
    unsigned long ghosts_2nd_hand_f_created;    /* then more likely a chance to have fractured requests */
    unsigned long ghosts_2nd_hand_m_completed;  /* which result in multiple mainio requests created as  */
    unsigned long ghosts_2nd_hand_f_completed;  /* ghosts vs just one single request.                   */ /* see notes at end on GHOST requests discussion 		*/


    /* Track event numbers and times within context of stream.						*/
    /* For example, if a bunch of back to back to back 'C' events are happening, then the 'First' C     */
    /* event is captured in 'First' and 'Last' when QEventCnt=0.  Subsequent C events only change the   */
    /* 'Last' timestamp while bumping CEventCnt for each time.  When the event types change within the  */
    /* stream of events, then all counts are reset as well as 'First' times -- then the new event type  */
    /* is captured.  The original/main purpose of tracking this type of meta event state within the     */
    /* stream of events is to detect the delay between a 'C' and 'D' event when device/lun queue was    */
    /* full and io was queued/waiting within the scheduler queue.  The expectation is the driver will   */
    /* do a callback quickly to pull down the next available queued io from scheduler after performing  */
    /* a C event callback.  But there are nuances to that logic and difference in driver processing     */
    /* that can result in a stream of C events over a non-trivial N ms period before the driver turns   */
    /* around to suck down the next batch of available io from the scheduler.                           */
    double        QFirstTime;		/* the timestamp of the 1st Q event in seq of Q events          */
    double        QLastTime;		/* the timestamp of the nth Q event, cnt=1 these are the same   */
    double        DFirstTime;		/* the timestamp of the 1st Q event in seq of Q events          */
    double        DLastTime;		/* the timestamp of the nth Q event, cnt=1 these are the same   */
    double        CFirstTime;		/* the timestamp of the 1st Q event in seq of Q events          */
    double        CLastTime;		/* the timestamp of the nth Q event, cnt=1 these are the same   */

    double        IEvtTime;		/* the timestamp at last event completion at which point Q=empty*/
    int           idle_state;		/* whether above is valid or left over from last idle time      */
#   define        Q_IS_IDLE 0
#   define        Q_IS_BUSY 1

    int QEventCnt;			/* number of Q events between 1st and nth, inclusive 		*/
    int DEventCnt;			/* number of Q events between 1st and nth, inclusive 		*/
    int CEventCnt;			/* number of Q events between 1st and nth, inclusive 		*/

    int inProgress;			/* for now, Q w/o C events					*//* for io w/o merging		*/
    int inProgress_Read;
    int inProgress_Write;
    int inFlight;			/* for now, D w/o C events					*//* for io w/o merging		*/
    int inFlight_Read;
    int inFlight_Write;
    double avgqu_lasttime;		/* last time avg queue depth accumulation performed		*/
    double avgqu_weighted;		/*           avg queue depth weighted value 			*/

    int   in_progress;		        /* Number of requests submitted (gendisk.inflight, field #9 in /proc/diskstats)*/ /* Number of 'D' w/o 'C' */ /* **duplicate?** @@@TBD */

    int started_reads;
    int started_writes;
    int completed_reads;
    int completed_writes;
    double total_read_time;
    double total_write_time;
    double max_await_read;
    double max_await_write;
    double max_await;
    double avg_await_read;	
    double avg_await_write;
    double avg_await;

    int flag_annotated;			/* reset for each new read in event, and set in annotate() 	*//* if next event not set, force annotation */
    int events_total;			/* total events thru parse_event()				*/ /* parse_event()			     */
    int events_exceptions;		/* number of events marked as exception				*/ /* exceptionevent()			     */
    int events_exceptplugs;		/* number of events marked as excpetion & are plug flow issue   */
    int events_exceptbadfmt;		/* number of events marked as exception & non-standard format   */ /* missing sector and/or length	     */
    int events_discarded;		/* number of events unmatched/discarded				*/ /* annotate_event()			     */
    int events_discarded_nonC;		/* number of events unmatched/discarded that are not C events   */ /* annotate_event()			     */
    int events_nofeature;		/* missing feature needed to properly process this event        */ /* annotate_event()			     */
    int events_notarget;		/* failed to match to existing typ_io target as needed          */ /* annotate_event()			     */


    int conflicted_io;			/* count of the number of conflicted io detected		*//* overlapping io of diff typ */
    int overlapped_io;		        /* count of the number of overlapped io detected, total         */
    int overlapping_io;			/* count of the number of overlapped io present in active list  *//* [1]			*/

    int    orphan_check;		/* number of io to complete before next check is run		*/
    int    orphan_io;			/* current count of any suspected orphan io on active list      */
    double orphan_time;			/* any active io before this time are flagged as orphans        *//* [2]			*/

    /* list management "helpers"    									*/
    int        num_exceptions;
    typ_event *exceptions;
    typ_event *last_exception;
    typ_io    *last_staged_io;
 
    int    a_then_q;			/* 1 = confirmed A->Q						*/   
    
    long   last_completed_sector;
    long   last_completed_length;
    double last_queue_t;

    int    reported_duplicate_completions;
#   define MAX_REPORTED_DUPLICATE_COMPLETIONS 10

    /* Statistics for best_match() type calls								*/
    int best_match_contexts;		/* number of io context needing best_match() use		*/
    int best_match_checks;		/* total number of best_match() calls				*/
    int best_match_high;		/* total number of best_match() calls with high confidence      *//* only 1 of the two passed in io qualified for use */
    int best_match_good;                /* total number of best_match() calls with good confidence      *//* both context qualified, had to use time to choose*/
    int best_match_special1_contexts;   /* number of io context needing best_match_special1() use       *//* Special case.1: "barrier" type events detected   */
    int best_match_special1_checks;	/* total number of best_match() calls				*/
    int best_match_special1_high;	/* total number of best_match() calls with high confidence      *//* only 1 of the two passed in io qualified for use */
    int best_match_special1_good;       /* total number of best_match() calls with good confidence      *//* both context qualified, had to use time to choose*/
    int best_match_special1_weak;       /* total number of best_match() calls with weak confidence      *//* one or both only directly matched rules1,3 not 2 */
    int best_match_special1_ties;       /* total number of best_match() calls with qualification ties   */

    unsigned long alerts;
#   define ALERTFLG_UNMATCHED_UNPLUG 0x0001
#   define ALERTFLG_NEG_U	     0x0010
#   define ALERTFLG_NEG1_U           0x0020 
#   define ALERTFLG_ZERO_U           0x0040
#   define ALERTFLG_ZERO_UT          0x0080
#   define ALERTFLG_X360_FORCED      0x0100
#   define MAX_ALLOWED_UNPLUG_MSG    10	     /* allow output of 1st 10 warnings concerning plug/unplug  *//* output affects stdout output, still logged in annotation */
    long alert_cnt_unmatched_u;		/* unplug, but plug count < unplug count                        */
    long alert_cnt_neg_u;		/* Unplugged - Plugged is negative & Plug events present        */
    long alert_cnt_neg1_u;		/* Unplugged - Plugged is negative & Plug events present        *//* and right after UT event  */
    long alert_cnt_zero_u;		/* Unplugged events but no Plug Events present                  */
    long alert_cnt_zero_ut;		/* UT events        but no Plug Events present                  */

    long xsplit_match_count;		/* number of staged1() matches that happened to X splits when not expecting them to */

    typ_event_signatures event_signatures; /* Track and count unique event signatures					 */

} typ_state;

#define ORPHAN_MIN_IO	1000		/* minimum number of completed io before orphan checking is allowed */
#define ORPHAN_CHECK    100		/* every this many io allow a recheck of the active list for orphans*/
#define ORPHAN_MULT     10		/* if io has been outstanding for more than 10xmax_await ~= orphan  */

/* State Notes:
 * [1] overlapping io (same sector being read/written by one or more active io at same time) typically does not happen in 
 *     normal production environment.  However, it seems more common in testing/benchmarking environments and have encountered
 *     this with fio specifically.  The issue is, if not accounted for, the first io ends up accumulating everything and 2nd io
 *     sometimes is not created as everything associated with 2nd io finds existing event for sector/length.  This was in part
 *     due to fast cache check against "current_event" which contains pointer to last event.  The only was to counter this is
 *     a more complex check of active events.  For example, if a 'C' event happens, it should only match against events for
 *     that sector/lenght that have a 'D'ispatch event.  This means since overlapping io *may* exist the whole active list
 *     needs to be scanned for best match (aka 'C' needs an event with 'D'...).  But that is a high penalty to pay for cases,
 *     especially production cases, where overlapping io likely does not exist.  So, we add this overlapping_io count and flag
 *     overlapping io by checking the active list *once* at inserting an io event onto the active list.  Most the time the
 *     active list will have no overlapping io and we can just continue to use first match on lba/length (typ, maj, min, ...).
 *     And upon completing an io, if the overlapping io flag is set in that event, we decrement the count in state.  This
 *     should return performance back to "normal" match first levels for much of the time.  Where it becomes problematic is
 *     only when overlapping io is the norm -- as we're paying a performance price at every active io insert time but expect
 *     or hope that this once eliminates having to walk the whole list at every subsequent event (because we're expecting 
 *     overlap detection at insert to be few).  When its the norm, we've added yet another full list walk which slows things
 *     down further.  If it become a real problem then we'll need to create a hashed list based upon lba... but even that 
 *     is problematic because sector 10,len16 overlaps sector 12,len16 and hashing on sector only works if we use some type
 *     of fixed size bucket (sector range) to hash on and always check buckets before and after the one a new io points to,
 *     assuming bucket size is at max disk io size (512kb-4M).  Essentially create another type of hot lba tree except track
 *     active io not just a count, in each bucket.  Seems like a lot of work for only a little gain, but will have to see
 *     what gprof shows.
 *
 * [2] after so many io have completed, we should have a pretty good sense of what the "average" await time per io is.
 *     Therefore any io that is more than N times slower that average, might be considered an orphan.  Or even better,
 *     an io that is more than N times slower than the maximum Q2D time up to now.  For example, the program sucks in
 *     a read event that starts at 10.0000 relative time mark.  Every N events we review the active io list for potential
 *     orphans, and at 11.000, such a review is kicked off.  At that time, the maximum Q2D time is 10ms and the default
 *     orphan multiplier is 10x so the state.orphan_time is set at 11.000 - (.100 * 10) or 10.000 seconds.  Any io that
 *     is has that or older start time on the active list would have is ORPHAN_IO flag set, and any earlier io would have
 *     the flag, if set, cleared.  That latter piece is because the max latency could have changed since last review of
 *     the active list.  If its a true orphan, then the flag will still be set at the end of processing.
 *
 *     At the end of processing we should output the whole active list to a file, along with the program's guess as to 
 *     whether each io was an orphan or not.  The summary section of the main output should include a line about how 
 *     many orphans are present, if non-zero.  This means the program will force one final active list review for 
 *     orphans at end of file time, before the summary is output.
 *
 *     Note that the active list is being fully scanned anyway at new active io insertion time because of having to detect
 *     overlapping io, so the depending on how slow the additional check for orphans might be, doing this frequently may
 *     be ok.  Setting an io quanta check is problematic in that some time waiting for N io to complete might cover multiple
 *     seconds... but that is actually ok.  In such a case the active io list itself will be small at all times or should be.
 *     The purpose of orphan checks is to try and get the logic correct such that orphans eventually get excluded for future
 *     checks both within the overlapping io check at insertion time and the best match at find_event() time when overlapping
 *     io are present.  That latter case, since it only is suspected to happen in testing, means it could be a significant
 *     win to detect and isolate orphans in that testing environments are the busiest with upwards of 100k or more iops per
 *     second and an active list that hovers at nr_requests+lun-queue-size in length.
 */



/* ------------------------------------------------------------------------------------ */
/* --- END: Binary output files ------------------------------------------------------- */
/* ------------------------------------------------------------------------------------ */

/* ------------------------------------------------------------------------------------ */
/* --- GLOBALS ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------------------ */
static typ_state state;


/* --- Filenames ---------------------------------------------------------------------- */
char devicename [MAXBUF];                                                           /* Expected                                   Default                         */
char inpfilename[MAXBUF];       /* ascii  input  parsed output from blkparxe   */   /* <devicename>.blktrace.txt               :: blktrace.parse.txt              */
char outfilename[MAXBUF];       /* ascii  output summary one-liner output      */   /* <devicename>.blktrace.merged.txt        :: merged.txt                      */
char excfilename[MAXBUF];       /* ascii  output events flagged as exception   */   /* <devicename>.blktrace.merged.exceptions :: merged.exceptions               */
char addfilename[MAXBUF];       /* ascii  output state annotated event listing *    /* <devicename>.blktrace.merged.annotated  :: merged.annotated                */
char bckfilename[MAXBUF];       /* ascii  output activity in disk buckets       */  /* <devicename>.blktrace.merged.buckets    :: merged.buckets                  */
char evtfilename[MAXBUF];       /* binary output file for each event.           */  /* <devicename>.blkparse.merged.events.bin :: merged.events.bin               */
char binfilename[MAXBUF];       /* binary output file for bucket (bin'd) data   */  /* <devicename>.blkparse.merged.bucket.bin :: merged.bucket.bin               */
char hotfilename[MAXBUF];       /* binary output file for hotspot data          */  /* <devicename>.blkparse.merged.hotlba.bin :: merged.hotlba.bin               */
/*   grpfilename[MAXBUF];       /* binary output file for group hotspot data    */  /* <group-name>.blkparse.merged.hotlba.bin :: n/a                             */
FILE     *inpf;			/* main input stream from blkparse 								*/
FILE     *outf;			/* main output file, 1 line containing all merged events for an io				*/
FILE     *excf;
FILE     *addf;			/* annotated output, has input stream events w/state info					*/
FILE     *bckf;			/* bucket/heat map output file									*/
FILE     *CSVf;
int       csvf;
/*ILE    *evtf;															*/
/*ILE    *binf;															*/
/*ILE    *hotf;															*/
FILE     *logF;			/* logged program output file									*/


#define MAX_EVENTS_BEFORE_FIRST_COMPLETE 10000
#define MAX_TOP_OF_FILE_LINES            400		/* "top of file" where we consider orphan events w/o staged/mainio ok   *//* ...and discard */
#define MAX_TOP_OF_FILE_QEVENTS          200		/* "top of file" where if not enough Q events have occurred, ok ignore  *//* ...and discard */


char homedirloc [MAXBUF]="~/.config/blktrace/blktrace.conf";
char thisdirloc [MAXBUF]=                 "./blktrace.conf";

int    field_set=0;
long   field_prg, field_flt, field_cpu, field_pid, field_size, field_sector, field_seek, field_desc, field_req, field_merge;
double field_queue, field_q2i, field_q2d, field_d2d, field_d2c, field_q2c;

/* NVMe blktrace is "special":
 * 259,15  20       13     0.000126716 34533  A   W 8742769112 + 256 <- (259,24) 8742766976
 * 259,24  20       14     0.000126931 34533  Q   W 8742769112 + 256 [kworker/u642:0]
 * 259,24  20       15     0.000127066 34533  G   W 8742769112 + 256 [kworker/u642:0]
 * 259,24  20       16     0.000127360 34533  I   W 8742769112 + 256 [kworker/u642:0]
 * 259,24  20       17     0.000129411 34792  D   W 8742769112 + 256 [kworker/20:2H]
 *
 * Note: device 259,24 partition1 has lba mapped to 259,15 (base device)... but then
 *       the blktrace events revert back to saying the remapped LBA 8742769112 is on
 *       the 259,24 partition1 device and not the correct 259,15 device as expected.
 *       The following helps track and correct this behavior.  Otherwise we end up
 *       with 10,000+ orphan A events for 259,15 that never leave the staging queue
 *       which ends up really slowing down processing.
 */
int special_nvme_device     = 0;	/* if devicename in filename is nvme*					*/
int special_nvme_partition  = 0;	/* if devicename in filename is nvme*pN					*/
int special_nvme_main_major = 0;	/* capture from first 'A' event						*/
int special_nvme_main_minor = 0;	/* " "									*/
int special_nvme_part_major = 0;	/* " "									*/
int special_nvme_part_minor = 0;	/* " "									*/

/* -------------------------------------------------------------------------------------------------------------------- */
/* -------------------------------------------------------------------------------------------------------------------- */

int read_event(char *inpline);

/* State/Setup														*/
/* -------------------------------------------------------------------------------------------------------------------- */
int        parse_args (int argc, char *argv[] );
FILE      *parse_setup();
int        parse_config();
int        useage();
int        setup_evtformat_io_table();
int        state_init();


/* ********************************************************************************************************************** */
/* *** STATS UTILITIES                                                                                                *** */
/* ********************************************************************************************************************** */
int        stats_samp_init();
int        stats_summ_init();
int        stats_samp_accumio(typ_io *io);
int        stats_summ_accumio(typ_io *io);
int       _stats_accum_init(typ_accumulator *accum);
int        stats_check_boundary( typ_io *io, int handle_idle );
int        stats_samp_output( int flg );
int        stats_summ_output( int flg );
int       _stats_accum_output( typ_accumulator *data, char *styp, int typ );
typ_remaps *find_remaps( int to_major, int to_minor, int from_major, int from_minor);
int         dump_remaps();

/* ********************************************************************************************************************** */
/* *** BINS UTILITIES                                                                                                 *** */
/* ********************************************************************************************************************** */
/* BINS[] - sort io into bins by time/size										  */
/* ---------------------------------------------------------------------------------------------------------------------- */
int bin_init();
int bin_init_sample();
int bin_sample(float kbsize, float q2c, int iotype );
int bin_await (float kbsize, float q2c );
int bin_kbs   (float kbsize, float q2c );
int bin_rrq   (float kbsize, float q2c );
int bin_wrq   (float kbsize, float q2c );
int dump_await_bins();
int dump_kbs_bins();
int dump_rrq_bins();
int dump_wrq_bins();
int dump_bins();
/* ********************************************************************************************************************** */

/* ********************************************************************************************************************** */
/* *** HEATMAP UTILITIES                                                                                              *** */
/* ********************************************************************************************************************** */
/* HEATMAP - track io to different lba range segments on the disk                                                         */
/* ---------------------------------------------------------------------------------------------------------------------- */
int              heatmap_disk_access_init     ();
int              heatmap_disk_access_dump     (int threshold, int flag);
int              heatmap_disk_access_bucket   ( long sector, long secsize, float q2c, float d2c, int requeue, int iotype );
#define          heatmap_disk_access_to_bucket(      _sector ) ((_sector) / (disk_stripe_size_in_kb*2L))
int              heatmap_disk_access_to_segment( int bucket );
typ_disk_stripe *heatmap_disk_access_mapbucket ( int segment, int bucket );
int              heatmap_disk_access_sum_stripes( typ_disk_stripe *summ );
int              process_disk_groups();
int              process_disk_group(typ_conf_group *group );
/* ********************************************************************************************************************** */


/*** STATE TRACKING ***/
int        state_event_count(typ_event *this);		/* raw count of the different event types encountered 		*/


int        free_event     (typ_event *event);
int accum_event(typ_event *event);
int summ_event (typ_event *event);
int accum_dump(int to_be_continued);
int summ_dump();
int test_boundary(typ_event *event);
int test_sample_time_boundary(typ_io *io);




int process_groups();

/* Utilities: String, General							*/
/*  --------------------------------------------------------------------------- */
int    strskip    (char **pptr, char *list);
int    strtrim    ( char  *bgn );
char  *get_token  (char **pptr, char *token);
int    get_tokend (char **pptr, char *token, char *dlimits);
int    getdecnum  (char **pptr );
long   getldecnum (char **pptr );
double getfloatnum(char **pptr );
char  *get_user_account();

/* Utilities: Memory								*/
/*  --------------------------------------------------------------------------- */
void *_malloc_event(unsigned int size);
void *_malloc_io(unsigned int size);
void *_malloc_ioinfo(unsigned int size);
void  _free_ioinfo(void *ptr );



int    read_major(char *inpline);
int    lvm_check(typ_actions *events);

int show_configuration(FILE *filf, int flg );
int accumulator_dump( typ_accumulator *data, char *styp, int typ );

int check_in_progress(int lineno );
int dump_io_dbg(typ_io *io);
int dump_io_raw(typ_io *io, char *reason,int lineno);
int dump_event_raw(typ_event *this);


/* Event processing, support routines; move event time to typ_io data structure 				*/
/* ------------------------------------------------------------------------------------------------------------ */
int assign_queue   ( typ_io *io, double timestamp, int flg );
int assign_insert  ( typ_io *io, double timestamp, int flg );
int assign_dispatch( typ_io *io, double timestamp, int flg );
int assign_complete( typ_io *io, double timestamp, int flg );
int set_event_mask1( typ_io *io, int    action_evtndx      );
int clr_event_mask1( typ_io *io, int    action_evtndx      );
int set_event_mask4( typ_io *io, int    action_evtndx1, int action_evtndx2, int action_evtndx3, int action_evtndx4 );
int clr_event_mask4( typ_io *io, int    action_evtndx1, int action_evtndx2, int action_evtndx3, int action_evtndx4 );
int cnt_event_type ( typ_io *io, char action);			/* @@@TBD					*/
char    *_showmask (int mask);

/* Events: (from man page)
 *
 * C -- complete A previously issued request has been completed.  The output will detail the sector and size of that request, as well as the success or failure of it.
 * D -- issued A request that previously resided on the block layer queue or in the i/o scheduler has been sent to the driver.
 * I -- inserted A request is being sent to the i/o scheduler for addition to the internal queue and later service by the driver. The request is fully formed at this time.
 * Q -- queued This notes intent to queue i/o at the given location.  No real requests exists yet.
 * B -- bounced The data pages attached to this bio are not reachable by the hardware and must be bounced to a lower memory location. This causes a big slowdown in i/o perfor‐
 *      mance,  since the data must be copied to/from kernel buffers. Usually this can be fixed with using better hardware -- either a better i/o controller, or a platform with
 *      an IOMMU.
 * M -- back merge A previously inserted request exists that ends on the boundary of where this i/o begins, so the i/o scheduler can merge them together.
 * F -- front merge Same as the back merge, except this i/o ends where a previously inserted requests starts.
 * M -- front or back merge One of the above
 * M -- front or back merge One of the above.
 * G -- get request To send any type of request to a block device, a struct request container must be allocated first.
 * S -- sleep No available request structures were available, so the issuer has to wait for one to be freed.
 * P -- plug When i/o is queued to a previously empty block device queue, Linux will plug the queue in anticipation of future ios being ad
 * U -- unplug Some request data already queued in the device, start sending requests to the driver. This may happen automatically if a timeout period  has  passed  (see  next
 *      entry) or if a number of requests have been added to the queue.
 * T -- unplug due to timer If nobody requests the i/o that was queued after plugging the queue, Linux will automatically unplug it after a defined period has passed.
 * X -- split  On  raid  or device mapper setups, an incoming i/o may straddle a device or internal zone and needs to be chopped up into smaller pieces for service. This may
 *      indicate a performance problem due to a bad setup of that raid/dm device, but may also just be part of normal boundary conditions. dm is notably bad at  this  and  will
 *      clone lots of i/o.
 * A -- remap For stacked devices, incoming i/o is remapped to device below it in the i/o stack. The remap action details what exactly is being remapped to what.
 *
 */

/* Event processing										*/
typ_event *clone_event(typ_event *this          );
int parse_event(typ_event *this, char *inpline  );
int remap_event    ( typ_event *event           );	/* A 					*/
int queue_event    ( typ_event *event	        );	/* Q					*/
int bmerge_event   ( typ_event *event           );	/* M					*/
int fmerge_event   ( typ_event *event           );	/* F 					*/
int sleep_event    ( typ_event *event           );      /* S					*/
int getreq_event   ( typ_event *event           );	/* G					*//* calls annotate()			*/
int insert_event   ( typ_event *event           );      /* I					*/
int dispatch_event ( typ_event *event	        );	/* D					*/
int requeue_event  ( typ_event *event           );	/* R					*/
int complete_event ( typ_event *event 	        );	/* C 					*/
int plug_event     ( typ_event *event, int typ  );	/* U, UT, P				*/
int split_event    ( typ_event *event           );	/* X					*/
int bounce_event   ( typ_event *event           );	/* B					*/
int message_event  ( typ_event *event           );      /* m					*/
int nomoveio_event ( typ_event *event           );
int annotate_event ( typ_event *event, int  mask, typ_io *io );
int flush_annotate (                                         );
int flush_postio   ( typ_event *event );
int     imb_event      ( typ_event *event );
int     imb_active_add ( typ_io    *io    );
int     imb_active_rem ( typ_io    *io    );
typ_io *imb_active_find( typ_event *event ); /* find an active IMB                        */
typ_io *imb_active_match(typ_event *event ); /* find an active IMB for this event + iotyp */
int     imb_active_crossmatch(typ_event *this, typ_io *io);
int    _imb_dump_cache ();


int exceptionevent      ( typ_event *event,             int srcline, char *rsn       );
int dbg_add_event_to_io ( typ_event *event, typ_io *io, int srcline, char *annotation);
int dbg_out_events_in_io(                   typ_io *io, FILE *filf                   );

typ_io *check_2ndhand_merging   (typ_event *event, typ_io *io, char *eventname, int *onmain);
typ_io *check_io_found          (typ_event *event, typ_io *io, char *eventname, int *onmain);
typ_io *search_mainio1          (typ_event *event, typ_io *io, char *eventname, int *onmain);
typ_io *search_mainio_special1  (typ_event *event, typ_io *io, char *eventname, int *onmain);
typ_io *search_mainio_barrier1  (typ_event *event, typ_io *io, char *eventname, int *onmain);
typ_io *search_staged1          (typ_event *event,             char *eventname, int  lineno);
typ_io *search_staged2          (typ_event *event,             char *eventname, int  lineno);
typ_io *search_staged_special1  (typ_event *event,             char *eventname, int  lineno);
typ_io *search_staged_duplicate1(typ_event *event, typ_io *io, char *eventname, int  lineno);
typ_io *search_staged_barrier1  (typ_event *event,             char *eventname, int  lineno);  /* KWIOBARRIER match/search */
typ_io *search_staged4_vmerges  (typ_event *event,             char *eventname, int  lineno);  /* DISCARDs missing merge bug workaround */
typ_io *search_staged_x360      (typ_event *event, typ_io *io, char *eventname, int  lineno);  /* For A,D,C event sequence*/
typ_io *best_match_special1     (typ_event *event, typ_io *io, typ_io *temp  );
typ_io *best_match              (typ_event *event, typ_io *io, typ_io *temp  );
int     check_mainio_special1   (typ_event *event, char *eventname            );
int     check_staged_special1   (typ_event *event, char *eventname            );
typ_io *ghost_create            (typ_event *event, int flg, int *onmain );
#define GHOST_1STHAND 1
#define GHOST_2NDHAND 2

/* IO processing										*/
/* new -> Staged list -> Mainio list -+-> Postio list -+-> Done					*/
/*                                    v                ^					*/
/*                                    +----------------+					*/
typ_io *create_io       (typ_event *this);
typ_io *create_subio    (typ_event *this);
typ_io *clone_to_subio  (typ_io    *this);
int     add_io_to_staged(typ_io    *this);
int     add_io_to_mainio(typ_io    *this);	/* only used by ghost requests			*/
int     sub_io_from_staged(typ_io  *this);
int     sub_io_from_mainio(typ_io  *this);
int     add_subio_to_mainio(typ_io *io, typ_io *subio, char *rsn);
int     move_staged_to_mainio(typ_io *this);
int     move_mainio_to_done(typ_io *this);	/* updates inProgress/Inflight counters		*/
int     move_mainio_to_post(typ_io *this);	/* captures inProgress/Inflight counters        */
int     move_postio_to_done(typ_io *this);
int     move_staged_to_dead(typ_io *this);
int     verify_staged_list(int line);
int     verify_mainio_list(int line);
int     verify_postio_list(int line);

int dbg_verify_staged_dump = 0;
int dbg_verify_mainio_dump = 0;
int dbg_verify_postio_dump = 0;



int        state_update();

typ_event *find_mainio( int pflg );
int check_for_orphans();
typ_event * check_event_mask(typ_event *new, typ_event *event, typ_event *last );
typ_event *_check_event_mask(typ_event *new, typ_event *event, typ_event *last );

/* Dump Event/IO Data Structures  								*/
/* -------------------------------------------------------------------------------------------- */
int         dump_state();
int         dump_staged_list(int lineno);
int         dump_staged_list1(typ_io *staged, int ndx, char *name);
int         dump_mainio_list(int lineno);
int         dump_mainio_list1(typ_io *mainio, int ndx, char *name);
int         dump_postio_list(int lineno);
int         dump_postio_list1(typ_io *postio, int ndx, char *name);

int output_completed_io( typ_io *io, char *reason, int qtype );
int output_remaining   ();
int output_io_header   (FILE *filf);
int output_key_header  ();

/* Fault processing 		  								*/
/* -------------------------------------------------------------------------------------------- */
unsigned long              _runtime_fault (typ_event *this, const char funcname[], int lineno, char *rsn, int ctl );  /*  7:      RUNTIME_FAULT()                           */
unsigned long   _program_processing_fault (typ_event *this, const char funcname[], int lineno, char *rsn, int ctl );  /* 21: PROG_FEATURE_FAULT                             */
unsigned long   _program_processing_fault1(typ_io    *this, const char funcname[], int lineno, char *rsn, int ctl );  /*  7: PROG_FEATURE_FAULT1   0: PROG_FEATURE_FAULT1_NO*/
unsigned long      _missing_feature_fault (typ_event *this, const char funcname[], int lineno, char *rsn, int ctl );  /* 26: MISS_FEATURE_FAULT                             */
unsigned long      _data_processing_fault (typ_event *this, const char funcname[], int lineno, char *rsn, int ctl );  /*  3: DATA_FEATURE_FAULT                             */
unsigned long             _notarget_fault (typ_event *this, const char funcname[], int lineno, char *rsn, int ctl );  /*  3: NOTARGET_FAULT                                 */
unsigned long   _discard_processing_fault (typ_event *this, const char funcname[], int lineno, char *rsn, int ctl );  /*  0: ???                                            */
static   int    _internal_exit(int sts);
#define CTL_FAULT_DEFAULT  0		/* default behavior, depends on -DDEBUG presence  	*/
#define CTL_FAULT_FORCE   -1		/* force an exit					*/
#define CTL_FAULT_IGNORE   1		/* disallow exit behavior on fault			*/
#define  EXIT              exit		/* just a macro to allow focus on controllable exit()   *//* "normal" exit 		*/
#define _EXIT             _internal_exit/* non-controllable exits -- will always exit           *//* internal fault type exit 	*/

static char _prmtyp( unsigned char prmtyp );
static long _get_filesize(char *filename);
static char *_cvtseconds( long seconds );
static char *_difseconds(              );

/* Helper routines for parse_event */
static int _get_event_action   (char **pptr, typ_event *this );
static int _get_event_iotype   (char **pptr, typ_event *this );
static int _get_event_sector   (char **pptr, typ_event *this );    
static int _get_event_length   (char **pptr, typ_event *this );
static int _get_event_remapinfo(char **pptr, typ_event *this );
static int _get_event_procname (char **pptr, typ_event *this );
static int _get_event_iocommand(char **pptr, typ_event *this );
static int _get_event_garbage  (char **pptr, typ_event *this );

int event_sig_add(typ_io *io, typ_event *event);

       int  io_sig_init( FILE *iof );
       int  io_sig_dump( FILE *iof );
static int _io_sig_dump( FILE *iof, typ_event_sighdr *sighdr, char *title);

typ_event_signature *io_sig_count( char *event_sigs );

static typ_event_signature *_io_sig_add(typ_event_sighdr *sighdr, char *signature );
static typ_event_sighdr    *_io_sig_hdralloc(typ_event_sighdr **psighdr);
static typ_event_datablk   *_io_sig_blkalloc(typ_event_sighdr   *sighdr);


int dbg_lineno;
/*
 * Function   : main()
 * Description: read in output from blkparse and glue all individual events for a given
 *              io together into one liner output.
 * Args       : 
 * Input      :
 * Output     :
 */
int main(int argc, char *argv[])
{
FILE *inpf;
int n, cpu;
int sav;
typ_event this;

    parse_args( argc, argv );
    inpf = parse_setup();

    /* Read blktrace event stream from input file...				  */
    while (fgets(state.inpline,MAXBUF,inpf) > 0)
    {
        flush_annotate();
        if (state_update() == 1) continue;				         /* if non-event, get next line   */
	q1printf( "--end------------------------------------------------\n\n");   /* end previous event processing */

#ifdef DEBUG
        if (mainio_on_list != (state.inProgress + (state.ghosts_created - state.ghosts_completed)))
        {
	    printf( "DBG[%05d]: assert fail( mainio_on_list %d != %d state.inProgress) ghosts:%d:%d(%d)\n", __LINE__, mainio_on_list, state.inProgress,
		state.ghosts_created, state.ghosts_completed, (state.ghosts_created - state.ghosts_completed));
	    dump_mainio_list(__LINE__);
	    dump_state();
	    fflush(stdout);
	    sleep(1);
        }
        _assert(mainio_on_list == (state.inProgress + (state.ghosts_created - state.ghosts_completed)));
#endif 

	if (strncmp(state.inpline,"CPU",3)==0) break;		        	    /* detect end of event stream  		*/
	if (strncmp(state.inpline,"Input file ",11) == 0) { q1printf( "%s\n", state.inpline ); continue; }

	q1printf( "\n--bgn:%09d-------------------------------------- %s %%%9.5f %6d:%8d\n", state.line, _difseconds(),
		((float)(state.read_filebytes)/(float)state.totl_filebytes)*100.0, staged_on_list, mainio_on_list );
	logIprintf( "%s\n", state.inpline );
        verify_staged_list(__LINE__);
        verify_mainio_list(__LINE__);
        state.xSeqNo++;						        	    /* bump "master" ticket # for any event type */

	if (parse_event(&this, state.inpline) != 0) continue;	        	    /* parse the event info                      *//* returns 1 on "exception" event *//* -1, blank */

#ifdef NEVER
	/* @@@TBD workaround for KWIOBARRIER - discard and C FN events for now */
	if ((this.prmact == 'C') && ((this.evtflags & EVTFLG_KWIOBARRIER) != 0) && (strncmp(this.evttyp,"FN",2) == 0) && (this.evttyp[2] == 0)) 
	{
	    printf( "DBG[%05d]: skipping C FN barrier this event for now, force EVTFLG_EXCEPTION.\n", __LINE__ );
	    this.evtflags |= EVTFLG_EXCEPTION;
	    exceptionevent(&this, __LINE__, "C FN barrier event - skipping" );
	    continue;
	}
#endif

	if ((flag_discards != 0) && (this.prmtyp == IOTYP_DISCARD))
        {
	    /* temp:workaround, ignore A,Q,G events for discards until fixed	*/
	    if ((this.prmact == 'A') ||
	        (this.prmact == 'Q') ||
	        (this.prmact == 'G'))
            {
		continue;
	    }
	}

	switch (this.prmact)							    /* primary action code			 */
	{
    	    case 'A' : remap_event   (&this);       continue;		/* remAp,     io relative to partition is remapped to full phy disk */
    	    case 'Q' : queue_event   (&this);       continue;		/* Queue,     intent to queue (_merge_request call?)  */
    	    case 'M' : bmerge_event  (&this);       continue;		/* Merge (merged onto the end/back of existing request) */
    	    case 'F' : fmerge_event  (&this);       continue;		/* Merge (merged onto the front    of existing request) */
	    case 'X' : split_event   (&this);       continue;           /* Split, incoming io straddles two devices and needs to be split        */
	    case 'S' : sleep_event   (&this);       continue;           /* Sleep,     get/alloc request structure failure, wait for one to be freed */
    	    case 'G' : getreq_event  (&this);       continue;		/* Get request, get (alloc) a struct request container  */ /* "Generic" scsi io typically */
    	    case 'I' : insert_event  (&this);       continue;		/* Insert  ,  into io scheduler */
    	    case 'D' : dispatch_event(&this);       continue;		/* Dispatch,  to hba driver     */
	    case 'R' : requeue_event (&this);	    continue;		/* Requeue,   io "failed" but will be retried */
    	    case 'C' : complete_event(&this);       continue;		/* Completed, io done           */

	    case 'N' : nomoveio_event(&this);       continue;		/* N          not covered in man page, but no data movement io?          */

    	    case 'P' : plug_event    (&this,  1);   continue;		/* Plug, typ. empty queue so this is 1st request, plug to await io train */
    	    case 'U' : plug_event    (&this,  0);   continue;		/* Unplug, allow io to drain to hba driver              		 */
    	    case 'T' : plug_event    (&this, -1);   continue;		/* Timer expire, unplug due to timer expires like cfg_slice idle         */

	    case '@' : exceptionevent(&this,BADEVT);continue;		/* parsing of the event failed or detected an issue such that we cant use*//* add to exception list */
    	    case 'm' : message_event (&this); 	    continue;		/* message event, silently toss if io type is N (none) as it should be   */
	    case '-' : --state.xSeqNo;              continue;
    	    default  : --state.xSeqNo; logEprintf( "%%E-unknown action '%c' '%s'\n", this.prmact, state.inpline );
	}
        printf( "DBG[%05d]: inp [%5d].'%s'\n", __LINE__, state.line, state.inpline );
    }
    fclose(inpf);
    flush_annotate();
    q1printf( "--end------------------------------------------------\n\n");   /* end previous event processing */
    printf( "%%I[%05d]-eof blktrace.txt input file reached.\n", __LINE__ ); fflush(stdout);

  
    /* --- EOF Time; wind down the processing ----------------------------------------------------------------- */ 
    flush_postio(NULL);		/* flush out any/all io on postio -- they have completed			*/
    stats_samp_output(0);	/* flush any data from last section of file that didn't reach next tmo boundary */
    fprintf( outf, "\n");
    fprintf( outf, "# --- File Summary %s ----------------------------------------------------------------------\n", inpfilename );
    stats_summ_output(0);	/* flush all accumulated stats for the whole file                               */
    output_remaining();		/* flush/dump out any partials still retained in staged/mainio/postio queues    */
    fprintf( outf, "#\n");
    fprintf( outf, "# #CPU :  Started    Ended  Crossed\n");
    for (cpu=0;cpu<MAXCPUS; cpu++)
    {
	if ((summ.cpu_bgn[cpu] + summ.cpu_end[cpu] + summ.cpu_crx[cpu]) == 0) continue;
	fprintf( outf, "#  %4d : %8d %8d %8d\n", cpu, summ.cpu_bgn[cpu], summ.cpu_end[cpu], summ.cpu_crx[cpu] );
    }
    fprintf( outf, "#\n");
    fprintf( outf, "#  Per IO\n");
    fprintf( outf, "#  Transfer     #IO\n");
    fprintf( outf, "#  Sectors        count Q2I       Total        Avg         Q2D       Total        Avg         Q2C       Total        Avg                'Size'\n");

    for (n=0; n<6; n++)
    { int nio = state.total_io;
	if (nio == 0) nio++;
        switch (n)
	{
	    case 0: fprintf( outf, "#    0 - %4d  ", EVENTDATA_SUBPAGE                    ); break;
	    case 1: fprintf( outf, "# %4d - %4d  ",  EVENTDATA_SUBPAGE+1, EVENTDATA_SMALL ); break;
	    case 2: fprintf( outf, "# %4d - %4d  ",  EVENTDATA_SMALL+1,   EVENTDATA_MEDIUM); break;
	    case 3: fprintf( outf, "# %4d - %4d  ",  EVENTDATA_MEDIUM+1,  EVENTDATA_LARGE ); break;
	    case 4: fprintf( outf, "# %4d - %4d  ",  EVENTDATA_LARGE+1,   EVENTDATA_JUMBO ); break;
	    default:fprintf( outf, "#      > %4d  ",                      EVENTDATA_JUMBO ); break;
        }
        fprintf( outf, "%8d Q2I: %16.9f/%12.9f Q2D: %16.9f/%12.9f Q2C: %16.9f/%12.9f  %5.1f%% %s\n",
	eventdata[n].count,
	eventdata[n].Q2I  , ((eventdata[n].count > 0)?(eventdata[n].Q2I / (double)eventdata[n].count):0.0),
	eventdata[n].Q2D  , ((eventdata[n].count > 0)?(eventdata[n].Q2D / (double)eventdata[n].count):0.0),
	eventdata[n].Q2C  , ((eventdata[n].count > 0)?(eventdata[n].Q2C / (double)eventdata[n].count):0.0),
	(eventdata[n].count * 100.0)/(float)nio,
	eventdata_desc[n] );
    }
    fprintf( outf, "#\n");
    fprintf( outf, "# Subpage and Small io sizes are typically inefficient (except on high iops devices like NVMe)\n");
    fprintf( outf, "# Medium io sizes are ok, but Large io size is typically the spot on the performance curve where\n");
    fprintf( outf, "#        efficiency is best before it starts to flatten out again for Jumbo and Xtra sized io.\n");
    fprintf( outf, "#\n");
    fprintf( outf, "Total io = %6d I/O Aligned to (%4ld) = %d (%12.9f%%) [-aNNN; align check %s]\n", 
	state.total_io, conf_alignquanta, state.total_aligned, (((float)state.total_aligned * 100.0)/(float)state.total_io), ((flag_alignchk==0)?"off":"on ") );
    fprintf( outf, "#\n");
    dump_bins();

    process_disk_groups();

    if (state.xsplit_match_count == 1000)
	       logHprintf( "%%I[%05d]: recommended to add -XX option to command line!\n", __LINE__ );
    if (conf_exceptions_inhibit == 0)
	fprintf( excf, " %%I[%05d]-%d events processed, %d exceptions noted (%d plug flow, %d badfmt), %d events discarded\n", __LINE__, state.events_total, 
		state.events_exceptions, state.events_exceptplugs, state.events_exceptbadfmt, state.events_discarded );
    fprintf( outf, " %%I[%05d]-%d events processed, %d exceptions noted (%d plug flow, %d badfmt), %d events discarded\n", __LINE__, state.events_total, 
		state.events_exceptions, state.events_exceptplugs, state.events_exceptbadfmt, state.events_discarded );
    fprintf( outf, " %%I[%05d]-Success. EOF reached.\n", __LINE__ );
    fclose(outf);
    fclose(excf);
    fclose(addf);
    fclose(bckf);

    sav = flag_debug; flag_debug = 1;
    dump_staged_list(__LINE__);
    dump_mainio_list(__LINE__);
    dump_postio_list(__LINE__);
    _imb_dump_cache();
    io_sig_dump(stdout);
    flag_debug = sav;
    dump_state();
    printf( "%%I[%05d]-%d events processed, %d exceptions noted (%d plug flow, %d badfmt), %d events discarded\n", __LINE__, state.events_total, 
		state.events_exceptions, state.events_exceptplugs, state.events_exceptbadfmt, state.events_discarded );
    printf( "%%I-successful completion\n");
    return(0);
}


/**
 * ==========================================================================================
 * Function : state_update
 *            @
 * Args     : @none
 *
 * Returns  : 0
 *
 * Description
 * Update basic state info when a new line is read in from the blktrace raw event file.
 * This includes saving last input line, current input line, and trimming off trailing 
 * whitespace. Reset the annotated flag which will only be set again when this event is output
 * to the annotation file. Track input file line number, and verify that a C event has happened
 * with a reasonalbe amount of time/input.  That latter is required because nvme event traces,
 * for example, contain Q events but never any C events.  Without a C event the tracking list
 * grows and grows slowing down processing since the code doesn't expect the active io list to
 * grown much beyond 2xnr_requests in size -- which is a fairly limited number even if nr_requests
 * was upped to 8192 or something large like that.  Without this shortcut bail out, the program
 * ended up trying to track 100s of thoushsand of active requests.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 **/
int state_update()
{
    /*
     * State info: capture basic information on this event into state 
     *             at start of new event
     */ 
    state.line++;
    state.flag_annotated = 0;

    state.read_filebytes += (long)strlen(state.inpline);
    if ((state.read_filebytes > state.next_filebytes) || (state.line > state.next_line))
    {
        printf( " %%I[%05d]-%9ld of %9ld bytes read (%%%6.2f)\n",  __LINE__, state.read_filebytes, state.totl_filebytes, ((float)(state.read_filebytes)/(float)state.totl_filebytes)*100.0 );
	if (state.read_filebytes > state.next_filebytes)
            state.next_filebytes += state.diff_filebytes;
	if (state.line           > state.next_line     )
	    state.next_line      += NEXT_LINES_QUANTA;
    }
    strtrim(state.inpline);
    strcpy(state.lstline, state.inpline);
    if (state.inpline[0] == '#') return(1); /* continue; don't parse this line */
    if ((state.event_count_complete == 0) && (state.line > MAX_EVENTS_BEFORE_FIRST_COMPLETE))
    {
        /* bad file? no 'C' events in in first part of input file??? */
        /* this can happen with nvme/blkmq as only Q events present  */
        fprintf( outf, "# Events read: %ld, completion events = 0!!!  Skipping file.\n", state.line );
        fprintf( outf, " %%E[%05d]: too many events read in (%d) without encountering a 'C'omplete event, exiting\n", __LINE__, MAX_EVENTS_BEFORE_FIRST_COMPLETE );
        fclose ( outf );
	PROG_FEATURE_FAULT(NULL,(int),"no C events detected",CTL_FAULT_FORCE);
    }
    return(0);
}


/*
  8,0   18        3     0.000001721 30916  Q  WS 173237576 + 8 [mysqld]
  8,0   18        4     0.000004895 30916  G  WS 173237576 + 8 [mysqld]
  8,0   18        5     0.000006937 30916  P   N [mysqld]
  8,0   18        6     0.000007879 30916  I  WS 173237576 + 8 [mysqld]
  8,0   18        0     0.000011862     0  m   N cfq30916S / insert_request
  8,0   18        0     0.000013135     0  m   N cfq30916S / add_to_rr
  8,0   18        7     0.000019898 30916  U   N [mysqld] 1
  8,0   18        0     0.000022715     0  m   N cfq workload slice:100
*/
int read_major(char *inpline)
{
char *ptr = inpline;
char token[MAXBUF];
int  major;
	skip_whitespace(&ptr);
	strtrim(ptr);
	major = getdecnum(&ptr); ptr++; skip_whitespace(&ptr);
	return(major);
}
/* Parse the blktrace event information into global 'this' event */
/*
 * Function   : parse_event( *event, *inpline )
 * Description: parse the blkparse text string of a single blktrace event
 * Args       : event structure to be filled in and blkparse string read from parse output file
 * Input      : blkparse input line
 * Output     : filled in event block
 * Returns    : 0 = parse was successful w/o issue
 *              1 = exception noted, skip this event -- event was added to "exceptions" list within state
 */
int parse_event(typ_event *this, char *inpline)
{
char *ptr = inpline;
char *bgn;
char *rwbs;
char token[MAXBUF];
char missing_fields[MAXBUF];
int  badfmt = 0;    /* event format malformed, i.e. we don't recognize it matching known field combos */
unsigned long imb_ws;
unsigned long imb_fws;
int           allow_none;
int           none_ok;
int           allow_exception;
unsigned int  iomask;
#define _isRemap( _ptr )    ((*ptr != 0) && (ptr[0] == '<') && (ptr[1] == '-'))
#define _isIOCMD( _ptr )    ((*ptr != 0) && (*ptr   == '('))
#define _isProcName( _ptr ) ((*ptr != 0) && (*ptr   == '['))
#define __kwio_assert( _arg, _this, _comment ) \
    if (!(_arg)) printf( "DBG[%05d]: assert failed, %s kwio count=%d :: %s\n", __LINE__, _comment, state.kwiobarrier, state.inpline );

#define __kwio_flags( _this ) \
    printf( "DBG[%05d]: kwio_flags | imbtyp %d event '%s' '%s' (%d|%ld, %d|%ld) kwiobarrier_count=%d\n", __LINE__, \
                          _this->imbtyp,\
                          _this->evtact, _this->evttyp,\
                         (_this->evtflags & EVTFLG_VALID_SECTOR)!=0?1:0, _this->sector,\
                         (_this->evtflags & EVTFLG_VALID_LENGTH)!=0?1:0, _this->length,\
			   state.kwiobarrier );\
    printf( "DBG[%05d]: kwio_flags | evtflags %016lX - before setting FWS/KWIO flags %016lX/%016lX\n", __LINE__, _this->evtflags, EVTFLG_SPECIAL_FWS, EVTFLG_KWIOBARRIER );\
    _this->evtflags |= (EVTFLG_KWIOBARRIER | EVTFLG_SPECIAL_FWS);\
    printf( "DBG[%05d]: kwio_flags | evtflags %016lX - after  setting FWS/KWIO flags\n", __LINE__, _this->evtflags );



    state.events_total++;

    bzero(this,sizeof(typ_event));
    _MARKER_(this);

    _assert( strlen(inpline) < sizeof(this->event_text) );
    strcpy(this->event_text, inpline );

    skip_whitespace(&ptr);
    strtrim(ptr);

    if (strlen(ptr) == 0) return(-1);	/* blank line! */


    /* 
     * "New" style:
     *   8,1   28        1     0.000000000  4923  A  WM 64 + 16 <- (253,4) 524594440
     *   8,16   8    86003    90.073958541  4923  Q  WM 64 + 16 [xfsaild/sdb]
     *   8,16   8    86004    90.073958824  4923  G  WM 64 + 16 [xfsaild/sdb]
     *   8,16   8    86007    90.073960976  4923  I  WM 64 + 16 [xfsaild/sdb]
     *   8,16   8    86011    90.073971768  4923  D  WM 64 + 16 [xfsaild/sdb]
     *   8,16   8    86014    90.074095632     0  C  WM 64 + 16 [0]     *
     *   Exception/corner cases:
     *   8,16   8    86014    90.074095632     0  C  WFS 64 [0]  << no length specified! typically will be implicit barrier
     *
     *
     * "Old" style: you have to assume only 1 io at a time -or- match on io command itself which
     *              has sector/length buried within the scsi command block. Ugh! Mostly this was
     *              appearing for non-disk media commands like INQUIRY which is a dma/read-in from
     *              storage but not media:sector/length related but a storage target command, not
     *              a storage media command.
     * 65,0    1       69     3.922432310     0  C   R (12 00 00 00 fe 00 ..) [0]
     * 65,0    6        3     3.922302438 30830  I   R 254 (12 00 00 00 fe 00 ..) [scsi_id]  12h = INQUIRY.
     * 65,0    6        4     3.922303694 30830  D   R 254 (12 00 00 00 fe 00 ..) [scsi_id]  << scsi_id invoked from udevd most likely
     * 65,0    1       69     3.922432310     0  C   R (12 00 00 00 fe 00 ..) [0]
     */


    /*   M,m   CPU    Seq#    Timestamp     PID Act Typ   Sector           Length  ProcName					
     *   8,16   1     1395    59.993920750  4754  I FWFSM 757449264  +          3 [kworker/1:1H]	<< common format A.1 (SL  : sector, non-zero length         ) [Note.1]
     *   253,89 143   109610 119.991621946 52207  X     R 3128572288 / 3128572384 [postgres]		<< common format A.2 (SL/S: " " plus split point            )
     *    A  B  C     D      E             F      G     H I            J           K 					
     *
     *   M,m   CPU    Seq#    Timestamp     PID Act Typ   Sector     Len    ___Remap_Infor___       
     *   259,0   11   19       5.027073014  1889  A  FWFS 575480512  + 4 <- (253,3) 407706304             << common format B (SL/R: sector+(>0 length) + remap from dev,sector
     *   259,0   11   19       5.027073014  1889  A  FWFS 575480512  + 0 <- (253,3) 407706304             << common format B (S0/R: sector+(=0 length) + remap from dev,sector
     *    A  B  C     D      E             F      G     H I            J     L   M  N
     *
     *   M,m   CPU    Seq#    Timestamp     PID Act Typ   Sector     Len           ProcName					
     *   259,0   11   20       5.027074128  1889  Q  FWFS                          [jbd2/dm-4-8]        << IMB type xx/W, event type include W+S
     *   259,0   11   21       5.027077378  1889  G  FWFS                          [jbd2/dm-4-8]        <<   "         "
     *   259,0   11   22       5.027084885   612  D    FN                          [kworker/11:1H]      << IMB type xx/N, event type is 'N'one for io type
     *   259,0   11   23       5.027852186     0  C    FN 0                        [0]                  << IMB type 0x/N, event type is 'N'one with explicit 0 for sector, no length
     *   259,0   11   24       5.027859859     0  C   WFS 575480512                [0]                  << IMB type Sx/W, event type w/>0sector, no length             [Note.2]
     *    A  B  C     D      E             F      G     H I            J           K 					
     *
     *   M,m   CPU    Seq#    Timestamp     PID Act Typ   Sector     Len           ProcName					
     *   259,0    3   16       0.023989209  1867  P     N                          [dmcrypt_write/2]    << xx/N, a non-io management event(s), typicall tagged as Other or Mgmt
     *    A  B  C     D      E             F      G     H I            J           K 					
     *
     *   An older style still supported:
     *   M,m   CPU    Seq#    Timestamp      PID Act Typ   Sector     Len           SCSI/ATA IO Command    ProcName					
     *   65,0    1    69       3.922432310     0   C    R                            (12 00 00 00 fe 00 ..) [0]
     *   65,0    6    3        3.922302438 30830   I    R  254                       (12 00 00 00 fe 00 ..) [scsi_id]  12h = INQUIRY.
     *    A B    C    D      E             F       G    H I            J             O                      K 					
     *
     * A-H  : These parts are standard and should always be present on all events.
     * I,J,K: The vast majority of events will also have I,J,K parts. These are expected for all actual data movement commands.
     * L,M,N: Remaps are common and will include the block device maj,min number and sector being mapped from.
     * O    : This is old style events which included text blocks with the scsi/ata command byte information.  So not
     *        see these in nearly forever (since 2012'ish)
     *
     * Notes:
     * 1. An SL format requires the length to be non-zero, but the sector can be zero in this case, aka io at start of disk
     *    But if the Length is zero, then this must be either an S0 (non-zero sector, zero length) or 00 (both zero) format.
     *    Such formats indicate a non-data movement command typically associated with IMplicit Barriers.
     * 2. The Sx/W IMB type includes the same specified sector as the original A|Q events minus any leading 'F'UA qualifier.
     *    But otherwise, matching the event type to the io context with A|Q information will work to match event io type plus
     *    the non-zero sector number.  Its possible this type of io is performed against sector 0 on the disk, in which case
     *    it will be a Ox/W IMB type.  The logic, while special case, still works.  But its noted that 0x/W format lines typically
     *    are not being seen in the wild (yet).  But the code still has to handle them jic.
     */


    /* Parse A-H parts here.				*/
    this->major         = getdecnum(&ptr); ptr++; skip_whitespace(&ptr); xprintf( "  xDBG: maj %d '%s'\n",  this->major,  ptr );
    this->minor         = getdecnum(&ptr);        skip_whitespace(&ptr); xprintf( "  xDBG: min %d '%s'\n",  this->minor,  ptr );
    this->cpu           = getdecnum(&ptr);        skip_whitespace(&ptr); xprintf( "  xDBG: cpu %d '%s'\n",  this->cpu,    ptr );
    this->seqnum        = getldecnum(&ptr);       skip_whitespace(&ptr); xprintf( "  xDBG: seq %ld '%s'\n", this->seqnum, ptr );
    this->timeinfo.time = getfloatnum(&ptr);      skip_whitespace(&ptr); xprintf( "  xDBG: tim %12.9f '%s'\n", this->timeinfo.time, ptr );
    this->timeinfo.line = state.line;
    this->pid           = getdecnum(&ptr);        skip_whitespace(&ptr); xprintf( "  xDBG: pid %d '%s'\n",     this->pid,       ptr );
    _get_event_action(&ptr, this);    /* 'G' the A,Q,S,G,I,D,C event action types */
    _get_event_iotype(&ptr, this);    /* 'H' the R,W,N,D,M,... event io     types */

    state.time          = this->timeinfo.time;


    /* Up until now all the fields have been "standard"/common ones, but */
    /* now, depending on action type (A|Q|... U|P...), the following     */
    /* fields may be different -- although the vast majority if io based */
    /* will be the sector + length [procname] format type. Event actions */
    /* imply both a subset of expected event types and formats		 */
    dxprintf( "DBG[%05d]: except: %c fmt: %d  none: %c\n", __LINE__,
		    ((this->evtflags & EVTFLG_EXCEPTION) == 0)?'F':'T',
		    evtformat_io[ (unsigned char)this->prmact ],
		    (this->prmtyp != IOTYP_NONE)?'F':'T' );

    /* Now we need to determine if there are sector,length parts present */
    /* Things the definitely indicate not are '[', '(', '<'              */
    /* So try and get two valid numbers, separated by '+' or '/' before  */
    /* hitting a stopper character of '[', '(', '<'                      */
    if ((*ptr != '[') && (*ptr != '(') && (*ptr != '<'))
    {
        /* Should be up to two numbers present */
        _get_event_sector(&ptr, this);
	_get_event_length(&ptr, this);
    }
    
    if (_isProcName(ptr))			/* account for older remap events that had a procname before "<-"	*/
	_get_event_procname (&ptr, this );      

    if (_isIOCMD(ptr))
	_get_event_iocommand(&ptr, this );

    if (_isRemap(ptr))
	_get_event_remapinfo(&ptr, this );

    if (_isProcName(ptr))
	_get_event_procname (&ptr, this );

    if (*ptr != 0)
        _get_event_garbage  (&ptr, this );    /* can also be the rare 'm'essage type with text message string		*/

    imb_event(this);

    /* DEBUG */
    dump_event_raw(this);


    /* OK, all parsing done by this point, should have found a sector,length 	*/
    /* Look for "special" cases, specifically KWIOBARRIER types (ibmtyp != NONE)*/
    /* The SPECIAL_FWS (Flush/Write/Sync) and KWIOBARRIER flags are  only used  */
    /* for **ADVISORY** purposes.  Flagging the event as most likely belonging  */
    /* to a barrier io due to sector,length combos being anything other than SL */
    /* (a Length being present and > 0, plus sector >= 0 value). See the file   */
    /* typ_blktrace.h for additional info on ibmtyp value range and meaning.    */
 

    /* 
     *        IMB_S0   ::
     *        FWS+KWIO :: 259,0    0        1     2.152241827 138872 A FWFSM 67137916 + 0 <- (253,0) 67135868       
     *        FWS+KWIO :: 259,0   11       19     5.027073014  1889  A FWFS 575480512 + 0 <- (253,3) 407706304
     *        FWS+KWIO :: 259,0    6        1     2.128390708 13905  A FWS       2048 + 0 <- (253,0) 0                      
     *
     *        IMB_00   ::
     *        FWS+KWIO :: 253,89  101      59     0.001563807 19690  A FWS 0 + 0 <- (253,456) 0        << note there sector is explicit '0'
     *
     *
     *        IMB_xx   ::
     *        FWS+KWIO :: 259,0    0        2     2.152242126 138872 Q FWFSM [kworker/0:0]
     *        FWS+KWIO :: 259,0   11       20     5.027074128  1889  Q FWFS  [jbd2/dm-4-8]
     *        FWS+KWIO :: 259,0    6        2     2.128390821 13905  Q FWS   [kworker/u24:6]
     *        FWS+KWIO :: 259,0    0        3     2.152246022 138872 G FWFSM [kworker/0:0]
     *        FWS+KWIO :: 259,0   11       21     5.027077378  1889  G FWFS  [jbd2/dm-4-8]
     *        FWS+KWIO :: 259,0    6        3     2.128394855 13905  G FWS   [kworker/u24:6]
     *
     *            KWIO :: 259,0   11       22     5.027084885   612  D  FN [kworker/11:1H]
     *
     *
     *        IMB_0x   :: 
     *            KWIO :: 259,0   11       23     5.027852186     0  C  FN 0 [0]          << 1st 'C'complete is FN 0 in Kernel write io barriers
     *
     *
     *        IMB_Sx   ::
     *        FWS+KWIO :: 259,0   11       24     5.027859859     0  C WFS 575480512 [0]  << Implied 'F'lush due to W+S and missing length @'C'omplete time
     *        FWS+KWIO :: 259,0    0        6     2.152371080     0  C WFSM 67137916 [0]  << 2nd, and final complete.
     *        FWS+KWIO :: 259,0    6        6     2.152032263     0  C WS       2048 [0]                                       
     *
     *        Normal kernel write io barrier sequence:
     *                    253,89  101       59    0.001563807 19690  A FWS 0 + 0 <- (253,456) 0
     *                    253,89  101       60    0.001563993 19690  Q FWS [mdX_raid10]
     *                    253,89  101       61    0.001564193 19690  G FWS [mdX_raid10]
     *                    253,89  101       62    0.001565379  2387  D  FN [kworker/101:1H]
     *                    253,89  101       75    0.001825737     0  C  FN 0 [0]                     
     *                    253,89  101       76    0.001826108     0  C  WS 0 [0]                     
     *
     *        Nested kernel write io barrier sequence that isn't applied as no writes outstading -or-
     *        previous nested barrier has been applied making this on redundant. Such sequences could
     *        be considered skipped (or failed) barriers.
     *                    253,89  101       70    0.001675262 19690  A FWS 0 + 0 <- (253,456) 0      
     *                    253,89  101       71    0.001675448 19690  Q FWS [mdX_raid10]
     *                    253,89  101       72    0.001675727 19690  G FWS [mdX_raid10]
     *                    253,89  101       86    0.002064615     0  C  WS 0 [0]                     << never dispatched!, no C FN 0 event.
     *
     */

    /* Barrier types often have Write/Sync io type as in FWS or WS or WSM or ...*/
    imb_ws = ((this->iomask & (IOMASK_WRITE | IOMASK_SYNC               )) == (IOMASK_WRITE | IOMASK_SYNC               ));  
    imb_fws= ((this->iomask & (IOMASK_WRITE | IOMASK_SYNC | IOMASK_FLUSH)) == (IOMASK_WRITE | IOMASK_SYNC | IOMASK_FLUSH));
    allow_none      = 0;   /* Allow 'FN' or 'N' iotyp events to be processed         */
    none_ok         = 0;   /* When set, the IOTYP_NONE (if present) has been accounted for in terms of understood context */
    allow_exception = 1;	
    switch (this->prmact)
    {
        case 'A': 
            /*        IMB_S0   ::
             *        FWS+KWIO :: 259,0    0        1     2.152241827 138872 A FWFSM 67137916 + 0 <- (253,0) 67135868
             *        FWS+KWIO :: 259,0   11       19     5.027073014  1889  A FWFS 575480512 + 0 <- (253,3) 407706304
             *        FWS+KWIO :: 259,0    6        1     2.128390708 13905  A FWS       2048 + 0 <- (253,0) 0
             *
             *        IMB_00   ::
             *        FWS+KWIO :: 253,89  101      59     0.001563807 19690  A FWS          0 + 0 <- (253,456) 0        << note there sector is explicit '0'
	     */
            if (imb_fws && ((this->imbtyp == IMBTYP_S0) || (this->imbtyp == IMBTYP_00)))
            {
                this->evtflags |= (EVTFLG_KWIOBARRIER | EVTFLG_SPECIAL_FWS);
                state.kwiobarrier++;
		allow_exception = 0;
            }

	    /* If the device name in the input file is nvme0*pN then could need */
	    /* special processing associated with nvme partition remaps         */
	    /* This adjusts the maj,min numbers being mapped into with the event*/
	    /* which could be incorrectly listed.				*/
            if (special_nvme_partition != 0)
            {
                if (special_nvme_main_major != 0)
                {
                    /* any event that match part maj,min change to main maj,min */
                    if ((this->major == special_nvme_part_major) &&
                        (this->minor == special_nvme_part_minor))
                    {
                        this->major = special_nvme_main_major;
                        this->minor = special_nvme_main_minor;
                    }
                }
            }
	    break;

        case 'Q': 
	    /*
             *        IMB_xx   :: (known/seen)
             *        FWS+KWIO :: 259,0    0        2     2.152242126 138872 Q FWFSM [kworker/0:0]
             *        FWS+KWIO :: 259,0   11       20     5.027074128  1889  Q FWFS  [jbd2/dm-4-8]
             *        FWS+KWIO :: 259,0    6        2     2.128390821 13905  Q FWS   [kworker/u24:6]
	     *
             *        IMB_S0   :: (unknown/not seen but possible if no remap but there always seems to be a remap currently)
             *        FWS+KWIO :: 259,0    0        1     2.152241827 138872 Q FWFSM 67137916 + 0 <- (253,0) 67135868
             *        FWS+KWIO :: 259,0   11       19     5.027073014  1889  Q FWFS 575480512 + 0 <- (253,3) 407706304
             *        FWS+KWIO :: 259,0    6        1     2.128390708 13905  Q FWS       2048 + 0 <- (253,0) 0
             *
             *        IMB_00   :: (unknown/not seen but possible)
             *        FWS+KWIO :: 253,89  101      59     0.001563807 19690  Q FWS          0 + 0 <- (253,456) 0        << note there sector is explicit '0'
	     */
            if (imb_fws && (this->imbtyp == IMBTYP_xx))
            {
		__kwio_assert( (state.kwiobarrier > 0), this, "Not in KWIOBARRIER? Near front of input?" );
		__kwio_flags ( this );
		allow_exception = 0;
            }
            if (imb_fws && ((this->imbtyp == IMBTYP_S0) || (this->imbtyp == IMBTYP_00)))
            {
		/* We could be nesting IMBs, so cannot assert that kwiobarrier count is zero */
		__kwio_flags ( this );
		allow_exception = 0;
                state.kwiobarrier++;
            }
            break;

        case 'G': 
            /*        IMB_xx   ::
             *        FWS+KWIO :: 259,0    0        3     2.152246022 138872 G FWFSM [kworker/0:0]
             *        FWS+KWIO :: 259,0   11       21     5.027077378  1889  G FWFS  [jbd2/dm-4-8]
             *        FWS+KWIO :: 259,0    6        3     2.128394855 13905  G FWS   [kworker/u24:6]
	     */
            if (imb_fws && (this->imbtyp == IMBTYP_xx)) 
            {
		__kwio_assert( (state.kwiobarrier > 0), this, "Not in KWIOBARRIER? Near front of input?" );
		__kwio_flags ( this );
		allow_exception = 0;
            }
            if (this->prmtyp == IOTYP_NONE)
	    {
	        /* 'G' with 'FN' or 'N' -- dont know what to do with this one */
                this->evtflags |= (EVTFLG_NONIOSTYLE | EVTFLG_EXCEPTION);
		fprintf( outf, " %%W[%05d]-'%c' event with 'N'one io type? '%s'\n", __LINE__, this->prmact, inpline );
	    }
	    break;


        case 'I': 
	    /* Are there 'I'nsert events for implicit barriers? Dont think so.*/
            if (this->prmtyp == IOTYP_NONE)
	    {
	        /* 'I' with 'FN' or 'N' -- dont know what to do with this one */
                this->evtflags |= (EVTFLG_NONIOSTYLE | EVTFLG_EXCEPTION);
		fprintf( outf, " %%W[%05d]-'%c' event with 'N'one io type? '%s'\n", __LINE__, this->prmact, inpline );
	    }
	    break;

        case 'D': 
	    /*        IMB_xx   ::
             *            KWIO :: 259,0   11       22     5.027084885   612  D  FN [kworker/11:1H]
             */
            if ((this->imbtyp == IMBTYP_xx) && ((strlen(this->evttyp) == 2) && (strncmp(this->evttyp,"FN",2) == 0)))
            {
		__kwio_assert( (state.kwiobarrier > 0), this, "Not in KWIOBARRIER? Near front of input?" );
		__kwio_flags ( this );
		none_ok         = 1; /* Prevent EXCEPTION due to 'N'one io type    */
	        allow_none      = 1; /* Allow a 'N'one type to be a non-exception */
		allow_exception = 0;
	    }
	    else if (this->prmtyp == IOTYP_NONE)
	    {
	        /* 'D' with 'FN' or 'N' -- dont know what to do with this one */
                this->evtflags |= (EVTFLG_NONIOSTYLE | EVTFLG_EXCEPTION);
		fprintf( outf, " %%W[%05d]-'%c' event with 'N'one io type? '%s'\n", __LINE__, this->prmact, inpline );
		none_ok    = 0;
	    }
	    break;

        case 'C': 
	    /*        IMB_0x   ::
             *            KWIO :: 259,0   11       23     5.027852186     0  C  FN 0 [0]          << 1st 'C'complete is FN 0 in Kernel write io barriers
             *
             *        IMB_Sx   ::
             *        FWS+KWIO :: 259,0   11       24     5.027859859     0  C WFS 575480512 [0]  << Implied 'F'lush due to W+S and missing length @'C'omplete time
             *        FWS+KWIO :: 259,0    0        6     2.152371080     0  C WFSM 67137916 [0]  << 2nd, and final complete.
             *        FWS+KWIO :: 259,0    6        6     2.152032263     0  C WS       2048 [0]
	     */
	    if (!imb_ws && (this->imbtyp == IMBTYP_0x) && ((strlen(this->evttyp) == 2) && (strncmp(this->evttyp,"FN",2) == 0)))
            {
		__kwio_assert( (state.kwiobarrier > 0), this, "Not in KWIOBARRIER? Near front of input?" );
		__kwio_flags( this );
		none_ok         = 1; /* Prevent EXCEPTION due to 'N'one io type    */
           	allow_exception = 0;
		allow_none      = 1;
		/* Not decrementing kwiobarrier count here, because it is expected */
		/* that a FN/0x type 'C'ompletion is only the 1st of two complete  */
		/* events and the 2nd W+S/Sx 'C'ompletion will do the honors. Else */
		/* the barrier count is decremented at io context move to done-q   */
	    }
	    else if (imb_ws && (this->imbtyp == IMBTYP_Sx))
	    {
		__kwio_assert( (state.kwiobarrier > 0), this, "Not in KWIOBARRIER? Near front of input?" );
		__kwio_flags( this );
		allow_exception = 0;
                if (--state.kwiobarrier < 0)                                /* @@@TBD this really belongs in postio */
                      state.kwiobarrier = 0;
            }
	    else if (this->prmtyp == IOTYP_NONE)
	    {
                this->evtflags |= (EVTFLG_NONIOSTYLE | EVTFLG_EXCEPTION);
		none_ok = 1;
	    }
	    break;

        case 'P': 
        case 'U': 
        case 'T': 
        case 'X': 
        case 'm':
	    allow_none = 1;
	    none_ok    = 1;

        case 'S': 
        case 'R': 
        case 'M': 
        case 'F': 
        default : 
	    /* Should not be anything of concern here for 'S'leeps 	*/
	    break;
    }

    if ((allow_none == 0) && (this->prmtyp == IOTYP_NONE ))
    {
        logWprintf( "%%W[%05d]: IOTYP_NONE(%d): unexpected 'N'one io type for this primary event action='%c'\n", __LINE__, this->prmtyp, this->prmact );
    }
    if ((none_ok    == 0) && (this->prmtyp == IOTYP_NONE ))
    {
        /* unexpected N event type, flag as exception and log     */
        logIprintf( "%%I[%05d]: IOTYP_NONE(%d): not in norm format per this primary type, action='%c'\n", __LINE__, this->prmtyp, this->prmact );
        this->evtflags |= EVTFLG_EXCEPTION;
        fprintf( outf, " %%E[%05d]-Event type '%s' with action type '%s' is unexpected pairing, add to exceptions.\n", __LINE__, this->evttyp, this->evtact );
        fprintf( outf, " %%I[%05d]-Input '%s'\n", __LINE__, inpline );
        sprintf( this->reason, "[%05d]: 'N' type and not (G|I|D|C|U|P|T), so not sure what the heck this is", __LINE__ );
        q0printf( "DBG[%05d]: set EXCEPTION flag on event: %s\n", __LINE__, this->reason );
          printf( "DBG[%05d]: set EXCEPTION flag on event: %s\n", __LINE__, this->reason );
    }

    /* this is just a standalone logging of barrier events, just 'cause */
    if (this->prmtyp == IOTYP_BARRIER)
    {
        fprintf( outf, " %%I-  'B'arrier IO @%12.9f w/Q:%lu D:%lu C:%lu\n",
                this->timeinfo.time, state.QSeqNo, state.DSeqNo, state.CSeqNo );
    }
    else if (this->imbtyp != IMBTYP_NONE)
    {
        fprintf( outf, " %%I-IMBarrier IO @%12.9f w/Q:%lu D:%lu C:%lu\n",
                this->timeinfo.time, state.QSeqNo, state.DSeqNo, state.CSeqNo );
    }

    if ((this->prmtyp == IOTYP_NONE) && (evtformat_io[ (unsigned char)this->prmact ]!=0))
    {
	/* 'N'one io type is non-io style of io such as IMB or TUR/INQUIRY/et.al. and	*/
	/* event type of A,Q,G,... io flow event.  So 'N'one makes this a non-data      */
	/* movement command.                                                            */
	if (allow_none == 0)
	{
            this->evtflags |= EVTFLG_NONIOSTYLE;
            sprintf( this->reason, "[%05d]: 'N' type w/ event type '%c', so not a data movement type io",   __LINE__, this->prmact );
            dprintf(            "DBG[%05d]: 'N' type w/ event type '%c', so not a data movement type io\n", __LINE__, this->prmact );
	}
    }

    if ((this->evtflags & EVTFLG_EXCEPTION) != 0)
        dprintf( "DBG[%05d]: EXCEPTION already set on event '%s'\n", __LINE__, state.inpline );


    /* Set EXCEPTION on events that the code is not going to be able to fully process    */
    /* For IMB events, allow_exceptions has been cleared so following isn't applicable.  */
    /* EXCEPTION events do not have sector and or length and or procname as expected     */
    if (allow_exception != 0)
    { int tmpflag;
        /* 
	 * Determine if no IMB processed above, and therefore a reason exists why this event 
	 * should be ignored as an EXCEPTION
	 */
	tmpflag = (((this->evtflags & EVTFLG_VALID_SECTOR ) == 0) || ((this->evtflags & EVTFLG_VALID_LENGTH ) == 0))?0:1;
	if ((tmpflag == 1) && ( ((this->evtflags & EVTFLG_VALID_LENGTH ) != 0) && (this->length == 0))) tmpflag = 0;
        strcpy(missing_fields, "[ " );

        if ( tmpflag                                ==                   0 ) strcat( missing_fields, "location{ "    );
        if ((this->evtflags & EVTFLG_VALID_SECTOR ) != EVTFLG_VALID_SECTOR ) strcat( missing_fields, "sector:"       );
        if ((this->evtflags & EVTFLG_VALID_LENGTH ) != EVTFLG_VALID_LENGTH ) strcat( missing_fields, "length "       );
	else if (this->length == 0)                                          strcat( missing_fields, "zero-length "  );
        if ( tmpflag                                ==                   0 ) strcat( missing_fields, "} "            );

	if ((this->prmact != 'A') &&
        ((this->evtflags & EVTFLG_VALID_PROCNAME)==                   0)) strcat( missing_fields, "process-name " );

        strcat(missing_fields, "]"  );

	if ((strlen(missing_fields) > 3) && ((allow_none == 0) || (this->prmtyp != IOTYP_NONE)))
	{
            xfprintf( outf, " %%E[%05d]-Missing %s field data when same was expected, add to exceptions.\n", __LINE__, missing_fields );
            xfprintf( outf, " %%I[%05d]-Input '%s'\n", __LINE__, inpline );
            sprintf( this->reason, "[%05d]: standard format, but event missing '%s'", __LINE__, missing_fields );
	    if ((this->evtflags & EVTFLG_EXCEPTION) == 0)
	    {
	        this->evtflags |= EVTFLG_EXCEPTION;
                dprintf( "DBG[%05d]: EXCEPTION being   set on event '%s'\n", __LINE__, state.inpline );
                dprintf( "DBG[%05d]:                         reason '%s'\n", __LINE__, this->reason );
	    }
	    else
	    {
                dprintf( "DBG[%05d]: EXCEPTION already set on event '%s'\n", __LINE__, state.inpline );
                dprintf( "DBG[%05d]:              but also because  '%s'\n", __LINE__, this->reason );
	    }
	}
   }


    /* evtformat_io[] is a 256 byte table with value of 1 if the event type (A,Q,G...) is recognized */
    /* as an io flow event type (vs events of P,U,T,m which are not *io* data movement flow events). */
    /* If this event is:
     *    + not currently flagged as an EXCEPTION of some kind, and
     *    + is a valid io flow event type (A,Q,G,...), and
     *    + is either
     *      + not a 'N'one type, aka is (R,W,B...), or
     *      + is  a 'N'one type of 'FN' (and redundantly has the leading 'F'lush qualifier present)
     *        and is a Q,G,D,or C event type
     * then do the following.
     */
    if (((this->evtflags & EVTFLG_EXCEPTION) == 0) && (evtformat_io[ (unsigned char)this->prmact ]!=0) &&
              ((this->prmtyp != IOTYP_NONE /* 'R'ead, 'Write, 'D'iscard - data movement io types */ ) ||
              ((this->prmtyp == IOTYP_NONE) && ((strncmp(this->evttyp,"FN",2) == 0) &&
                 ((this->prmact == 'D' /* 'FN' */) || 
		  (this->prmact == 'Q' /* 'FN' */) || 
		  (this->prmact == 'G' /* 'FN' */) || 
		  (this->prmact == 'C' /* 'FN' */))))))
    {
        /* all the flagged events in evtformat_io[] are expected to have sec+len [procname] irregardless*/
        /* of event type with the sole exception being A (remAp) events which are just slightly         */
        /* different but are lumped into this part of the event string parsing anyway....               */
        dxprintf( "DBG[%05d]: !EXCEPTION and (!IOTYP_NONE or IOTYP_NONE+FN+(D|Q|G|C) - which are allowed, so all good here)\n", __LINE__ );
    }
    else if (this->prmtyp == IOTYP_NONE )
    {
	/* handled and reported on above */;
    }
    else if (this->imbtyp != IMBTYP_NONE)
    {
        /* IMBs handled elsewhere */
	/* aka remAp events with missing procname are ok       */
	/* as are any normal R,W,D,M io types with zero sector */;
    }
    else
    {
        printf( "%%W[%05d]: IOTYP_xxxx(%d): not in norm format per this primary type, action='%c', skipping further parse\n", __LINE__, this->prmtyp, this->prmact );
    }

    if ((this->evtflags & EVTFLG_EXCEPTION) != 0)
    {
        /* clone this event and stick it onto the exceptions list within state */
        /* and DO NOT COUNT the event action nor type information(?)           */
        _CHEKER_(this);
        dprintf( "DBG[%05d]: exception noted on event, not counted, skipped - placed on exception list\n", __LINE__ );
        dprintf( "DBG[%05d]: input  = '%s'\n", __LINE__, this->event_text );
        dprintf( "DBG[%05d]: reason = '%s'\n", __LINE__, this->reason     );
        if ((this->evtflags & EVTFLG_EXCEPTDONE) == 0)			/* logic to count badfmt only once per event */
	    if (badfmt != 0)
	        state.events_exceptbadfmt++;
        exceptionevent(this, __LINE__, "event evtflags has EXCEPTION set" );

	/* Need to do a bit of sleuthing.  This could be one of those special cases */
	/* If part of the following, not both count and return(0) instead of (1)    
         * 
         *   8,6    0       10     0.000619252 126042  A FWS 0 + 0 <- (253,2) 0
         *   8,0    0       11     0.000619652 126042  Q FWS [db2sysc]
         *   8,0    0       12     0.000620552 126042  G FWS [db2sysc]
         *   8,0    0       13     0.000621052 126042  I FWS [db2sysc]
         *   8,0    0       14     0.000920178 108767  C  WS 0 [0]
         */
        if ( ((strlen(this->evttyp) == 3) && (strncmp(this->evttyp,"FWS",3) == 0)) ||
	     ((strlen(this->evttyp) == 2) && (strncmp(this->evttyp, "WS",2) == 0) && (this->prmact == 'C')) )
	{ char eventname[32]; 
	    eventname[0] = 0;
	    switch(this->prmact)
	    {
	        case 'Q': strcpy(eventname, "queue     " );
                case 'G': if (eventname[0] == 0)
	                  strcpy(eventname, "getrequest" );
		if (((this->evtflags & EVTFLG_VALID_SECTOR) == 0) &&
		    ((this->evtflags & EVTFLG_VALID_LENGTH) == 0))
		{
		    if (check_staged_special1(this,eventname) != 0)
			this->specials |= SPCFLG_00;
		}
		break;
                case 'I': strcpy(eventname, "insert    " );
		if (((this->evtflags & EVTFLG_VALID_SECTOR) == 0) &&
		    ((this->evtflags & EVTFLG_VALID_LENGTH) == 0))
		{
		    if (check_mainio_special1(this,eventname) != 0)
			this->specials |= SPCFLG_00;
		}
		break;
	        case 'C': strcpy(eventname, "complete  " );
		if (((this->evtflags & EVTFLG_VALID_SECTOR) != 0) &&
		    ((this->evtflags & EVTFLG_VALID_LENGTH) == 0))
		{
		    if (check_mainio_special1(this,eventname) != 0)
			this->specials |= SPCFLG_00;
		}
		break;
		default: break;
	    }
        }
	if ((this->evtflags & EVTFLG_KWIOBARRIER) != 0) dump_event_raw(this);
	if ((this->specials & SPCFLG_00) != 0)
	{
            state_event_count(this);	
	    _CHEKER_(this);
	    _return(0);
	}
        _return(1);
    }
    else
    {
        /* Count both the event action (Q|I...) and event type (R|W...)        */
        state_event_count(this);	
    }
    _CHEKER_(this);
    if ((this->evtflags & EVTFLG_KWIOBARRIER) != 0) dump_event_raw(this);
    _return(0);


    /* ================================================================================	*/
    /* Additional notes/examples							*/
    /* ================================================================================	*/
    /*
        The following is an example of a implicit barrier.  Note that the length in the initial
	A event is zero with sector=0 (imbtyp=00). But other exceptable barrier sequences include
	a non-zero sector (imbtyp=S0) at A events.  Whatever the explicit sector in the first A
	(or Q) event of the io context, that sector will repeat on the W+S 2nd completion event.
	Note the '0' sector in the C/FN event is not reflective of the sector, see 2nd example.
        253,89  91      892     0.058243730 19690  A FWS 0 + 0 <- (253,456) 0   @@@ mark this KWIOBARRIER state.kwiobarrier++;
        253,89  91      893     0.058243911 19690  Q FWS [mdX_raid10]		@@@ state.kwiobarrier > 0 && no sect,size
        253,89  91      894     0.058244128 19690  G FWS [mdX_raid10]		@@@ state.kwiobarrier > 0 && no sect,size
        253,89  91      895     0.058245379  2964  D  FN [kworker/91:1H]	@@@ state.kwiobarrier > 0 && no sect,size
	253,89  91      896     0.058382756  2964  C  FN 0 [0]			@@@ state.kwiobarrier > 0 && w/ sect, no size
	253,89  91      897     0.058382974  2964  C  WS 0 [0]			@@@ state.kwiobarrier > 0 && w/ sect, no size --state.kwiobarrier

	2nd example, note the C/FN has 0 for sector vs the real expected sector of 575480512
	259,0   11       19     5.027073014  1889  A FWFS 575480512 + 0 <- (253,3) 407706304            << TYPE 1
        259,0   11       20     5.027074128  1889  Q FWFS [jbd2/dm-4-8]
        259,0   11       21     5.027077378  1889  G FWFS [jbd2/dm-4-8]
        259,0   11       22     5.027084885   612  D  FN [kworker/11:1H]
        259,0   11       23     5.027852186     0  C  FN 0 [0]
        259,0   11       24     5.027859859     0  C WFS 575480512 [0]


        NOTE: The flow include nesting of barriers
	+---- barrier depth
	V
	1>> 253,89  91     1049     0.059881318 19690  A FWS 0 + 0 <- (253,456) 0       ; new, add to staged
            253,89  91     1050     0.059881500 19690  Q FWS [mdX_raid10]A		; check A exists on io
            253,89  91     1051     0.059881728 19690  G FWS [mdX_raid10]		; check A,Q exists on io	staged -> moves to main_io
            253,89  91     1052     0.059883260  2964  D  FN [kworker/91:1H]		; check A,Q,G exists on io                      on main_io only
                    
        2>> 253,89  91     1063     0.060053156 19690  A FWS 0 + 0 <- (253,456) 0	; ditto
            253,89  91     1064     0.060053335 19690  Q FWS [mdX_raid10]
            253,89  91     1065     0.060053607 19690  G FWS [mdX_raid10]
                    
        3>> 253,89  91     1066     0.060064324 19690  A FWS 0 + 0 <- (253,456) 0	; ditto
            253,89  91     1067     0.060074701 19690  Q FWS [mdX_raid10]
            253,89  91     1068     0.060075009 19690  G FWS [mdX_raid10]
                    
        4>> 253,89  91     1069     0.060085912 19690  A FWS 0 + 0 <- (253,456) 0	; ditto
            253,89  91     1070     0.060086092 19690  Q FWS [mdX_raid10]
            253,89  91     1071     0.060086299 19690  G FWS [mdX_raid10]
                    
        1>> 253,89  91     1072     0.060163679     0  C  FN 0 [0]			; check A,Q,G,D exists on io on main_io only, move to post_io, treat
	                                                                                ; A-D, move to postio, expect 2nd complete
        1>> 253,89  91     1073     0.060163883     0  C  WS 0 [0]			; check A,Q,G,D,C exists on io **OR** just A,Q,G
											; check postio first for A-C and this is 2nd complete to finish it off.
											; otherwise check staged queue and move directly to postio queue/done
                    
        2>> 253,89  91     1074     0.060166278  2964  D  FN [kworker/91:1H]		; only check main_io queue
                    
        2>> 253,89  91     1081     0.060416621     0  C  FN 0 [0]			; only check main_io queue, moved to postio, expect 2nd complete
        2>> 253,89  91     1082     0.060416774     0  C  WS 0 [0]			;      check postio  queue, found = done, not found check stage queue
	                                                                                ;      and move directly to postio/done.
        3>> 253,89  91     1083     0.060417481     0  C  WS 0 [0]		        @@@ this barrier had no data movement writes, do no D,C,C just A,Q,G,C vs
        4>> 253,89  91     1084     0.060417821     0  C  WS 0 [0]		        @@@ others which were A,Q,G,D,C,C (1&2).  Both 3&4 barriers seemed to 
	                                                                                @@@ just failed and completed with the just one 'C' event seen.
    */

#undef _isRemap
#undef _isIOCMD
#undef _isProcName
#undef __kwio_assert
#undef __kwio_flags
}


static int _get_event_action( char **pptr, typ_event *this )
{
char *bgn;
char *ptr = *pptr;

    bgn             =  ptr;
    this->prmact    = *ptr;
    this->evtact[0] = *ptr++;             this->evtact[1] = 0;


    /* "SPECIAL" case, we're seeing UT events where this seems to force the plug count to 1 and */
    /* UT event is immediately followed by a U which decrements it the last of the way.  Convert*/
    /* a UT event to a T event. ... And complain if prior to this its just a 'T' event.         */
    /* A 'T' event will push plug count down to 1.                                              */
    if (this->evtact[0] == 'T')
    {
        fprintf( outf, " %%E[%05d]-Encoutering a 'T' event, only expecting 'UT' events?! Internal logic error.\n", __LINE__ );
        fprintf( outf, " %%I[%05d]-Input '%s'\n", __LINE__, state.inpline );
    }


    /* Cover the 'UT' event action, most are single characters only except this one */
    if ((*ptr == 'T') && (this->prmact == 'U')) 
    { 
        this->prmact    = 'T';			/* treat this 'UT' as a 'T' */
        this->evtact[1] = *ptr++;		/* treat this 'UT' as a 'T' */
        this->evtact[2] = 0;
    }

    
    if (*ptr != ' ')
    {
	/* Encountered a action string that is more than 1 char and not UT  */
	/* which until now was the only known exception!  Back up and save  */
	/* the whole action string.  Verify its not bigger than MAXLEN      */
	/* ACTION, which *might* happen on corrupt events in the input file */
        ptr = bgn;
        get_token(&ptr,this->evtact);
        if (strlen(this->evtact) >= MAXLEN_ACTION)
	{	
	    /* we're exiting, but the other thing we can do is set the prmact to '@' and add this event to the exceptions list */
	    fprintf( outf, " %%E[%05d]-Encountering a action longer than %d characters: '%s', skip.\n", __LINE__, MAXLEN_ACTION, this->evtact );
	     printf(        "%%E[%05d]-Encountering a action longer than %d characters: '%s', skip.\n", __LINE__, MAXLEN_ACTION, this->evtact );
	    this->evtact[MAXLEN_ACTION];
	    this->evtflags |= (EVTFLG_BADFIELD | EVTFLG_EXCEPTION); /* multi-char event type and too long for field */
	    sprintf( this->reason, "[%05d] event action string > allowed size", __LINE__ );
        }

	/* Ok, verify that this is not some other compound event type we don't know about yet      */
	 printf(        "%%E[%05d]-Compound event action '%s' that is not a 'UT' event. add to exceptions.\n", __LINE__, this->evtact );
	fprintf( outf, " %%E[%05d]-Compound event action '%s' that is not a 'UT' event. add to exceptions.\n", __LINE__, this->evtact );
	fprintf( outf, " %%I[%05d]-Input.%08d '%s'\n", __LINE__, state.line, state.inpline );
	this->evtflags |= (EVTFLG_UNKFIELD | EVTFLG_EXCEPTION);  /* multi-char event type and its not 'UT' */
	sprintf( this->reason, "[%05d] compound event action detected and not 'UT'", __LINE__ );
    }
    xprintf( "  xDBG: act %c:'%s' '%s'\n", this->prmact, this->evtact, ptr );

    /* Ok, now ready to move to next field: event type (R|W|...) 					*/
    skip_whitespace(&ptr);		
    *pptr = ptr;
    return(0);
}


static int _get_event_iotype( char **pptr, typ_event *this )
{
char *rwbs;
char token[MAXBUF];
char *ptr = *pptr;
unsigned int iomask;


    strcpy(this->evttyp, get_token(&ptr,token)); skip_whitespace(&ptr); xprintf( "  xDBG: typ %s '%s'\n", this->evttyp, ptr );

    /* IO "type" RWDBS (and N which isn't in the man page!) */
    /* R - Read      D - Discard          B - Barrier
     * W - Write     S - Synchronous      N - neither read or write (ioctl? no data xfer?)[1]
     * M - Metadata  F - Flush or Fua (positional dependent : FMS is flush/meta/sync e.g.)
     * A - readAhead     Flush if first/before, FUA if last/after
     *
     * [1] the binary action flags set within the kernel have a 'W' and 'R' flag, the
     *     blkparse checks the 'W' flag, and then ->bytes != 0 then 'R' is set.
     */
    /* @@@TBD: should verify that the string does not exceed the allowed length 			*/
    /* @@@TBD: should verify that its format is valid/as expected and not weird or anything             */

    /* setup the primary type of this event, typically primary action is just the single 1st char	*/
    /* in evttyp[], typical R|W ... but that can be buried inside of the longer evttyp string, so walk  */
    /* evttyp[] and capture the primary type.                                                           */
    iomask = 0;
    rwbs = &this->evttyp[0];        /* Can be FWS, that is 'F' flag may come first, if so skip it that leading 'F' character */
         if (*rwbs == 'F'){      iomask|= IOMASK_FLUSH; rwbs++;}
         if (*rwbs == 'R') this->prmtyp = IOTYP_READ;
    else if (*rwbs == 'W') this->prmtyp = IOTYP_WRITE;
    else if (*rwbs == 'M') this->prmtyp = IOTYP_META;
    else if (*rwbs == 'D') this->prmtyp = IOTYP_DISCARD;
    else if (*rwbs == 'B') this->prmtyp = IOTYP_BARRIER;
    else if (*rwbs == 'N') this->prmtyp = IOTYP_NONE;		/* e.g. "P   N [xfsaild/sdb]"					*/
    else
    {
	this->prmtyp = IOTYP_OTHER;
        this->evtflags |= (EVTFLG_BADFIELD | EVTFLG_EXCEPTION);
	 printf(       " %%E[%05d]-Compound event type (RWBS) '%s' unparsed for prime type, add to exceptions.\n", __LINE__, this->evttyp );
	fprintf( outf, " %%E[%05d]-Compound event type (RWBS) '%s' unparsed for prime type, add to exceptions.\n", __LINE__, this->evttyp );
	fprintf( outf, " %%I[%05d]-Input.%08d '%s'\n", __LINE__, state.line, state.inpline );
        sprintf( this->reason, "[%05d]: compound event type does not include recognized primary type", __LINE__ );
    }

    iomask = 0;
    rwbs = &this->evttyp[0];        /* Can be FWS, that is 'F' flag may come first, if so skip it that leading 'F' character */
    if (*rwbs == 'F') { iomask |= IOMASK_FLUSH; rwbs++; }
    while (*rwbs != 0)
    {
             if (*rwbs == 'R') { _assert( ((iomask & IOMASK_MAINTYP) == 0)); _assert( (iomask & IOMASK_READ     ) == 0); iomask |= IOMASK_READ;       }
	else if (*rwbs == 'W') { _assert( ((iomask & IOMASK_MAINTYP) == 0)); _assert( (iomask & IOMASK_WRITE    ) == 0); iomask |= IOMASK_WRITE;      }
	else if (*rwbs == 'D') { _assert( ((iomask & IOMASK_MAINTYP) == 0)); _assert( (iomask & IOMASK_DISCARD  ) == 0); iomask |= IOMASK_DISCARD;    }
	else if (*rwbs == 'N') { _assert( ((iomask & IOMASK_MAINTYP) == 0)); _assert( (iomask & IOMASK_NONE     ) == 0); iomask |= IOMASK_NONE;       }
	else if (*rwbs == 'B') { _assert( ((iomask & IOMASK_MAINTYP) == 0)); _assert( (iomask & IOMASK_BARRIER  ) == 0); iomask |= IOMASK_BARRIER;    }
	else if (*rwbs == 'S') {                                             _assert( (iomask & IOMASK_SYNC     ) == 0); iomask |= IOMASK_SYNC;       }
	else if (*rwbs == 'F') {                                             _assert( (iomask & IOMASK_FUA      ) == 0); iomask |= IOMASK_FUA;        }
	else if (*rwbs == 'M') {                                             _assert( (iomask & IOMASK_META     ) == 0); iomask |= IOMASK_META;       }
	else if (*rwbs == 'A') {                                             _assert( (iomask & IOMASK_READAHEAD) == 0); iomask |= IOMASK_READAHEAD;  }
        else
        {
		iomask |= IOMASK_UNKNOWN;
		printf(        " %%W[%05d]-event rwbs field '%s' contains unknown '%c' character?!\n", __LINE__, this->evttyp, *rwbs );
		fprintf( outf, " %%W[%05d]-event rwbs field '%s' contains unknown '%c' character?!\n", __LINE__, this->evttyp, *rwbs );
                fprintf( outf, " %%I[%05d]-Input.%08d '%s'\n", __LINE__, state.line, state.inpline );
        }
	rwbs++;
    }
    this->iomask = iomask;

    *pptr = ptr;
    return(0);
}



static int _get_event_procname( char **pptr, typ_event *this )
{
char *ptr = *pptr;
char *dst = &this->procname[0];
int   len = 0;

    _assert( (*ptr == '[') );
    while ((*ptr != 0) && (*ptr != ']'))
    {
        *dst++ = *ptr++;
	 len++;
    }
    if (*ptr == ']')
    {
        *dst++ = *ptr++;
	 len++;
    }
    *dst   = 0;
    len++;
    xprintf( "  xDBG: nam %s '%s'\n", this->procname, ptr );

    this->evtflags |= EVTFLG_VALID_PROCNAME;
    /* check to see if the process name is 'null' and if so, try looking it up */
    /* from companion top data (if available) that was pre-processed as part   */
    /* of setup at start of program...                                         */
    /* @@@TBD - parse top and associate pid with process name... keep a list   */

    skip_whitespace(&ptr);
    *pptr = ptr;
    return(len);
}
static int _get_event_iocommand( char **pptr, typ_event *this )
{
char *ptr = *pptr;
char *dst = this->extras;
int   len = 0;

    printf( "DBG[%05d]: OLDSTYPE w/iocommand '%s'!\n", __LINE__, ptr );
    _assert( (*ptr == '(') );
    while ((*ptr != 0) && (*ptr != ')'))
    {
        *dst++ = *ptr++;
         len++;
    }
    if (*ptr == ')')
    {
	*dst++ = *ptr++;
	 len++;
    }
    *dst   = 0;
     len++;

    this->evtflags |= (EVTFLG_NONIOSTYLE | EVTFLG_SCSICOMMAND | EVTFLG_EXCEPTION);

    skip_whitespace(&ptr);
    *pptr = ptr;
    return(len);
}

static int _get_event_garbage( char **pptr, typ_event *this )
{
char  iobuffer[1024];
char *ptr = *pptr;
char *dst = &iobuffer[0];
int   len = 0;

    if (this->prmact == 'm') 
    {
        /* Not trailing garbage, but just the 'm'essage text string         */
        printf( " %%I[%05d]-trailing 'm'essage text '%s' detected.\n", __LINE__, ptr );
	strcpy(this->extras, ptr );
	len = strlen(this->extras);
	while (*ptr != 0); ptr++;
	*pptr = ptr;
	return(0);
    }

    printf( " %%E[%05d]-trailing garbage detected, '%s' unparsed!\n", __LINE__, ptr );
    while (*ptr != 0)
    {
        *dst++ = *ptr++;
         len++;
    }
    *dst   = 0;
     len++;

    /* Nominally the typ_event includes no storage for trailing
     * garbage, so allocate what is needed.
     */
    len = (len+15) & ~0xF; /* pad out to 16 byte boundary */
    dst = malloc(len);
    bzero(dst,len);
    strcpy(dst, iobuffer);
    this->garbage = dst;

    /* What?! mark as exception and set onto exceptions list */
    printf( "%%E[%05d]: unrecognized event format, internal logic error?\n", __LINE__ );
    printf( "DBG[%05d]: %s() - ptr='%s' UNKFORMAT.\n", __LINE__, __FUNCTION__, ptr );
    sprintf( this->reason, "[%05d]: unrecognized event format, internal logic error?", __LINE__ );
    this->evtflags |= EVTFLG_UNKFORMAT | EVTFLG_DISCARDED;  /* has unparsed trailing garbage */
    this->evtflags |= EVTFLG_EXCEPTION;

    skip_whitespace(&ptr);
    *pptr = ptr;
    return(len);
}

static int _get_event_remapinfo(char **pptr, typ_event *this )
{
char *ptr = *pptr;

    /* This is a remAp event, it won't have procname and that	*/
    /* is ok.  Parse the from major,minor and blkmap from sector*/
    /* "<- (maj,min) sector"					*/
    _assert( (*ptr == '<') ); ptr++;
    _assert( (*ptr == '-') ); ptr++;
    _assert( (*ptr == ' ') ); ptr++;
    skip_whitespace(&ptr);
     
    _assert( (*ptr == '(') ); ptr++;
    _assert( (isdigit(*ptr)) );
    this->from_major = getdecnum(&ptr);

    _assert( (*ptr == ',') ); ptr++;
    skip_whitespace(&ptr);
    _assert( (isdigit(*ptr)) );
    this->from_minor = getdecnum(&ptr);        
    skip_whitespace(&ptr);
    _assert( (*ptr == ')') ); ptr++;
    skip_whitespace(&ptr);

    _assert( (isdigit(*ptr)) );
    this->from_sector = getldecnum(&ptr);
    skip_whitespace(&ptr);

    this->evtflags |= EVTFLG_VALID_FROMSECT;	/* short hand for remap present */

    skip_whitespace(&ptr);
    *pptr = ptr;
    return(0);
}
static int _get_event_sector(char **pptr, typ_event *this )
{
char *ptr = *pptr;

    if (isdigit(*ptr))
    {
        xprintf( "  xDBG:         '%s' <- sector\n", ptr );

        this->sector    = getdecnum(&ptr);
        this->evtflags |= EVTFLG_VALID_SECTOR;
	this->evtflags |= EVTFLG_LOCFORMAT;  	/* we have at least a sector number...	*/
        _assert( (*ptr == ' ' ));
        skip_whitespace(&ptr);

	xprintf( "  xDBG: sec %ld.%d '%s'\n", this->sector, (this->evtflags & EVTFLG_VALID_SECTOR)?1:0, *pptr );
    }
    /* else no digits/sector present, return */

    *pptr = ptr;
    return(this->sector);
}
static int _get_event_length(char **pptr, typ_event *this )
{
char *ptr = *pptr;

    /* Should be a '+' or '/' present after a valid sector number and     */
    /* before the length is specified (if any)                            */
    if (  (*ptr == '+') || ((this->prmact == 'X') && (*ptr == '/')))
    {
        ptr++;
        skip_whitespace(&ptr);

        xprintf( "  xDBG:         '%s' <- length\n", ptr );

        _assert( (isdigit(*ptr)) );
        this->length    = getdecnum(&ptr);
        this->evtflags |= EVTFLG_VALID_LENGTH;
	this->evtflags |= EVTFLG_LOCFORMAT;          /* we must have correct sector+length (location) data format to get here */
        _assert( (*ptr == ' ' ));
        skip_whitespace(&ptr);

        xprintf( "  xDBG: len %d.%d '%s'\n", this->length, (this->evtflags & EVTFLG_VALID_SIZE)?1:0, ptr );
    }
    /* else no digits/length present, return */

    *pptr = ptr;
    return(this->length);
}


typ_event *clone_event(typ_event *this)
{
typ_event *clone;

    if ((clone = _malloc_event(sizeof(typ_event))) == NULL)
    {
        printf( "%%F[%05d]-malloc of typ_event(%d) failed.  Total allocated memory %ld, total events allocated %d:%ld\n", __LINE__,
	    sizeof(typ_event), state.allocated_memory_total, state.allocated_events, state.allocated_memory_events );
 	RUNTIME_FAULT(NULL,(typ_event *),"malloc failed, analyze with gprof recommended",CTL_FAULT_FORCE);
    }
    bzero(clone,sizeof(typ_event));
    state.allocated_events++;
    state.allocated_memory_events += sizeof(typ_event);
    state.allocated_memory_total  += sizeof(typ_event);

    bcopy(this,clone,sizeof(typ_event));
    clone->next = (typ_event *)NULL;
    _return(clone);
}



/* SECTION: FUNCTION BLOCK ; CONFIG */
/* ================================================================================================================= */
/* === CONFIG ====================================================================================================== */
/* ================================================================================================================= */

int parse_args(int argc, char *argv[])
{
int match = 0;
int ndx;
int argndx = 1;
int strndx = 0;
int flg_inpf = 0;
int flg_outf = 0;
int flg_bckf = 0;
int flg_addf = 0;
int flg_excf = 0;
char *ptr, *src, *dst;

    if (argc < 2)
    {
	printf( "%%E-missing input filename\n");
        useage();
        EXIT(0);
    }

#   ifdef PARSE
    /* 
     * blktrace_parse is deprecated version but some still using it, force
     * switch to newer blktrace_merge version.  blktrace_parse was only held
     * available in case of issues, but blktrace_parse has multiple serious 
     * issues including not updated for later kernel versions and its quirks.
     */
    printf( "\n\nWARNING: blktrace_parse is now deprecated in favor of blktrace_merge\n");
    printf(     "         which includes additional updates and reflects the nature\n");
    printf(     "         of the program -- namely merging of multiple individual events\n");
    printf(     "         into a single io context. Continuing with blktrace_merge shortly.\n");
    printf(     " \n");
    printf(     "         A version of blktrace_parse is available as blktrace_parse.deprecated\n");
    printf(     "         if needed, but be warned it has the old parse architecture and has not\n");
    printf(     "         been in active development since 2020.\n");
    printf(     "============================================================================\n");
    sleep(5);
#   endif

    strcpy(devicename,  "sda"		      );
    strcpy(inpfilename, "blktrace.parse.txt"  );
    strcpy(outfilename, "merged.txt"          );
    strcpy(excfilename, "merged.exceptions"   );
    strcpy(addfilename, "merged.annotated"    );
    strcpy(bckfilename, "merged.buckets"      );
    strcpy(evtfilename, "merged.events.bin"   );
    strcpy(binfilename, "merged.bucket.bin"   );
    strcpy(hotfilename, "merged.hotlba.bin"   );

    logIprintf( "command: %s {%s}\n", argv[0], VERSION );
    while (argndx<argc)
    {
        dprintf( "argndx=%d/%d, %s\n", argndx, argc, argv[argndx] );
        if (argv[argndx][0] == '-')
        {
            ptr = &argv[argndx][1];
            while (*ptr != 0)
            {
                switch (*ptr)
                {
                    case 'h': ptr++; useage(); EXIT(0);
		    case 'a': ptr++; conf_no_annotation ^= 1; break; /* on/off flag ; turn off annotation file writes                 */
		    case 'b': ptr++; flag_processbad ^= 1;    break; /* on/off flag ; process file that would typ be skipped (no 'C') */
                    case 'c': ptr++; flag_showconfig ^= 1;    break; /* on/off flag ; show configuration details                      */
                    case 'd': ptr++; flag_debug++  ;          break; /* counter     ; no system commands                              */ /* debug (internal/support) */
                    case 'q': ptr++; flag_quiet++  ;          break; /* counter     ; turn off classes of information to the log file */
		    case 'r': ptr++; flag_negrequeue ^= 1;    break; /* on/off flag ; do not reset dispatch time on requeue           */
		    case 't': ptr++; flag_tracing++;          break; /* counter     ; tprintf enable                                  */ /* debug (internal/support) */
	            case 'f': ptr++; flag_function   ^= 1;    break; /* on/off flag ; TRACE macros                                    */
		    case 'X': ptr++; flag_xsplits++;	      break; /* X splits    : control matching behavior logic                 */
		    case 'u': ptr++; flag_unplugs    ^= 1;    break; /* Plug/Unplug : turn off %I messages associated with P/U/UT     */
                    case 'v': ptr++; flag_verbose++;          break; /* counter     ; turn up verbose-ness		              */
                    case 'p': ptr++; flag_check_inprogress++; break; /* counter     ; turn on debug routine for inprogress counter    */ /* debug (internal/support) */
                    case 'M': ptr++; flag_remap_bug  ^= 1;    break; /* remap bug   ; turn on checking for remap bug, see FN.102      */
		    case 'S': ptr++; flag_shortform  ^= 1;    break; /* short form  ; turn off trailing columns to reduce width       */
                    case 'A': ptr++; flag_alignchk=1; 		     /* value       ; -Annn check for sector alignment                */
			      conf_alignquanta=atol(ptr);
			      if (conf_alignquanta == 0L) conf_alignquanta = 8;    /* reset to 4k */
			      logIprintf( "DBG: align quanta=%d\n", conf_alignquanta );
			      while (*ptr != 0) ptr++;
			      break;
		    case 'D': ptr++; flag_discards^=1;	     	     /* on/off flag ; turn off discard processing (temp:workaround)   */
			      conf_orphan_event_policy = 2;	     /* make orphan events silent				      */
							     break;  /* on/off flag ; turn off discard processing (temp:workaround)   */
		    case 'E': ptr++; flag_estimates++;	     break;
                    case 'V': printf( "%%I-version='%s'\n", VERSION); EXIT(0);
                }
            }
        }
        else
        {
              switch (strndx)
              {
                case 0: strcpy( inpfilename, argv[argndx] ); flg_inpf= 1; break;
                case 1: strcpy( outfilename, argv[argndx] ); flg_outf= 1; break;
	        case 2: strcpy( bckfilename, argv[argndx] ); flg_bckf= 1; break;
	        case 3: strcpy( addfilename, argv[argndx] ); flg_addf= 1; break;
	        case 4: strcpy( excfilename, argv[argndx] ); flg_excf= 1; break;
                default: logEprintf( "%%E-invalid argument '%s' encountered\n", argv[argndx] );
                         useage();
                         EXIT(0);
              }
              strndx++;
        }
        argndx++;
    }
    if (flag_quiet > 3) flag_quiet=3;
    if (flag_xsplits != 0) 
    {
        if (flag_xsplits >= 2) conf_xsplits = CFG_XSPLITS_PRESENT; 
	else                   conf_xsplits = CFG_XSPLITS_MISSING; 
    }

    if (flg_inpf != 0)  
    {
	/* adjust filenames, if new one not specified */
	src = inpfilename;
	dst = devicename;
	while ((*src != 0) && (*src != '.')) *dst++ = *src++;
	*dst = 0;
	if (flg_outf == 0) sprintf( outfilename, "%s.blktrace.merged.txt",        devicename );
        if (flg_excf == 0) sprintf( excfilename, "%s.blktrace.merged.exceptions", devicename );
	if (flg_addf == 0) sprintf( addfilename, "%s.blktrace.merged.annotated",  devicename );
	if (flg_bckf == 0) sprintf( bckfilename, "%s.blktrace.merged.buckets",    devicename );
			   sprintf( evtfilename, "%s.blktrace.merged.events.bin", devicename );
			   sprintf( binfilename, "%s.blktrace.merged.bucket.bin", devicename );
			   sprintf( hotfilename, "%s.blktrace.merged.hotlba.bin", devicename );

	if (strncmp(devicename, "nvme", 4) == 0)
	{
	    /* check to see if this is a partition that was traced */
	    special_nvme_device    = 1;
	    special_nvme_partition = 0;
	    special_nvme_main_major= 0;
            special_nvme_main_minor= 0;
            special_nvme_part_major= 0;
            special_nvme_part_minor= 0;
	    src = &devicename[strlen(devicename)-1];
	    while ((src != devicename) && (*src != 'p') && (isdigit(*src))) --src;
	    if (*src == 'p') special_nvme_partition = 1;
	    logIprintf( "%%I[%05d]-nvme partition capture detected (%s)\n", __LINE__, devicename );
	}
    }

#   ifdef SIGLIB
    siglib_siginit();
#   endif

    bzero(&remaps[0],sizeof(remaps));

    return(0);
}
int show_configuration(FILE *filf, int flg )
{
#define support if (flag_debug != 0) fprintf

    if (flg == 0) return(0);

    fprintf( filf, "#\n");
    fprintf( filf, "#@@@ shortform=%d\n", flag_shortform );
    fprintf( filf, "# CONFIG   :-command line options---------------------------------------------------------------------------------------------\n");
    support( filf, "# CONFIG   : flag_debug              %11d   [-d]    {debug: dprintf enable(s)                                       %6s}\n", flag_debug,            " " );
    fprintf( filf, "# CONFIG   : flag_verbose            %11d   [-v]    {enable additional verbose output                               %6s}\n", flag_verbose,          " " );
    fprintf( filf, "# CONFIG   : flag_quiet              %11d   [-q]    {quiet down 'standard' output, remove %I, %W, with add'l -q     %6s}\n", flag_quiet ,           " " );
    fprintf( filf, "# CONFIG   : flag_unplugs            %11d   [-u]    {turn off logging of unplug %I events                           %6s}\n", flag_unplugs,          " " );
    support( filf, "# CONFIG   : flag_tracing            %11d   [-t]    {debug: tprintf enable                                          %6s}\n", flag_tracing,          " " );
    support( filf, "# CONFIG   : flag_function           %11d   [-f]    {debug: TRACE   enable                                          %6s}\n", flag_function,         " " );
    support( filf, "# CONFIG   : flag_check_inprogress   %11d   [-p]    {debug: validate mainio_list vs in-progress counter             %6s}\n", flag_check_inprogress, " " );
    fprintf( filf, "# CONFIG   : flag_negrequeue         %11d   [-r]    {do not reset dispatch time at requeue time                     %6s}\n", flag_negrequeue,       " " );
    fprintf( filf, "# CONFIG   : flag_processbad         %11d   [-b]    {processe 'bad' files - files w/o 'C' events are typ. skipped   %6s}\n", flag_processbad,       " " );
    fprintf( filf, "# CONFIG   : flag_showconfig         %11d   [-s]    {show config (this) output                                      %6s}\n", flag_showconfig,       " " );
    fprintf( filf, "# CONFIG   : flag_alignchk           %11d   [-Annn] {perform alignment check against starting sector [1]            %6s}\n", flag_alignchk,         " " );
    fprintf( filf, "# CONFIG   : alignquanta             %11d   [ ]     {[1] value provided in -A option, in sectors                    %6s}\n", conf_alignquanta,      " " );

    fprintf( filf, "# CONFIG   :-blktrace.conf options--------------------------------------------------------------------------------------------\n");
    fprintf( filf, "# CONFIG   : disk_count_threshold       %8d%9s  {heat map: print out disk  bucket only if >= this numbr io present    }\n", conf_disk_count_threshold,       " " );
    fprintf( filf, "# CONFIG   : disk_group_count_threshold %8d%9s  {heat map: print out group bucket only if >= this numbr io present    }\n", conf_disk_group_count_threshold, " " );
    fprintf( filf, "# CONFIG   : disk_stripe_multiplier     %8d%9s  {heat map: numbr of 128Kib 'stripes' to include in a bucket           }\n", conf_disk_stripe_multiplier,     " " );
    fprintf( filf, "# CONFIG   : include_d2d                %8d%9s  {head map: include D2D time as separate column in ouput for requeues  }\n", conf_include_d2d,                " " );
    fprintf( filf, "# CONFIG   : noreset_on_requeue         %8d%9s  {see -r, moves D2D time from Q2D (default) to D2C time                }\n", conf_noreset_on_requeue,         " " );
    fprintf( filf, "# CONFIG   : no_annotation              %8d%9s  {see -a, stops output to annotation/trace file                        }\n", conf_no_annotation,              " " );


    fprintf( filf, "# CONFIG   :-filenames--------------------------------------------------------------------------------------------------------\n");
    fprintf( filf, "# CONFIG   : input filename        '%s'\n", inpfilename );
    fprintf( filf, "# CONFIG   : output filename       '%s'\n", outfilename );
    fprintf( filf, "# CONFIG   : except filename       '%s'\n", excfilename );
    fprintf( filf, "# CONFIG   : bucket filename       '%s'\n", bckfilename );
    fprintf( filf, "# CONFIG   : heat map data         '<name>.blktrace.merged.hotlba.bin'\n" );
    fprintf( filf, "# CONFIG   : head map report       '<group>.blktrace.merged.group.out'\n" );
    fprintf( filf, "#\n");
#undef support
}

int useage()
{
	printf( "blktrace_parse {options} blktrace-output-file\n");
        printf( "\n");
        printf( "   -h : output this information and exit.\n");
        printf( "   -V : output program version info and exit.\n");
        printf( "\n");
        printf( "   -q : turn off classes of information to the log file.\n");
        printf( "        -qq should turn off all logged output.\n");
        printf( "   -t : turn on function tracing of some key functions within the program.\n");
        printf( "   -v : turn up verbosity, more -vvv, more verbose-ness.\n");
        printf( "\n");
	printf( "-Annn : turn on alignment quanta checking, all io must be to LBA aligned\n");
	printf( "        to modulo nnn value\n");
        printf( "\n");
        printf( "-R    : inhibit 'R'equeue events from resetting the dispatch time, off by default\n");
        printf( "        when set, storage is charged (D2C) from the first dispatch to completion vs\n");
        printf( "        default calculation of last dispatch to completion.\n");
        printf( "\n");

   return(0);
}


/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
FILE *parse_setup()
{
FILE *inpf;
int   n;

    parse_config(homedirloc);           /* general account (user preference) settings                */
    parse_config(thisdirloc);           /* specific settings for the blktrace data in this directory */
    bin_init();
    heatmap_disk_access_init();         /* track disk accesses across whole disk, detect hotspots    */
    bzero(&imb_active_cache,sizeof(imb_active_cache));
    state_init();
    stats_samp_init();
    stats_summ_init();

    bzero(&req_nocontext,sizeof(req_nocontext));
    bzero(&req_nonio,    sizeof(req_nonio    ));

    samp.boundary = 1.000;		/* default: 1 second mark				     */

    setup_evtformat_io_table();

    /* Ok, final tweaks - if -R or noreset_on_requeue set, make sure the flag_negrequeue is set...   */
    /* unless the include_d2d config is set, then make sure the flag_negrequeue is cleared.  The     */
    /* noreset_on_reque will only be referenced here and everywhere else the flag_negrequeue used to */
    /* control processing of the time data associated with requeues.                                 */
    if (conf_noreset_on_requeue != 0)   flag_negrequeue = 1;
    if (conf_include_d2d        != 0) { flag_negrequeue = 0; chk_use_include_d2d++; }

    show_configuration(stdout, flag_showconfig);


    /* --------------------------------------------------------------------------------------------- */

    /* Peek inside file to see if major number might reference nvme devices. */
    /* set state.device_nvme flag if either 245 or 259 present, but NOTE!    */
    /* nvme does not have a reserved/assigned major number so just asks for  */
    /* next available/dynamic major number which will *mostly* be 245 or 259 */
    /* will need .conf configurable to ignore or force this option, but for  */
    /* now attempt to do this automatically.                                 */
    if ((inpf = fopen(inpfilename, "r" )) == NULL)
    {
	printf( "%%E[%05d]-cannot open '%s' file for read access\n", __LINE__, inpfilename );
	EXIT(1);
    }
    for (n=0; n < 20; n++)
    { int major; char inpline[MAXBUF];
	if (fgets(inpline,MAXBUF,inpf) <= 0) break;
	if (inpline[0] == '#') continue;
	major = read_major(inpline);
	if ((major == 245) || (major == 259)) state.device_nvme = 1;
    }
    fclose(inpf);

    /* Ok, open up all the (global) files the program will be using	    */
    /* inpf = main input,  events list from the blkparse output file	    */
    /* outf = main output, merged events into 1 line per io 		    */
    /* addf = annotated individual event list, mostly for debug/visualizing */
    /* bckf = bucket/heat map file                                          */
    state.bgn_seconds=(unsigned long)time(NULL);

    state.totl_filebytes = _get_filesize(inpfilename);
    if ((state.diff_filebytes = state.totl_filebytes / 1000) < NEXT_BYTES_QUANTA)
	 state.diff_filebytes = NEXT_BYTES_QUANTA;
    state.next_filebytes = NEXT_BYTES_QUANTA;
    state.read_filebytes = 0L;
    state.next_line      = NEXT_LINES_QUANTA;
    state.est_lines      = (long) (((double)state.totl_filebytes) / EST_LINE_AVGSIZE);
    state.est_seconds    = (long)((((double)state.est_lines     ) / EST_TIME_PERQUANTA) * EST_LINE_AVGTIME );
    printf( "%%I[%05d]-estimated total events: %12ld\n", __LINE__, state.est_lines );
    printf( "%%I[%05d]-estimated total time  :  %s\n", __LINE__, _cvtseconds(state.est_seconds) );
    if (flag_estimates != 0) { printf( "\n\n"); exit(0); }

    inpf = fopen(inpfilename, "r" );
    outf = fopen(outfilename, "w" );
    addf = fopen(addfilename, "w" );
    bckf = fopen(bckfilename, "w" );
    if (inpf == NULL) { logFprintf( "%%F-cannot open file '%s' for reading\n", inpfilename ); EXIT(1); }
    if (outf == NULL) { logFprintf( "%%F-cannot open file '%s' for writing\n", outfilename ); EXIT(1); }
    if (addf == NULL) { logFprintf( "%%F-cannot open file '%s' for writing\n", addfilename ); EXIT(1); }
    if (bckf == NULL) { logFprintf( "%%F-cannot open file '%s' for writing\n", bckfilename ); EXIT(1); }
    if (conf_exceptions_inhibit == 0)
    {
	 excf = fopen(excfilename, "w" );
         if (excf == NULL) { logFprintf( "%%F-cannot open file '%s' for writing\n", excfilename ); EXIT(1); }
    }
    else
	excf = NULL;

    /* output headers on outf (main output file) and addf (annotated file) */
    fprintf( outf, "#Input file: %s\n", inpfilename );
	
    if (conf_no_annotation == 0)
    {
    fprintf( addf, "# Input file : %s\n", inpfilename );
    fprintf( addf, "# KEY        :\n");
    fprintf( addf, "# column 1   : ' ' event was processed\n");
    fprintf( addf, "#              '>' event was skipped/not processed\n");
    fprintf( addf, "# Plug field : '@' Dispatch event, but isPlugged > 0?!\n");
    fprintf( addf, "#            : ' ' nominal\n");
    fprintf( addf, "#            : '$' IS_ORPHAN_IO     flag is set on this io\n");
    fprintf( addf, "#            : '&' IS_CONFLICTED_IO flag is set on this io\n");
    fprintf( addf, "#            : '#' IS_OVERLAPPED_IO flag is set on this io\n");
    fprintf( addf, "#\n");

    fprintf( addf, 
    "#From Maj,Mn CPU    SeqNo     Seconds        PID  Evt Typ Sector   +Len Description                      ; Plug   QTicket#   DTicket#   CTicket#  Stg Prg    R    W  Dev    R    W Bias\n");
    fprintf( addf, 
    "#---- ------ --- -------- --------------- --------|--|---|---------+--- ---------------------------------; ------ -------- ---------- ----------|----|---- ---- ----|---- ---- ---- ----\n");
    }

    /* Setup state before looping through bklparse event stream		    */
    samp.inflight = 0;
    summ.inflight = 0;
    state.flag_annotated = 1;

    return(inpf);
}

/*
 * Function   : setup_evtformat_io_table()
 * Description: setup evtformat_io[] table, set each format type that includes sector+length [procname]
 *              in the event format to value of '1'.  So evtformat_io[ event-type ] indicates directly
 *              whether event type has the standard io type format or not.  This table reduces a long
 *              chain of ifs to just a table lookup.
 * Args       : none
 * Input      : none
 * Output     : evtformat_io[] table setup
 */
int setup_evtformat_io_table()
{
    bzero(&evtformat_io[0], sizeof(evtformat_io));
    evtformat_io['A'] = 1;
    evtformat_io['Q'] = 1;
    evtformat_io['M'] = 1;
    evtformat_io['X'] = 1;
    evtformat_io['F'] = 1;
    evtformat_io['S'] = 1;              /*  8,112 12   100113   749.295660896 13855  S   W 52429568 + 256 [(null)] */
    evtformat_io['G'] = 1;
    evtformat_io['I'] = 1;
    evtformat_io['D'] = 1;
    evtformat_io['R'] = 1;              /* 65,16  15   152178   810.380068545 13855  R   W 41281792 + 512 [0]      */
    evtformat_io['C'] = 1;
    
    evtformat_io['N'] = 1;
    return(0);
}

int state_init()
{

    bzero(&state,sizeof(typ_state));

    state.serialnumb = 1;

    state.line       = 0;
    state.time       = 0.0;

    state.isPlugged  = -1;

    state.QFirstTime = 0.00;		/* seconds							*/
    state.QLastTime  = 0.00;
    state.DFirstTime = 0.00;
    state.DLastTime  = 0.00;
    state.CFirstTime = 0.00;
    state.CLastTime  = 0.00;

    state.total_read_time   = 0.00;
    state.total_write_time  = 0.00;
    state.max_await_read    = 0.00;
    state.max_await_write   = 0.00;
    state.max_await         = 0.00;
    state.avg_await_read    = 0.00;
    state.avg_await_write   = 0.00;
    state.avg_await         = 0.00;

    state.orphan_check = ORPHAN_MIN_IO;
    state.orphan_time  = 0.00;
 
    return(0);
}



int parse_config( char *location )
{
char username[64];
char filename[MAXPATHLEN];
char token   [MAXBUF];
char cfgline [MAXBUF];
typ_conf_group *this;
typ_conf_group *last;
int  mult, ndx;
int  lineno=0;
FILE *cfgf;
char *ptr;

    strcpy(filename, location);
    if (*location == '~')
    {
	strcpy(username,get_user_account());
	if (strlen(username) == 0)
        {
	    printf( "%%W[%05d]-skipping import of '%s' configuration file, unable to determine account name.\n", __LINE__, location );
	    return(0);
        }
        sprintf( filename, "/%s/%s", username, &location[1] );
    }
    if ((cfgf=fopen(filename,"r")) == NULL)
    {
	logHprintf( "%%I[%05d]-config file '%s' not present.\n", __LINE__, filename );
        return(0);
    }
    logHprintf( "%%I[%05d]-process config file '%s'...\n", __LINE__, filename );
    while (fgets(cfgline, MAXBUF, cfgf ) != NULL)
    {
	lineno++;
	if (cfgline[0] == '#') continue;

	strtrim(cfgline); 
        ptr = cfgline;
	skip_whitespace(&ptr);
        get_tokend(&ptr,token, " \t:="); skip_whitespace(&ptr);
	if ((*ptr == ':') || (*ptr == '=')){ ptr++; skip_whitespace(&ptr); }

	if ((strlen(token) == strlen("base_seconds")) && (strncmp( token, "base_seconds", 12) == 0))
	{
	    get_token(&ptr,token);
	    conf_base_seconds = atoi(token);
	    logHprintf( "%%I[%05d]-control 'base_seconds'       being set to %d via %s (default=0)\n", __LINE__, conf_base_seconds, filename );
	    continue;
	}
        if ((strlen(token) == strlen("stripe_mult")) && (strncmp( token, "stripe_mult", 11) == 0))
        {
	    get_token(&ptr,token);
	    mult = atoi(token);
	    if (mult <= 0) mult = 1; /* cannot allow zero or negative values */
	    if ((mult >= 1) && (mult <= MAX_STRIPE_MULT))
            {
		logHprintf( "%%I[%05d]-control 'stripe multiple'    being set to %d via %s (default=%d)\n", __LINE__, mult, filename, conf_disk_stripe_multiplier );
		conf_disk_stripe_multiplier = mult;
	    }
	    else
	    {
		logHprintf( "%%W[%05d]-stripe multipler setting of %d skipped via %s, must be between 1...%d\n", __LINE__, mult, filename, MAX_STRIPE_MULT );
	    }
	    continue;
	}

        if ((strlen(token) == strlen("io_count_threshold")) && (strncmp( token, "io_count_threshold", 18) == 0))
        {
            get_token(&ptr,token);
            mult = atoi(token);
	    if (mult <= 0) mult = 1; /* cannot allow zero or negative values */
            logHprintf( "%%I[%05d]-control 'io count threshold' being set to %d via %s (default=%d)\n", __LINE__, mult, filename, conf_disk_count_threshold   );
            conf_disk_count_threshold   = mult;
            continue;
        }

        if ((strlen(token) == strlen("group_io_count_threshold")) && (strncmp( token, "group_io_count_threshold", 24) == 0))
        {
            get_token(&ptr,token);
            mult = atoi(token);
	    if (mult <= 0) mult = 1; /* cannot allow zero or negative values */
            logHprintf( "%%I[%05d]-control 'group_io count threshold' being set to %d via %s (default=%d)\n", __LINE__, mult, filename, conf_disk_group_count_threshold   );
            conf_disk_group_count_threshold   = mult;
            continue;
        }

        if ((strlen(token) == strlen("noreset_on_requeue")) && (strncmp( token, "noreset_on_requeue", 24) == 0))
        {
            get_token(&ptr,token);
            mult = atoi(token);
            logHprintf( "%%I[%05d]-control 'reset on requeue' being set to %d via %s (default=%d)\n", __LINE__, mult, filename, conf_noreset_on_requeue );
            conf_noreset_on_requeue = mult;
            continue;
        }

        if ((strlen(token) == strlen("include_d2d")) && (strncmp( token, "include_d2d", 24) == 0))
        {
            get_token(&ptr,token);
            mult = atoi(token);
            logHprintf( "%%I[%05d]-control 'include D2D'        being set to %d via %s (default=%d)\n", __LINE__, mult, filename, conf_include_d2d );
            conf_include_d2d = mult;
            continue;
        }
        if ((strlen(token) == strlen("no_annotation")) && (strncmp( token, "no_annotation", 24) == 0))
        {
            get_token(&ptr,token);
            mult = atoi(token);
            logHprintf( "%%I[%05d]-control 'no_annotation'      being set to %d via %s (default=%d)\n", __LINE__, mult, filename, conf_no_annotation );
            conf_no_annotation = mult;
            continue;
        }

        if ((strlen(token) == strlen("allow_duplicate_completes")) && (strncmp( token, "allow_duplicate_completes", 24) == 0))
        {
            get_token(&ptr,token);
            mult = atoi(token);
            logHprintf( "%%I[%05d]-control 'allow_duplicate_completes' being set to %d via %s (default=%d)\n", __LINE__, mult, filename, conf_allow_duplicate_completes );
            conf_allow_duplicate_completes = mult;
            continue;
        }

        if ((strlen(token) == strlen("merged_event_debug")) && (strncmp( token, "merged_event_debug", 18) == 0))
        {
            get_token(&ptr,token);
            mult = atoi(token);
            if (mult <= 0) mult = 0; 
            if (mult >= 1) mult = 1;
            logHprintf( "%%I[%05d]-control 'merged_event_debug' being set to %d via %s (default=%d)\n", __LINE__, mult, filename, conf_merged_event_debug );
            conf_merged_event_debug = mult;
            continue;
        }

        if ((strlen(token) == strlen("exceptions_inhibit")) && (strncmp( token, "exceptions_inhibit", 18) == 0))
        {
            get_token(&ptr,token);
            mult = atoi(token);
            if (mult <= 0) mult = 0; 
            if (mult >= 1) mult = 1;
            logHprintf( "%%I[%05d]-control 'exceptions_inhibit' being set to %d via %s (default=%d)\n", __LINE__, mult, filename, conf_exceptions_inhibit );
            conf_exceptions_inhibit = mult;
            continue;
        }

        if ((strlen(token) == strlen("x360_policy")) && (strncmp( token, "x360_policy", 11) == 0))
        {
            get_token(&ptr,token);
            mult = atoi(token);
            if (mult <= 0) mult = 0; 
            if (mult >= 4) mult = 4;
            logHprintf( "%%I[%05d]-control 'x360_policy' being set to %d via %s (default=%d)\n", __LINE__, mult, filename, conf_x360_policy );
            conf_x360_policy = mult;
            continue;
        }

        if ((strlen(token) == strlen("x360_completions")) && (strncmp( token, "x360_completions", 16) == 0))
        {
            get_token(&ptr,token);
            mult = atoi(token);
            if (mult <= 0) mult = 0; 
            logHprintf( "%%I[%05d]-control 'x360_completions' being set to %d via %s (default=%d)\n", __LINE__, mult, filename, conf_x360_completions );
            conf_x360_completions = mult;
            continue;
        }



        if ((strlen(token) == strlen("group")) && (strncmp( token, "group", 5) == 0))
        {
	    /* allocate a placeholder group with 256 device members */
	    if (tmp_conf_group == NULL)
	        tmp_conf_group = (typ_conf_group *)malloc(sizeof(typ_conf_group)+(sizeof(typ_conf_grpdevice)*256));
	    bzero(tmp_conf_group,sizeof(typ_conf_group)+(sizeof(typ_conf_grpdevice)*256));
	
            get_tokend(&ptr,token, " \t:="); skip_whitespace(&ptr);
	    if ((*ptr == ':') || (*ptr == '=')) { ptr++; skip_whitespace(&ptr); }

	    strcpy( tmp_conf_group->group_name, token );

	    while (*ptr != 0)
	    {
		get_tokend(&ptr, token, " \t:,;"); skip_whitespace(&ptr);
		if ((*ptr == ':') || (*ptr == ',') || (*ptr == ';')) { ptr++; skip_whitespace(&ptr); }
	        strcpy(tmp_conf_group->devices[ tmp_conf_group->device_cnt++ ].device_name, token );
	    }

	     /* Ok, alloc a group of just the right size */
	    this = (typ_conf_group *)malloc(sizeof(typ_conf_group)+(sizeof(typ_conf_grpdevice)*tmp_conf_group->device_cnt));
	    bzero(this, sizeof(typ_conf_group)+(sizeof(typ_conf_grpdevice)*tmp_conf_group->device_cnt) );
	    strcpy(this->group_name, tmp_conf_group->group_name );
	    for (ndx=0; ndx<tmp_conf_group->device_cnt; ndx++)
		strcpy(this->devices[ndx].device_name, tmp_conf_group->devices[ndx].device_name );
	    this->device_cnt = tmp_conf_group->device_cnt;

	    this->private = (typ_disk_stripe *)malloc(sizeof(typ_disk_stripe));

	    if (groups == NULL) 
	    {
		/* first group */
		groups = this;
	    }
	    else
	    {
		last = groups;
		while (last->next != NULL) last = last->next;
		last->next = this;
		groups_cnt++;
	    }
            logHprintf( "%%I[%05d]-group   '%s' defined, includes ", __LINE__, this->group_name );
	    for (ndx=0; ndx<this->device_cnt; ndx++) printf( "%s%c  ", this->devices[ndx].device_name, (((ndx+1)<this->device_cnt)?',':' ') );
	    printf( "\n");
	    continue;
	}

        if (strlen(cfgline) > 0)
	{
	    printf( "%%W[%05d]-unknown blktrace.conf directive, skipping %4d:'%s'\n", __LINE__, lineno, cfgline );
	    printf( "%%I[%05d]-token '%s' next '%s'\n", __LINE__, token, ptr );
	}
    } 
    fclose(cfgf);
    logHprintf( "%%I[%05d]-dump groups, (if any defined)\n",__LINE__);
    this = groups;
    while (this != NULL)
    {
	logHprintf( "%%I[%05d]-group '%s' contains ", __LINE__, this->group_name );
        for (ndx=0; ndx<this->device_cnt; ndx++)
            printf( "%s ", this->devices[ndx].device_name );
        printf( "\n" );
	this = this->next;
    }
    return(0);
}
		

/* SECTION: FUNCTION BLOCK ; UTILITY FUNCTIONS */
/* ================================================================================================================= */
/* === UTILITY FUNCTIONS =========================================================================================== */
/* ================================================================================================================= */

char *get_user_account()
{
char *name;

    if ((name = getenv("HOME")) != 0)
    {
        return(name);
    }
    if ((name = getenv("USER")) != 0)
        return(name);
    if ((name = getenv("USERNAME")) != 0)
        return(name);
    if (strcmp(name, "/root") == 0)
            return("root");
   fprintf( stderr, "%%W[%05d]-cannot determine user account name, quitting\n", __LINE__ );
   return("");
}
int lvm_check(typ_actions *actions)
{
    /* lvm events have only Q & C events -- no I or D since there is no scheduler/request queue */
    /* associated with an lvm device.  Check for missing I and D timestamps, if Q & C exist     */
    /* but I and D do not, then return 1 (is lvm device), otherwise return 0.                   */
    if ((actions->queue.line != 0) && (actions->complete.line != 0))
    {
        if ((actions->insert.line != 0) && (actions->dispatch.line != 0))
            return(0);	/* no an lvm device */
        else
            return(1);  /* is an lvm device */
    }
    return(0);
}

int getdecnum( char **pptr )
{
int value = 0;
char *ptr = *pptr;

   while ((*ptr >= '0') && (*ptr <= '9'))
   {
        value = (value * 10) + (int)(*ptr - '0');
        ptr++;
   }
   *pptr = ptr;
   return(value);
}
long getldecnum( char **pptr )
{
long value = 0;
char *ptr = *pptr;

   while ((*ptr >= '0') && (*ptr <= '9'))
   {
        value = (value * 10L) + (long)(*ptr - '0');
        ptr++;
   }
   *pptr = ptr;
   return(value);
}
double getfloatnum(char **pptr)
{
char token[MAXBUF];
double val;

        get_token(pptr, token);
        val = (double )atof(token);
        return((double)atof(token));
}

int strskip(char **pptr, char *list)
{
char *ptr;
char *chk;

    ptr = *pptr;
    chk = list;
    while (1)
    {
        while (*chk != 0)
        {
            if (*chk == *ptr)
            {
                ptr++;
                chk = list;
                break;
            }
            chk++;
        }
        if ((*chk == 0) || (*ptr == 0))
            break;
    }
    *pptr = ptr;
    return(1);
}
int strtrim( char *bgn )
{
char *ptr;
char *chk;
int   len;

    len = strlen(bgn);
    ptr = &bgn[len-1];
    while (1)
    {
        if ((*ptr == ' ') || (*ptr == '\t') || (*ptr == '\n') || (*ptr == 0x0A) || (*ptr == 0x0D))
        {
            *ptr = 0;
            if (ptr == bgn) return(2);
            --ptr;
            continue;
        }
        break;
    }
    return(1);
}

char *get_token(char **pptr, char *token)
{
char *bgn = token;
char *ptr = *pptr;

    *bgn = 0;
    while ((*ptr != 0) && (*ptr != ' ') && (*ptr != '\t'))
        *bgn++ = *ptr++;
    *bgn   = 0;
    *pptr  = ptr;
    return(token);
}
static int nodelimit(char c, char *list)
{
   while (*list != 0)
   {
        if (*list == c) return(1);
        list++;
   }
   return(0);
}
int get_tokend(char **pptr, char *token, char *dlimits)
{
char *bgn = token;
char *ptr = *pptr;

    *token = 0;
    while ((*ptr != 0) && (nodelimit(*ptr, dlimits)==0))
        *token++ = *ptr++;
    *token = 0;
    *pptr  = ptr;
    *token = 0;
    *pptr  = ptr;
    return(strlen(bgn));
}


/* SECTION: FUNCTION BLOCK ; BINS */
/* ================================================================================================================= */
/* === BINS ======================================================================================================== */
/* ================================================================================================================= */

/*
 * In manufacturing, often you "bin" parts -- which ones meet specs within a given range -- some are faster
 * some are slower.  This is something similar.  The program sets up "bins" into which io are sorted as to
 * size and/or speed. For example, all io with await (Q2C) time >=1ms and < 5ms are stuffed/counted into
 * await bin[1], etc.  Then at the end of the sample or run of data, the bins of data are dumped out.  This
 * gives a rough profile of io -- are most of the io completing in a short period of time or longer period of
 * time, how many outliers are there?  How much data is transferred associated with each bin (e.g. 80% of all
 * io completes really really fast but only account for 10% of the data transfers while really slow 20% of the
 * io account for 90% of the data transferred implies a performance problem exists).  Anyway, io counted into
 * array of bins[] with each bin associated with a range or time or size info.
 */

float await_bins[MAXBUCKET] = {
 /*   0 */      0.0 /*ms*/,  /* idle */
 /*   1 */      1.0 /*ms*/,
 /*   2 */      5.0 /*ms*/,
 /*   3 */     10.0 /*ms*/,
 /*   4 */     25.0 /*ms*/,
 /*   5 */     50.0 /*ms*/,
 /*   6 */    100.0 /*ms*/,
 /*   7 */    150.0 /*ms*/,
 /*   8 */    200.0 /*ms*/,
 /*   9 */    250.0 /*ms*/,
 /*  10 */    500.0 /*ms*/,
 /*  11 */   1000.0 /*ms*/,
 /*  12 */   2000.0 /*ms*/,
 /*  13 */   5000.0 /*ms*/,
 /*  14 */  10000.0 /*ms*/,
 /*  15 */      0.0 /*ms*/  /* >10s */
};


float kbs_bins[MAXBUCKET] = {
 /*   0 */      0.0 /*kb*/,  /* idle */
 /*   1 */     10.0 /*kb*/,
 /*   2 */     50.0 /*kb*/,
 /*   3 */    100.0 /*kb*/,
 /*   4 */    250.0 /*kb*/,
 /*   5 */    500.0 /*kb*/,
 /*   6 */   1000.0 /*kb*/,
 /*   7 */   2000.0 /*kb*/,
 /*   8 */   5000.0 /*kb*/,
 /*   9 */  10000.0 /*kb*/,
 /*  10 */  25000.0 /*kb*/,
 /*  11 */  50000.0 /*kb*/,
 /*  12 */  75000.0 /*kb*/,
 /*  13 */ 100000.0 /*kb*/,
 /*  14 */ 200000.0 /*kb*/,
 /*  15 */      0.0 /*kb*/  /* >200M */
};

float req_bins[MAXBUCKET] = {
 /*   0 */      0.0 /*kb*/,  /* idle */
 /*   1 */      1.0 /*kb*/,
 /*   2 */      2.0 /*kb*/,
 /*   3 */      4.0 /*kb*/,
 /*   4 */      8.0 /*kb*/,
 /*   5 */     16.0 /*kb*/,
 /*   6 */     32.0 /*kb*/,
 /*   7 */     48.0 /*kb*/,
 /*   8 */     64.0 /*kb*/,
 /*   9 */     96.0 /*kb*/,
 /*  10 */    128.0 /*kb*/,
 /*  11 */    256.0 /*kb*/,
 /*  12 */    512.0 /*kb*/,
 /*  13 */   1024.0 /*kb*/,
 /*  14 */   2048.0 /*kb*/,
 /*  15 */      0.0 /*kb*/  /* >200M */
};



/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
/* called at start of program in parse_setup() to zero the stats arrays         */
/* soooo whyare readreq and writereq init'd here but not in bin_sample_init() ? */
/* and shouldn't this be part of state, or at least a "stats_block" type thingy */
/* rather than scattered about.							*/
int bin_init()
{
int ndx,d;
    dprintf( "DBG[%05d]: initialize all buckets!!!!\n", __LINE__ );
    bin_total_samples =
    bin_total_readreq =
    bin_total_writreq = 0;
    bin_total_data[0] = 0.0;    /* Xferred: total */
    bin_total_data[1] = 0.0;    /* Xferred: reads */
    bin_total_data[2] = 0.0;    /* Xferred: writes*/
    bin_total_data[3] = 0.0;
    for (ndx=0; ndx<MAXBUCKET; ndx++)
    {
        await_bucket[ndx].sample_count =
          rrq_bucket[ndx].sample_count =
          wrq_bucket[ndx].sample_count =
          kbs_bucket[ndx].sample_count = 0;
        for( d=0; d<4; d++)
        await_bucket[ndx].data[d]      =
          rrq_bucket[ndx].data[d]      =
          wrq_bucket[ndx].data[d]      =
          kbs_bucket[ndx].data[d]      = 0.0;
    }
    return(1);
}


/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
/* This is called at the end of each 1s sample */
int bin_init_sample()
{
int ndx,d;
    bin_total_samples = 0;
    bin_total_data[0] = 0.0;	/* Xferred: total */
    bin_total_data[1] = 0.0;	/* Xferred: reads */
    bin_total_data[2] = 0.0;    /* Xferred: writes*/
    bin_total_data[3] = 0.0;
    for (ndx=0; ndx<MAXBUCKET; ndx++)
    {
	await_bucket[ndx].sample_count = 
	  kbs_bucket[ndx].sample_count = 0;
	for( d=0; d<4; d++)
        await_bucket[ndx].data[d]      = 
	  kbs_bucket[ndx].data[d]      = 0.0;
    }
    return(1);
}

/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int bin_sample(float kbsize, float q2c, int iotype )
{
    /* in ascending order:
     * read       = IOTYP_READ
     * write      = IOTYP_WRITE, IOTYP_META, IOTYP_BARRIER
     * discard    = IOTYP_DISCARD, treat discards as writes for bin'ing purposes
     */
    if ((iotype != IOTYP_READ) && (!(iotype >= IOTYP_WRITE))) return(0);

    bin_total_samples++;
    bin_total_data[XFER_TOTAL] += kbsize;
    bin_await(kbsize, q2c);
    bin_kbs(kbsize, q2c);
  
    /* The above are flushed/cleared at the beginning of each 1s sample */
    /* at the end of dump.                                              */
    /* The following are only dumped at end of file.                    */
    if (iotype == IOTYP_READ) bin_rrq( kbsize, q2c );
    else                      bin_wrq( kbsize, q2c );    
    return(1);
}


/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int bin_await(float kbsize, float q2c)
{
int ndx;

    await_bucket[MAXBUCKET].sample_count++;
    await_bucket[MAXBUCKET].data[AWAIT_TOTAL] += kbsize;
    await_bucket[MAXBUCKET].data[AWAIT_TIME ] += q2c;
    for (ndx=0; ndx<MAXBUCKET-1; ndx++)
    {
        if (q2c <= await_bins[ndx])
        {
		await_bucket[ndx].sample_count++;
		await_bucket[ndx].data[AWAIT_TOTAL]  += kbsize;
		await_bucket[ndx].data[AWAIT_TIME ]  += q2c;
                return(1);
        }
    }
    await_bucket[MAXBUCKET-1].sample_count++;
    await_bucket[MAXBUCKET-1].data[AWAIT_TOTAL] += kbsize;
    await_bucket[MAXBUCKET-1].data[AWAIT_TIME ] += kbsize;
    return(1);
}

/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
/* bucket is added to per second sample time */
int bin_kbs(float kbsize, float q2c)
{
int ndx;

    kbs_bucket[MAXBUCKET].sample_count++;
    kbs_bucket[MAXBUCKET].data[KBS_TOTAL] += kbsize;
    kbs_bucket[MAXBUCKET].data[KBS_TIME ] += q2c;
    for (ndx=0; ndx<MAXBUCKET-1; ndx++)
    {
        if (kbsize <= kbs_bins[ndx])
        {

		kbs_bucket[ndx].sample_count++;
		kbs_bucket[ndx].data[KBS_TOTAL] += kbsize;
		kbs_bucket[ndx].data[KBS_TIME ] += kbsize;
	        return(1);
        }
    }
    kbs_bucket[MAXBUCKET-1].sample_count++;
    kbs_bucket[MAXBUCKET-1].data[KBS_TOTAL] += kbsize;
    kbs_bucket[MAXBUCKET-1].data[KBS_TIME ] += q2c;
    return(1);
}


/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
/* bucket is added to per read io request */
int bin_rrq(float reqsize, float q2c )
{
int ndx;

    rrq_bucket[MAXBUCKET].sample_count++;
    rrq_bucket[MAXBUCKET].data[REQ_TOTAL] += reqsize;
    rrq_bucket[MAXBUCKET].data[REQ_AWAIT] += q2c;
    for (ndx=0; ndx<MAXBUCKET-1; ndx++)
    {
        if (reqsize <= req_bins[ndx])
        {
                rrq_bucket[ndx].sample_count++;
                rrq_bucket[ndx].data[REQ_TOTAL] += reqsize;
	        rrq_bucket[ndx].data[REQ_AWAIT] += q2c;
                return(1);
        }
    }
    rrq_bucket[MAXBUCKET-1].sample_count++;
    rrq_bucket[MAXBUCKET-1].data[REQ_TOTAL] += reqsize;
    rrq_bucket[MAXBUCKET-1].data[REQ_AWAIT] += q2c;
    return(1);
}


/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int bin_wrq(float reqsize, float q2c)
{
int ndx;

    wrq_bucket[MAXBUCKET].sample_count++;
    wrq_bucket[MAXBUCKET].data[REQ_TOTAL] += reqsize;
    wrq_bucket[MAXBUCKET].data[REQ_AWAIT] += q2c;
    for (ndx=0; ndx<MAXBUCKET-1; ndx++)
    {
        if (reqsize <= req_bins[ndx])
        {
                wrq_bucket[ndx].sample_count++;
                wrq_bucket[ndx].data[REQ_TOTAL] += reqsize;
	        wrq_bucket[ndx].data[REQ_AWAIT] += q2c;
                return(1);
        }
    }
    /* didn't fit into any of the buckets */
    wrq_bucket[MAXBUCKET-1].sample_count++;
    wrq_bucket[MAXBUCKET-1].data[REQ_TOTAL] += reqsize;
    wrq_bucket[MAXBUCKET-1].data[REQ_AWAIT] += q2c;
    return(1);
}


/*
total samples = 1252
total blocks  = 
Buckets: Await
   0    1    5   10   25   50  100  150  200  250  500 1000 2000 5000  10s       ; ms per io
0003 0006 0007 0004 0009 0001 0000 0001 0000 0000 0000 0000 0000 0000 0000 0000  ; #samples 
 9.7 19.4 22.6 12.9 29.0  3.2  0.0  3.2  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  ; percentage of requests 
 0.8  3.2  7.4  8.4 38.0  8.4  0.0 33.8  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  ;~percentage of transferred data 

Buckets: kbs
   0   10   50  100  250  500 1000 2000 5000  10M  25M  50M  75M 100M 200M       ; KB per request
0003 0006 0007 0004 0009 0001 0000 0001 0000 0000 0000 0000 0000 0000 0000 0000  ; #samples 
 9.7 19.4 22.6 12.9 29.0  3.2  0.0  3.2  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  ; percentage of requests 
 0.8  3.2  7.4  8.4 38.0  8.4  0.0 33.8  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  ;~percentage of transferred data 
*/
int dump_await_bins();
int dump_kbs_bins();
int dump_rrq_bins();
int dump_wrq_bins();
int dump_bins()
{
    fprintf( outf, "#Total  IO     = %8d\n", bin_total_samples );
    fprintf( outf, "#Total  KBytes = %8.0f\n", bin_total_data[XFER_TOTAL] );
    if (bin_total_samples == 0) bin_total_samples++;
    if (bin_total_data[XFER_TOTAL] <= 0.01) bin_total_data[XFER_TOTAL] = 0.01;
    dump_await_bins();
    dump_kbs_bins();
    dump_rrq_bins();
    dump_wrq_bins();
    fprintf( outf, "\n");
    fprintf( outf, "------------------------------------------------------------------------------------------------------------------------------------------\n");
    fprintf( outf, "--- Hot LBA Map   ------------------------------------------------------------------------------------------------------------------------\n");
    fprintf( outf, "--- Device: %-15s --------------------------------------------------------------------------------------------------------------\n", devicename );
    heatmap_disk_access_dump(conf_disk_count_threshold, 1);
    bin_init_sample();
    return(1);
}
int dump_await_bins()
{
int ndx;
    fprintf( outf, "#\n");
    fprintf( outf, "#Buckets: Await\n#");
    for (ndx=0; ndx<MAXBUCKET-1; ndx++)
    {
	if (await_bins[ndx] < 10000.0)
	    fprintf( outf, "%4.0f ", await_bins[ndx] );
	else
	    fprintf( outf, "%3.0fs ", await_bins[ndx] / 1000.0 );
    }
    fprintf( outf, "      ; avg ms/io per IO\n");

    fprintf( outf, "#" );
    for (ndx=0; ndx<MAXBUCKET; ndx++)
	fprintf( outf, "%04d ", await_bucket[ndx].sample_count );
    fprintf( outf, " ; #io requests\n");

    fprintf( outf, "#" );
    for (ndx=0; ndx<MAXBUCKET; ndx++)
    	fprintf( outf, "%4.1f ", ((float)await_bucket[ndx].sample_count * 100.0) / (float)bin_total_samples );
    fprintf( outf, " ; percentage of requests\n");

    fprintf( outf, "#" );
    for (ndx=0; ndx<MAXBUCKET; ndx++)
        fprintf( outf, "%4.1f ", (await_bucket[ndx].data[0] * 100.0) / bin_total_data[XFER_TOTAL] );
    fprintf( outf, " ;~percentage of transferred data\n");
    return(1);
}


int dump_kbs_bins()
{
int ndx;
    fprintf( outf, "#\n");
    fprintf( outf, "#Buckets: KB/IO (Request Size)\n#");
    for (ndx=0; ndx<MAXBUCKET-1; ndx++)
    {
	if (kbs_bins[ndx] < 10000.0)
	    fprintf( outf, "%4.0f ", kbs_bins[ndx] );
	else
	    fprintf( outf, "%3.0fM ", kbs_bins[ndx] / 1000.0 );
    }
    fprintf( outf, "      ; kb xferred per IO\n");

    fprintf( outf, "#" );
    for (ndx=0; ndx<MAXBUCKET; ndx++)
	fprintf( outf, "%04d ", kbs_bucket[ndx].sample_count );
    fprintf( outf, " ; #IO requests\n");

    fprintf( outf, "#" );
    for (ndx=0; ndx<MAXBUCKET; ndx++)
    	fprintf( outf, "%4.1f ", ((float)kbs_bucket[ndx].sample_count * 100.0) / (float)bin_total_samples );
    fprintf( outf, " ; percentage of requests\n");

    fprintf( outf, "#" );
    for (ndx=0; ndx<MAXBUCKET; ndx++)
        fprintf( outf, "%4.1f ", (kbs_bucket[ndx].data[0] * 100.0) / bin_total_data[XFER_TOTAL] );
    fprintf( outf, " ;~percentage of transferred data\n");
    return(1);
}

int dump_rrq_bins()
{
int ndx;
int   total_requests = rrq_bucket[MAXBUCKET].sample_count;
float total_ms       = rrq_bucket[MAXBUCKET].data[REQ_AWAIT];
float total_data     = rrq_bucket[MAXBUCKET].data[REQ_TOTAL];

    fprintf( outf, "#\n");
    fprintf( outf, "#Buckets: KB/IO (Read Request Size)\n#");
    for (ndx=0; ndx<MAXBUCKET-1; ndx++)
    {
        if (req_bins[ndx] < 10000.0)
            fprintf( outf, "%4.0f ", req_bins[ndx] );
        else
            fprintf( outf, "%3.0fM ", req_bins[ndx] / 1000.0 );
    }
    fprintf( outf, "      ; kb  xferred per read io request\n");

    fprintf( outf, "#" );
    for (ndx=0; ndx<MAXBUCKET; ndx++)
        fprintf( outf, "%04d ", rrq_bucket[ndx].sample_count );
    fprintf( outf, " ; #requests\n" );

    /* prevent divide by zero when there is no events */
    if (total_requests == 0   ) total_requests = 1;
    if (total_data     <= 0.1 ) total_data     = 1.0;
    if (total_ms       <= 0.1 ) total_ms       = 1.0;

    fprintf( outf, "#" );
    for (ndx=0; ndx<MAXBUCKET; ndx++)
        fprintf( outf, "%4.1f ", ((float)rrq_bucket[ndx].sample_count * 100.0) / (float)total_requests );
    fprintf( outf, " ; percentage of requests          : %10.2f\n", ((float)rrq_bucket[MAXBUCKET].sample_count * 100.0 )/(float)total_requests );

    fprintf( outf, "#" );
    for (ndx=0; ndx<MAXBUCKET; ndx++)
        fprintf( outf, "%4.1f ", (rrq_bucket[ndx].data[REQ_TOTAL] * 100.0) / total_data );
    fprintf( outf, " ;~percentage of transferred data  : %10.2f\n", (rrq_bucket[MAXBUCKET].data[REQ_TOTAL] * 100.0 )/(float)total_data );

    fprintf( outf, "#" );
    for (ndx=0; ndx<MAXBUCKET; ndx++)
        fprintf( outf, "%4.1f ", (rrq_bucket[ndx].data[REQ_AWAIT] * 100.0) / total_ms );
    fprintf( outf, " ;~percentage of time              : %10.2f\n", (rrq_bucket[MAXBUCKET].data[REQ_AWAIT] * 100.0 )/(float)total_ms );
    return(1);
}
int dump_wrq_bins()
{
int ndx;
int   total_requests = wrq_bucket[MAXBUCKET].sample_count;
float total_ms       = wrq_bucket[MAXBUCKET].data[REQ_AWAIT];
float total_data     = wrq_bucket[MAXBUCKET].data[REQ_TOTAL];

    fprintf( outf, "#\n");
    fprintf( outf, "#Buckets: KB/IO (Write Request Size)\n#");
    for (ndx=0; ndx<MAXBUCKET-1; ndx++)
    {
        if (req_bins[ndx] < 10000.0) 
            fprintf( outf, "%4.0f ", req_bins[ndx] );
        else
            fprintf( outf, "%3.0fM ", req_bins[ndx] / 1000.0 );
    }
    fprintf( outf, "      ; kb  xferred per write io request\n");

    fprintf( outf, "#" );
    for (ndx=0; ndx<MAXBUCKET; ndx++)
        fprintf( outf, "%04d ", wrq_bucket[ndx].sample_count );
    fprintf( outf, " ; #requests\n");

    /* prevent divide by zero when there is no events */
    if (total_requests == 0   ) total_requests = 1;
    if (total_data     <= 0.1 ) total_data     = 1.0;
    if (total_ms       <= 0.1 ) total_ms       = 1.0;

    fprintf( outf, "#" );
    for (ndx=0; ndx<MAXBUCKET; ndx++)
        fprintf( outf, "%4.1f ", ((float)wrq_bucket[ndx].sample_count * 100.0) / (float)total_requests );
    fprintf( outf, " ; percentage of requests          : %10.2f\n", ((float)wrq_bucket[MAXBUCKET].sample_count * 100.0 )/(float)total_requests );

    fprintf( outf, "#" );
    for (ndx=0; ndx<MAXBUCKET; ndx++)
        fprintf( outf, "%4.1f ", (wrq_bucket[ndx].data[REQ_TOTAL] * 100.0) / total_data );
    fprintf( outf, " ;~percentage of transferred data  : %10.2f\n", (wrq_bucket[MAXBUCKET].data[REQ_TOTAL] * 100.0)/(float)total_data  );

    fprintf( outf, "#" );
    for (ndx=0; ndx<MAXBUCKET; ndx++)
        fprintf( outf, "%4.1f ", (wrq_bucket[ndx].data[REQ_AWAIT] * 100.0) / total_ms );
    fprintf( outf, " ;~percentage of time              : %10.2f\n", (wrq_bucket[MAXBUCKET].data[REQ_AWAIT] * 100.0)/(float)total_ms    );
    return(1);
}


/* SECTION: FUNCTION BLOCK ; DUMP IO/EVENT DATA STRUCTURES */
/* ================================================================================================================= */
/* === DUMP IO/EVENT DATA STRUCTURES =============================================================================== */
/* ================================================================================================================= */



/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int dump_state()
{
    printf( "\n");
    printf( "DBG[%05d]: state\n", __LINE__ );
    printf( "DBG[%05d]: ===================================================================================\n", __LINE__ );
    printf( "DBG[%05d]: %6d::'%s'\n", __LINE__, state.line,   state.inpline );
    printf( "DBG[%05d]: %6d::'%s'\n", __LINE__, state.line-1, state.lstline );
    printf( "DBG[%05d]: Plug   P:%08lu            U:%08lu (isPlugged=%d)\n", __LINE__,
	state.PlugCount, state.UnplugCount, state.isPlugged );
    printf( "DBG[%05d]: SeqNo  x:%08lu Q:%08lu S:%08lu G:%08lu M:........ F:........ I:%08lu D:%08lu R:%08lu C:%08lu (inProgress=%08lu, inFlight=%08lu)\n", __LINE__,
	state.xSeqNo, state.QSeqNo, state.SSeqNo, state.GSeqNo, state.ISeqNo, state.DSeqNo, state.RSeqNo, state.CSeqNo,
	(state.QSeqNo + state.XSeqNo) - state.CSeqNo, state.DSeqNo - state.CSeqNo );
    printf( "DBG[%05d]: Events A:%08lu Q:%08lu S:%08lu G:%08lu M:%08lu F:%08lu I:%08lu D:%08lu R:%08lu C:%08lu x:%08lu\n", __LINE__,
	state.event_count_remap, state.event_count_queue, state.event_count_sleep, state.event_count_getrq, state.event_count_merge,
	state.event_count_front, state.event_count_insert, state.event_count_dispatch, state.event_count_requeue, state.event_count_complete,
	state.event_count_other);


#ifdef NOTYET 
    double        QFirstTime;		/* the timestamp of the 1st Q event in seq of Q events          */
    double        QLastTime;		/* the timestamp of the nth Q event, cnt=1 these are the same   */
    double        DFirstTime;		/* the timestamp of the 1st Q event in seq of Q events          */
    double        DLastTime;		/* the timestamp of the nth Q event, cnt=1 these are the same   */
    double        CFirstTime;		/* the timestamp of the 1st Q event in seq of Q events          */
    double        CLastTime;		/* the timestamp of the nth Q event, cnt=1 these are the same   */

    int QEventCnt;			/* number of Q events between 1st and nth, inclusive 		*/
    int DEventCnt;			/* number of Q events between 1st and nth, inclusive 		*/
    int CEventCnt;			/* number of Q events between 1st and nth, inclusive 		*/
#endif

    printf( "DBG[%05d]: inProgress: %07d - R:  %6d W:  %6d%s\n", __LINE__, 
	state.inProgress, state.inProgress_Read, state.inProgress_Write,
	state.inProgress==(state.inProgress_Read + state.inProgress_Write)?" ok":" %ERROR!" );
    printf( "DBG[%05d]: inFlight  : %07d - R:  %6d W:  %6d%s\n", __LINE__, 
	state.inFlight, state.inFlight_Read, state.inFlight_Write,
	state.inFlight==(state.inFlight_Read + state.inFlight_Write)?" ok":" %ERROR!" );
    printf( "DBG[%05d]: started   : %07d - R:  %6d W:  %6d\n", __LINE__,
       (state.started_reads +state.started_writes ),
	state.started_reads, state.started_writes );
    printf( "DBG[%05d]: completed : %07d - R:  %6d W:  %6d\n", __LINE__,
       (state.completed_reads +state.completed_writes ),
	state.completed_reads, state.completed_writes );
    printf( "DBG[%05d]: inprogress: %07d - R:  %6d W:  %6d\n", __LINE__,
      ((state.started_reads - state.completed_reads   ) +
       (state.started_writes - state.completed_writes )),
	state.started_reads - state.completed_reads, 
        state.started_writes - state.completed_writes );
    printf( "DBG[%05d]: TotTime   :           R:%8.4f W:%8.4f\n", __LINE__,
	state.total_read_time, state.total_write_time );
    printf( "DBG[%05d]: MaxAwait  :           R:%8.4f W:%8.4f (%8.4f)\n", __LINE__,
	state.max_await_read, state.max_await_write, state.max_await );
    printf( "DBG[%05d]: AvgAwait  :           R:%8.4f W:%8.4f (%8.4f)\n", __LINE__,
	(state.completed_reads>0)?(state.total_read_time/(double)state.completed_reads):0.00,
	(state.completed_writes>0)?(state.total_write_time/(double)state.completed_writes):0.00,
        (state.completed_reads+state.completed_writes)>0?(state.total_read_time+state.total_write_time)/(double)(state.completed_reads+state.completed_writes):0.00);
    printf( "DBG[%05d]: oddIO     : conflicted:%6d overlapped:%6d (active=%6d)\n", __LINE__,
	state.conflicted_io, state.overlapped_io, state.overlapping_io );
    printf( "DBG[%05d]: orphans   : %12.8f = %6d, next check in %d io (current time=%12.8f)\n", __LINE__,
	state.orphan_time, state.orphan_io, state.orphan_check, state.time );
    printf( "DBG[%05d]: --------------------------------------------------------------------\n\n", __LINE__ );
    if (state.xsplit_match_count >= 1000)
	    printf( "\n%%I[%05d]: recommended to add -XX option to command line!\n", __LINE__ );
    return(0);
}

/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int dump_staged_list(int lineno)
{
typ_io *staged;
int hdr=0;
int cnt;

    dprintf( "\n");
    dprintf( "DBG[%05d]: dump_staged_list(%d)\n", lineno, staged_on_list );
    if (staged_on_list == 0) return(0);

    /* dump_mainio_list1(&this,-1,"this"); -- there is no 'this' global io, only 'this' event */
    /* printf( "DBG[%05d]: %-14s %12p[    ] \n", __LINE__, "current_mainio", curr_mainio ); */
    for (cnt=0,staged=staged_list; staged != NULL; staged=staged->next,cnt++)
    {
	if (hdr++ == 0)
	{
            dprintf( "DBG[%05d]: ===================================================================================\n", __LINE__ );
            dprintf( "                              Address   ndx         Next         _Dev_  Timestamp   Act Type_  EventMask__,nn x _____Sector_____, Len_  flags  counts\n");
	}
        dump_staged_list1(staged,cnt,"staged");
    }
    if (cnt != staged_on_list)
        dprintf( "DBG[%05d]: staged_on_list %d != %d count found\n", __LINE__, staged_on_list, cnt );
    dprintf( "DBG[%05d]: --------------------------------------------------------------------\n\n", __LINE__ );
    return(0);
}

/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int dump_staged_list1( typ_io *staged, int ndx, char *name )
{
    /* The -IOTYP_READ biases reads as 0, anything positive as some variant of WRITE (write, trim, barrier...), 
     * anything negative as "something else" */
    dprintf( "DBG[%05d]: %-14s %12p[%4d] -> %12p  ", __LINE__, name, staged, ndx, staged->next );
    dprintf(            "%3d,%3d %12.8f '%c' %6.6s %s,%02d %d:%16lu,%6ld %06X%s\n",
        staged->major, staged->minor, staged->timeinfo.time,  staged->prmact, staged->evttyp, _showmask(staged->event_mask), staged->prmtyp-IOTYP_READ,
        staged->locflg, staged->sector, staged->length, staged->ioflags,
	(((staged->evtflags & EVTFLG_GHOST) == 0)?"":" [GHOST]") );

    return(0);
}



/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int dump_mainio_list(int lineno)
{
typ_io *mainio;
int hdr=0;
int cnt;

    dprintf( "\n");
    dprintf( "DBG[%05d]: dump_mainio_list(%d)\n", lineno, mainio_on_list );
    if (mainio_on_list == 0) return(0);

    /* dump_mainio_list1(&this,-1,"this"); -- there is no 'this' global io, only 'this' event */
    for (cnt=0,mainio=mainio_list; mainio != NULL; mainio=mainio->next,cnt++)
    {
	if (hdr++ == 0)
        {
	    dprintf( "DBG[%05d]: ===================================================================================\n", __LINE__ );
	    dprintf( "                              Address   ndx         Next         _Dev_  Timestamp   Act Type_  EventMask__,nn x _____Sector_____, Len_  flags  counts\n");
	    dprintf( "DBG[%05d]: %-14s %12p[    ] \n", __LINE__, "current_mainio", curr_mainio );
	}
	dump_mainio_list1(mainio,cnt,"active");
    }
    if (cnt != mainio_on_list)
	dprintf( "DBG[%05d]: mainio_on_list %d != %d count found\n", __LINE__, mainio_on_list, cnt );
    dprintf( "DBG[%05d]: --------------------------------------------------------------------\n\n", __LINE__ );
    return(0);
}


/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int dump_mainio_list1( typ_io *mainio, int ndx, char *name )
{
int save;
    /* The -IOTYP_READ biases reads as 0, anything positive as some variant of WRITE (write, trim, barrier...), 
     * anything negative as "something else" */
    dprintf( "DBG[%05d]: %-14s %12p[%4d] -> %12p  ", __LINE__, name, mainio, ndx, mainio->next );
    dprintf(            "%3d,%3d %12.8f '%c' %6.6s %s,%02d %d:%16lu,%6ld %06X merges=%4d requeues=%4d,%4d sleeps=%4d%s\n",
	mainio->major, mainio->minor, mainio->timeinfo.time,  mainio->prmact, mainio->evttyp, _showmask(mainio->event_mask), mainio->prmtyp-IOTYP_READ,
	mainio->locflg, mainio->sector, mainio->length, mainio->ioflags, mainio->info->cnt_merges, mainio->info->cnt_requeues, mainio->info->cnt_dispatches, mainio->info->cnt_sleeps,
	((mainio->evtflags & EVTFLG_GHOST)==0?"":" [GHOST]") );
    save = conf_merged_event_debug;
	   conf_merged_event_debug = 1;
    dbg_out_events_in_io(mainio, stdout );
           conf_merged_event_debug = save;
    return(0);
}

/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int dump_postio_list(int lineno)
{
typ_io *postio;
int cnt;

    printf( "\n");
    printf( "DBG[%05d]: dump_postio_list(%d)\n", lineno, postio_on_list );
    printf( "DBG[%05d]: ===================================================================================\n", __LINE__ );
    /* dump_mainio_list1(&this,-1,"this"); -- there is no 'this' global io, only 'this' event */
    /* printf( "DBG[%05d]: %-14s %12p[    ] \n", __LINE__, "current_postio", curr_mainio ); no 'curr_postio' */
    for (cnt=0,postio=postio_list; postio != NULL; postio=postio->next,cnt++)
    {
        dump_postio_list1(postio,cnt,"completed");
    }
    if (cnt != postio_on_list)
        printf( "DBG[%05d]: postio_on_list %d != %d count found\n", __LINE__, postio_on_list, cnt );
    printf( "DBG[%05d]: --------------------------------------------------------------------\n\n", __LINE__ );
    return(0);
}

/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int dump_postio_list1( typ_io *postio, int ndx, char *name )
{   
    /* The -IOTYP_READ biases reads as 0, anything positive as some variant of WRITE (write, trim, barrier...), 
     * anything negative as "something else" */
    dprintf( "DBG[%05d]: %-14s %12p[%4d] -> %12p  ", __LINE__, name, postio, ndx, postio->next );
    dprintf(            "%3d,%3d %12.8f '%c' %6.6s %s,%02d %d:%16lu,%6ld %06X merges=%4d requeues=%4d sleeps=%4d\n",
        postio->major, postio->minor, postio->timeinfo.time,  postio->prmact, postio->evttyp, _showmask(postio->event_mask), postio->prmtyp-IOTYP_READ, 
        postio->locflg, postio->sector, postio->length, postio->ioflags, postio->info->cnt_merges, postio->info->cnt_requeues, postio->info->cnt_sleeps );
    
    return(0);
}





/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int dump_io_raw(typ_io *io, char *reason, int lineno)
{
int active, completed;
typ_io *subio;
int cnt=0;
    /* raw debug dump */
    if (flag_debug != 0)
    {
        dprintf( "dDBG[%05d]: dump_io_raw(%05d) flag_debug=%d reason='%s'\n", __LINE__, lineno, flag_debug, reason );
	for (active=0,completed=0,subio = io->subio; subio != NULL; subio = subio->subio)
        {
	    if ((subio->ioflags & IS_COMPLETE) == 0) active++;
            else                                     completed++;
        }
        dprintf( "dDBG[%05d]: dump %s event %016lX, merges=%d(%d active, %d completed)\n", __LINE__, ((io->parent==NULL)?"mainio":"subio"), io,
                ((io->parent==NULL)?io->info->cnt_merges   :io->parent->info->cnt_merges), 
                ((io->parent==NULL)?io->info->cnt_completes:io->parent->info->cnt_completes) );
        dprintf( "dDBG[%05d]:      sector, size, '%c' QIDC : %12ld:%6ld %s %12.9f %12.9f %12.9f %12.9f\n", __LINE__,
                io->prmact, io->sector, io->length,  _showmask(io->event_mask), 
                io->info->events.first.time,    io->info->events.insert.time,
                io->info->events.dispatch.time, io->info->events.complete.time );
        if (io->info->cnt_merges > 0)
        {   
            dprintf( "dDBG[%05d]: active    merges: %d/%d\n", __LINE__, active, io->info->cnt_merges );
            subio = io->subio;
            while (subio != NULL)
            {   
		printf( "DBG[%05d]: subio #%d %p\n", __LINE__, cnt+1, subio );
		if ((subio->ioflags & IS_COMPLETE) == 0)
                    dprintf( "dDBG[%05d]: [%3d]sector, size, '%c' QIDC : %16ld.%6ld %c:%12.9f %c:%12.9f \n", __LINE__, cnt,
                        subio->lstact, subio->sector, subio->length, 
			subio->prmact, subio->timeinfo.time,
		        subio->lstevt.prmact, subio->lstevt.timeinfo.time );
	        cnt++;
                subio = subio->subio;
            }
            dprintf( "dDBG[%05d]: completed merges: %d/%d\n", __LINE__, active, io->info->cnt_merges );
            subio = io->subio;
            while (subio != NULL)
            {   
		if ((subio->ioflags & IS_COMPLETE) != 0)
                    dprintf( "dDBG[%05d]: [%3d]sector, size, '%c' QIDC : %16ld.%6ld %12.9f %12.9f %12.9f %12.9f\n", __LINE__, cnt,
                        subio->prmact, subio->sector, subio->length, 
                        subio->info->events.first.time,    subio->info->events.insert.time,
                        subio->info->events.dispatch.time, subio->info->events.complete.time );
	        cnt++;
                subio = subio->subio;
            }
        }
        dprintf( "dDBG[%05d]: done.\n", __LINE__ );
        fflush(stdout);
    }
    return(0);
}


/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int dump_io_dbg(typ_io *io)
{
    dprintf( "DBG[%05d]: dump  io    %016lX: next %016lX subio %016lX\n", __LINE__, io, io->next, io->subio );
    dprintf( "DBG[%05d]:      .data  %3d,%3d cpu %d seqno %12ld sect %12ld size %6ld flags %04X evtflg %016lX '%s'\n", __LINE__,
                io->major, io->minor, io->cpu, io->seqnum, io->sector, io->length, io->ioflags, io->evtflags, io->procname );
    dprintf( "DBG[%05d]:      .count %3d:merges %3d:inserted %3d:requeues %3d:dispatches %3d:completes, %3d:coverages\n", __LINE__,
		io->info->cnt_merges,
		io->info->cnt_inserts,
		io->info->cnt_requeues,
		io->info->cnt_dispatches,
		io->info->cnt_completes,
		io->info->cnt_coverages );
    dprintf( "DBG[%05d]:      .time  F:%12.8f Q:%12.8f I:%12.8f D:%12.8f C:%12.8f RL:%12.2f R1:%12.2f D2D:%12.2f D2C.1:%12.2f D2C.n:%12.2f\n", __LINE__,
                io->info->events.first.time, 
                io->info->events.queue.time, 
                io->info->events.insert.time, 
                io->info->events.dispatch.time, 
                io->info->events.complete.time, 
                io->info->events.requeue.time, 
                io->info->events.requeue_first.time,
	        io->info->events.d2d.time,
		io->info->events.d2c_first.time,
		io->info->events.d2c_last.time );
    dprintf( "DBG[%05d]:      .time  Q:%12s I:%12.8f D:%12.8f C:%12.8f \n", __LINE__, " ",
                (io->info->events.insert.time   - io->info->events.first.time),
                (io->info->events.dispatch.time - io->info->events.first.time),
                (io->info->events.complete.time - io->info->events.first.time) );
    return(0);
}
/**
 * ==========================================================================================
 * Function :
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int dump_event_raw(typ_event *this)
{
static char _prmtyp[32]="xoNSRWMBD-----------------------";
    dprintf( "DBG[%05d]: state.kwiobarrier = %d\n", __LINE__, state.kwiobarrier );
    dprintf( "DBG[%05d]: dump event %016lX: next %016lX io:%016lX\n", __LINE__, this, this->next, this->request );
    dprintf( "DBG[%05d]:            .specials %016lX (see SPCFLG_ defines)\n", __LINE__, this->specials );

    /* ------------------------------------------------------------------------------------------------------------------------ */
    /* --- event body: data from event stream --------------------------------------------------------------------------------- */
    /* ------------------------------------------------------------------------------------------------------------------------ */
                                                        dprintf( "DBG[%05d]:            .evtflags %016lX (see EVTFLG_ defines)\n", __LINE__, this->evtflags );
    if ((this->evtflags & EVTFLG_EXCEPTION      ) != 0) dprintf( "DBG[%05d]:                      0x0000.0001 EXCEPTION\n", __LINE__ );
    if ((this->evtflags & EVTFLG_IGNORED        ) != 0) dprintf( "DBG[%05d]:                      0x0000.0002 IGNORED\n", __LINE__ );
    if ((this->evtflags & EVTFLG_BADFIELD       ) != 0) dprintf( "DBG[%05d]:                      0x0000.0004 BADFIELD\n", __LINE__ );
    if ((this->evtflags & EVTFLG_UNKFIELD       ) != 0) dprintf( "DBG[%05d]:                      0x0000.0008 UNKFIELD\n", __LINE__ );
    if ((this->evtflags & EVTFLG_LOCFORMAT      ) != 0) dprintf( "DBG[%05d]:                      0x0000.0010 FORMT_LOCFORMAT\n", __LINE__ );
    if ((this->evtflags & EVTFLG_LOCDATA        ) != 0) dprintf( "DBG[%05d]:                      0x0000.0010 FORMT_LOCDATA\n", __LINE__ );
    if ((this->evtflags & EVTFLG_OLDSTYLE       ) != 0) dprintf( "DBG[%05d]:                      0x0000.0020 FORMT_OLDSTYLE\n", __LINE__ );
    if ((this->evtflags & EVTFLG_NONIOSTYLE     ) != 0) dprintf( "DBG[%05d]:                      0x0000.0040 NONIOSTYLE\n", __LINE__ );
    if ((this->evtflags & EVTFLG_VALID_FROMSECT ) != 0) dprintf( "DBG[%05d]:                      0x0000.0080 VALID_FROMSECT\n", __LINE__ );
    if ((this->evtflags & EVTFLG_VALID_PROCNAME ) != 0) dprintf( "DBG[%05d]:                      0x0000.0800 VALID_PROCNAME\n", __LINE__ );
    if ((this->evtflags & EVTFLG_VALID_SECTOR   ) != 0) dprintf( "DBG[%05d]:                      0x0000.1000 VALID_SECTOR\n", __LINE__ );
    if ((this->evtflags & EVTFLG_VALID_LENGTH   ) != 0) dprintf( "DBG[%05d]:                      0x0000.2000 VALID_LENGTH\n", __LINE__ );
    if ((this->evtflags & EVTFLG_VALID_SIZE     ) != 0) dprintf( "DBG[%05d]:                      0x0000.2000 VALID_SIZE\n", __LINE__ );
    if ((this->evtflags & EVTMSK_VALID_LOCDATA  ) != 0) dprintf( "DBG[%05d]:                      0x0000.3000 VALID_LOCDATA\n", __LINE__ );
    if ((this->evtflags & EVTFLG_WHOLE_COMPLETE ) != 0) dprintf( "DBG[%05d]:                      0x0001.0000 WHOLE_COMPLETE\n", __LINE__ );
    if ((this->evtflags & EVTFLG_BIO_COMPLETE   ) != 0) dprintf( "DBG[%05d]:                      0x0002.0000 BIO_COMPLETE\n", __LINE__ );
    if ((this->evtflags & EVTFLG_SPECIAL_FWS    ) != 0) dprintf( "DBG[%05d]:                      0x0004.0000 SPECIAL_FWS\n", __LINE__ );
    if ((this->evtflags & EVTFLG_GHOST          ) != 0) dprintf( "DBG[%05d]:                      0x0010.0000 GHOST\n", __LINE__ );
    if ((this->evtflags & EVTFLG_GHOST_2NDGEN   ) != 0) dprintf( "DBG[%05d]:                      0x0020.0000 GHOST_2NDGEN\n", __LINE__ );
    if ((this->evtflags & EVTFLG_INPROGDONE     ) != 0) dprintf( "DBG[%05d]:                      0x0040.0000 INPROGDONE\n", __LINE__ );
    if ((this->evtflags & EVTFLG_2NDHAND_MERGE  ) != 0) dprintf( "DBG[%05d]:                      0x0080.0000 2NDHAND_MERGE\n", __LINE__ );
    if ((this->evtflags & EVTFLG_EXCEPTDONE     ) != 0) dprintf( "DBG[%05d]:                      0x0100.0000 EXCEPTDONE\n", __LINE__ );
    if ((this->evtflags & EVTFLG_BESTMATCH      ) != 0) dprintf( "DBG[%05d]:                      0x0200.0000 BESTMATCH\n", __LINE__ );
    if ((this->evtflags & EVTFLG_NOFEATURE      ) != 0) dprintf( "DBG[%05d]:                      0x0400.0000 NOFEATURE\n", __LINE__ );
    if ((this->evtflags & EVTFLG_NOTARGET       ) != 0) dprintf( "DBG[%05d]:                      0x0800.0000 NOTARGET\n", __LINE__ );
    if ((this->evtflags & EVTFLG_DISCARDED      ) != 0) dprintf( "DBG[%05d]:                      0x1000.0000 DISCARDED\n", __LINE__ );
    if ((this->evtflags & EVTFLG_UNKFORMAT      ) != 0) dprintf( "DBG[%05d]:                      0x2000.0000 UNKFORMAT\n", __LINE__ );
    if ((this->evtflags & EVTFLG_KWIOBARRIER    ) != 0) dprintf( "DBG[%05d]:                      0x4000.0000 KWIOBARRIER\n", __LINE__ );

    dprintf( "DBG[%05d]:            .main     %3d,%3d:%12ld -> %3d,%3d:%12ld+%12ld\n", __LINE__,
		   this->from_major, this->from_minor, this->from_sector,
		   this->major,      this->minor,      this->sector,     this->length );
    dprintf( "DBG[%05d]:            .prmact     [%c '%s']\n", __LINE__, this->prmact, this->evtact );
    dprintf( "DBG[%05d]:            .prmtyp   %d [%c '%s']\n", __LINE__,
		    this->prmtyp, _prmtyp[this->prmtyp], this->evttyp );
    typ_action    timeinfo;                   /* timestamp and numb (lineno) captured for this event line                       */
    dprintf( "DBG[%05d]:            .timeinfo %8ld %13.9f pid %8d cpu %4d seg %12ld myseq %12ld\n", __LINE__,
		    this->timeinfo.line, this->timeinfo.time, this->timeinfo.pid, this->timeinfo.cpu,
		    this->timeinfo.seqnum, this->timeinfo.mySeqNo );
    dprintf( "DBG[%05d]:            .procname '%s'\n", __LINE__, this->procname );
    dprintf( "DBG[%05d]:            .extras   '%s'\n", __LINE__, this->extras   );
    dprintf( "DBG[%05d]:            .eventxt  '%s'\n", __LINE__, this->event_text);
    dprintf( "DBG[%05d]:            .reason   '%s'\n", __LINE__, this->reason   );
    return(0);
}




/* SECTION: FUNCTION BLOCK ; HEATMAPS */
/* ================================================================================================================= */
/* === HEATMAPS ==================================================================================================== */
/* ================================================================================================================= */


/* 
 * "HotSpots" tracking.
 *
 * create a set of buckets each so big.  Currently the base size is 128kb * a configurable multiplier.  Currently the multiplier is
 * set to 128 (only because there are io with 256 sector sizes which with a multiplier of 1 means a "hotspot" would have just a count
 * of 1 visit -- not very useful.  So tweaked up to 128 multiplier so seeing significant visits now represent co-located data that
 * is being accessed.  If the last io was in the same bucket, then no seeks in/out of the bucket are counted.  If a previous io 
 * size slid the current bucket to the next one, that bucket was silently set to the current bucket (silent=no seek counter increment
 * either leaving the previous bucket or entering the new bucket since it was done via io.
 *
 */

/*
 * blktrace_parse, add a sector map for "hot spots" and detect # entries and exits from same.
 * assume a 128kb stripe size, but can be specified a different one.  Since we don't know
 * what size the sector range is, assume a 8TB disk? 4TB? and have that also settable.
 *
 * and sectors read/written + count of reads/writes + time spent in bucket read/write.
 *
 * set threshold filter for output
 * sort results and output
 * set threshold for how many to output
 * 
 * if 4TB/128k fails don't output, ask to update blktrace_parse.conf in the directory'
 * with new config params and re-run.
 *
 * 2^40   2^10*2^7-^17 so 2^(40-17) buckets.  2^23 = 8 million buckets. max of 2^24 buckets
 *
 * to cheat, create segments of pointers (64:8 bytes each)  -> 8 ints (32:4 each?).
 * so 32MB of pointers max if hard limit of 2^24 buckets.  So above 4TB need to increase
 * bucket size. Bucket size needs to be 2^N so 256k 512k 1M typical.  Nothing smaller than
 * 128k
 *
 * fixed limit of 4096 segments 2^12 -> 4096 segment chunks each ->
 *
 * 2^12 * 2^12 = 2^24 bucket = 16M buckets * 128k = 2^24 * 2^17 = 2^41 or 2TB.
 * larger than 2TB need to go to 256k for 4TB etc. on up the line.
 *
 * bucket:
 * int seeks_in
 * int seeks_out
 * int reads
 * int writes
 * int reads_kb
 * int write_kb
 * int read_ms
 * int write_ms`
 */



/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int heatmap_disk_access_init()
{
    disk_stripe_size_in_kb = disk_stripe_size_in_kb * conf_disk_stripe_multiplier;
    max_disk_sector = ((long)MAX_SEGMENT_ENTRIES * (long)MAX_SEGMENT_ENTRIES * disk_stripe_size_in_kb * 2L );
    logHprintf( "%%I[%05d]-max disk size supported %16ld (sectors) %16ldGiB\n", __LINE__, max_disk_sector, ((max_disk_sector * 2L) / (1024L * 1024L)) );

    if (((long)(MAX_BUCKET_INDEX+1L) * disk_stripe_size_in_kb * 2L) < max_disk_sector)
    {
        printf( "%%F[%05d]-internal logic error, %16ld < %16ld, exit.\n", __LINE__, ((long)MAX_BUCKET_INDEX * disk_stripe_size_in_kb * 2L) , max_disk_sector );
        printf( "DBG[%05d]: %ld needed, have %ld\n", __LINE__, max_disk_sector / (disk_stripe_size_in_kb * 2), MAX_BUCKET_INDEX);
	PROG_FEATURE_FAULT(NULL,(int),"bad heatmap state detected", CTL_FAULT_FORCE);
    }

    bzero(&diskHotSpots, sizeof(typ_disk_hotspots));
    diskHotSpots.min_bucket = 0x7FFFFFFF;
    diskHotSpots.max_bucket = -1;

#   ifdef DBG_HOTSPOTS
    diskHotSpots.min_sector = 0x7FFFFFFFFFFFF;
    diskHotSpots.max_sector = -1;
#   endif
}



/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int heatmap_disk_access_dump(int threshold, int flag)
{
int ndx;
int segno  = 0;
int bckno  = 0;
int segcnt = 0;
int bckcnt = 0;
int rdcnt  = 0;
int wrcnt  = 0;
int skips  = 0;
int empty  = 0;
int spots  = 0;
int tot_cnt, tot_req;
long tot_sec;
int dbg_bucket_cnt = 0;
float tot_q2c, tot_d2c;
typ_disk_stripe *this;
typ_disk_segment *myseg;
int datfd;
int written;
typ_disk_stripe skipped;
typ_disk_stripe all_stripes;

    datfd = -1;
    if (flag == 1)
    {
        if ((datfd = open( hotfilename, O_CREAT|O_WRONLY, S_IRWXU)) == -1)
        {
	    printf( "%%W[%05d]-HotSpot data not saved, cannot open '%s' for write access.\n", __LINE__, hotfilename );
        }
        bzero( &hot_header, sizeof(typ_hotbinary_header) );
        hot_header.rectyp = RECTYP_HOT_HEADER;
        hot_header.version = RECVER_HOT_HEADER;
#       ifdef DBG_HOTSPOTS
        hot_header.dbg_hotspots = 1;
#       endif
        hot_header.conf_disk_count_threshold       = conf_disk_count_threshold;
        hot_header.conf_disk_group_count_threshold = conf_disk_group_count_threshold;
        hot_header.conf_disk_stripe_multiplier     = conf_disk_stripe_multiplier;
        hot_header.disk_stripe_size_in_kb          = disk_stripe_size_in_kb;
        hot_header.max_disk_sector                 = max_disk_sector;
        bcopy( &diskHotSpots, &hot_header.diskHotSpots, sizeof( typ_disk_hotspots ));
        if (datfd != -1)
        {
            if ((written = write( datfd, &hot_header, sizeof(typ_hotbinary_header))) != sizeof(typ_hotbinary_header ))
            {
	        printf( "%%E[%05d]-binary HotSpots header write failed: %d bytes written, %d requested.\n", __LINE__, written, sizeof(typ_hotbinary_header) );
            }
        }
    }

    spots = heatmap_disk_access_sum_stripes(&all_stripes);
    if ((tot_cnt = all_stripes.read_cnt + all_stripes.write_cnt) == 0   ) tot_cnt = 1;
    if ((tot_sec = all_stripes.read_sec + all_stripes.write_sec) == 0   ) tot_sec = 1;
    if ((tot_q2c = all_stripes.read_q2c + all_stripes.write_q2c) == 0.00) tot_q2c = 0.1;
    if ((tot_d2c = all_stripes.read_d2c + all_stripes.write_d2c) == 0.00) tot_d2c = 0.1;
         tot_req = all_stripes.read_req + all_stripes.write_req;
    rdcnt = all_stripes.read_cnt;
    wrcnt = all_stripes.write_cnt;

    bzero(&skipped,sizeof(skipped));
    dprintf( "DBG[%05d]: min/max bucket %d:%d\n", __LINE__, diskHotSpots.min_bucket, diskHotSpots.max_bucket);
    fprintf( outf, "------------------------------------------------------------------------------------------------------------------------------------------\n");
    fprintf( outf, "Bucket size=%ldKiB * %ld multiplier = %ldKiB (each bucket spans %ld sectors)\n", MIN_STRIPE_SIZE, 
		conf_disk_stripe_multiplier, disk_stripe_size_in_kb, disk_stripe_size_in_kb*2L );
    fprintf( outf, "IO Count Threshold=%d (this or more read+write total io count and the bucket is output, otherwise its added the the 'skipped' bucket.\n", threshold );
    fprintf( outf, "%%IO    - percentage of total number of io         (%8d          ) in this bucket\n", rdcnt+wrcnt );
    fprintf( outf, "%%Xfer  - percentage of total sectors read/written (%10ld sectors) in this bucket\n", tot_sec );
    fprintf( outf, "%%Await - percentage of total await   time (Q2C)   (%11.2fms     ) in this bucket {await as in iostat's await column }\n", tot_q2c );
    fprintf( outf, "%%D2C   - percentage of total storage time (D2C)   (%11.2fms     ) in this bucket {storage time as in storage latency}\n",  tot_d2c );
    fprintf( outf, "Notes   - 1. %%Await can be smaller hanger than %%D2C in the following because these are percentages of total io load.\n");
    fprintf( outf, "             When %%Await < %%D2C, this just means that on average the io in this bucket had more storage latency than other buckets.\n");
    fprintf( outf, "             In ideal world the %%Await would track %%D2C +/- some small amount, which for the most part should be true.\n"); 
    fprintf( outf, "------------------------------------------------------------------------------------------------------------------------------------------\n");
    fprintf( outf, "               |_________Bucket__________| |___Seeks___| |_______________Reads__________________| |________________Writes_________________| |___Percentage of Total___|\n");
    fprintf( outf, "  Bucket#      bgn sector       end sector     in    out     count  sectors  await(ms)    d2c(ms)      count  sectors  await(ms)    d2c(ms)    %%IO  %%Xfer %%Await   %%D2C\n");

    for (bckno=0, segno=0; segno < MAX_SEGMENT_ENTRIES; segno++ )
    {
	dprintf( "DBG[%05d]: segno:bckno %d:%d ptr %lx\n", __LINE__, segno, bckno, (long)diskHotSpots.segments.ptr[segno] );
	if ((myseg = diskHotSpots.segments.ptr[segno]) == NULL) { bckno += MAX_SEGMENT_ENTRIES; continue; }
	segcnt++;

        for (ndx=0; ndx < MAX_SEGMENT_ENTRIES; ndx++, bckno++)
        {
	    dprintf( "DBG[%05d]: %8d[%4d,%4d] ptr %lx\n", __LINE__, bckno, segno, ndx, (long)myseg->ptr[ndx] );
	    if (bckno < diskHotSpots.min_bucket) {                            continue; }
            if (bckno > diskHotSpots.max_bucket) { segno=MAX_SEGMENT_ENTRIES; break;    }

	    if ((this = myseg->ptr[ndx]) == NULL)
		continue;
	
	    dbg_bucket_cnt++;

	    if (this->seeks_in == -1) 
	    {
	        /* allocated but never used, skip! */
	        /* count them as skips             */
	        skips++;
                empty++;
		continue;
	    }
	    bckcnt++;

	    if (flag == 1)
	    {
	        bzero( &hot_entry, sizeof( typ_hotbinary_data ) );
	        hot_entry.rectyp        = RECTYP_HOT_DATA;
	        hot_entry.bucket_number = bckno;
                bcopy( this, &hot_entry.bucket, sizeof( typ_disk_stripe ) );
                if (datfd != -1)
                {
                    if ((written = write( datfd, &hot_entry, sizeof(typ_hotbinary_data))) != sizeof(typ_hotbinary_data ))
                    {
	                printf( "%%E[%05d]-binary HotSpots header data failed: %d bytes written, %d requested.\n", __LINE__, written, sizeof(typ_hotbinary_data) );
                    }
                }
	    }
 	    if (this->read_q2c  < this->read_d2c ) fprintf( outf, "@@@ read q2c %10.2f < %10.2f d2c : output to %s\n", this->read_q2c, this->read_d2c, hotfilename );
 	    if (this->write_q2c < this->write_d2c) fprintf( outf, "@@@ writ q2c %10.2f < %10.2f d2c : output to %s\n", this->write_q2c, this->write_d2c, hotfilename );

	    if ((this->read_cnt + this->write_cnt) >= threshold)
            {
	        fprintf( outf, "%8d %16ld-%16ld %6d:%6d  %8d,%8d,%10.2f,%10.2f  %8d,%8d,%10.2f,%10.2f  %6.2f %6.2f %6.2f %6.2f\n",
		    bckno, this->bgn_sector, this->end_sector, this->seeks_in, this->seeks_out, 
                           this->read_cnt,   this->read_sec,   this->read_q2c, this->read_d2c,
		           this->write_cnt,  this->write_sec,  this->write_q2c,this->write_d2c,
			  (((float)(this->read_cnt + this->write_cnt)/(float)tot_cnt) * 100.0),
			  (((float)(this->read_sec + this->write_sec)/(float)tot_sec) * 100.0),
			  ((       (this->read_q2c + this->write_q2c)/       tot_q2c) * 100.0),
			  ((       (this->read_d2c + this->write_d2c)/       tot_d2c) * 100.0) );
	    }
	    else
	    {
		skips++;
		skipped.seeks_in  += this->seeks_in;
		skipped.seeks_out += this->seeks_out;
		skipped.read_cnt  += this->read_cnt;
		skipped.read_req  += this->read_req;
		skipped.read_sec  += this->read_sec;
		skipped.read_q2c  += this->read_q2c;
		skipped.read_d2c  += this->read_d2c;
		skipped.write_cnt += this->write_cnt;
                skipped.write_req += this->write_req;
		skipped.write_sec += this->write_sec;
		skipped.write_q2c += this->write_q2c;
		skipped.write_d2c += this->write_d2c;
	    }
        }
    }
    if (flag != 0) close( datfd );
    if (skips != 0)
    {
	this = &skipped;
	fprintf( outf, "%8s %16d/%16d %6d:%6d  %8d,%8d,%10.2f,%10.2f  %8d,%8d,%10.2f,%10.2f  %6.2f %6.2f %6.2f %6.2f  (io count<%d)\n",
		"Skipped", skips, diskHotSpots.bucket_cnt, this->seeks_in, this->seeks_out, 
                           this->read_cnt,   this->read_sec,   this->read_q2c, this->read_d2c,
		           this->write_cnt,  this->write_sec,  this->write_q2c,this->write_d2c,
			  (((float)(this->read_cnt + this->write_cnt)/(float)tot_cnt) * 100.0),
			  (((float)(this->read_sec + this->write_sec)/(float)tot_sec) * 100.0),
			  ((       (this->read_q2c + this->write_q2c)/       tot_q2c) * 100.0),
			  ((       (this->read_d2c + this->write_d2c)/       tot_d2c) * 100.0), threshold );
    }
    if (empty != 0)
    fprintf( outf, "%8s %16d/%16d %6d:%6d  %8d,%8d,%10.2f,%10.2f  %8d,%8d,%10.2f,%10.2f  %6.2f %6.2f %6.2f %6.2f\n",
		"Idle", empty, diskHotSpots.bucket_cnt, 0,0, 0,0,0.0,0.0, 0,0,0.0,0.0, 0.0,0.0,0.0,0.0 );
    this = &all_stripes;
    fprintf( outf, "%8s %16d/%16d %6d:%6d  %8d,%8d,%10.2f,%10.2f  %8d,%8d,%10.2f,%10.2f  %6.2f %6.2f %6.2f %6.2f\n",
		"Active", spots, diskHotSpots.bucket_cnt, this->seeks_in, this->seeks_out, 
                           this->read_cnt,   this->read_sec,   this->read_q2c, this->read_d2c,
		           this->write_cnt,  this->write_sec,  this->write_q2c,this->write_d2c,
			  (((float)(this->read_cnt + this->write_cnt)/(float)tot_cnt) * 100.0),
			  (((float)(this->read_sec + this->write_sec)/(float)tot_sec) * 100.0),
			  ((       (this->read_q2c + this->write_q2c)/       tot_q2c) * 100.0),
			  ((       (this->read_d2c + this->write_d2c)/       tot_d2c) * 100.0) );	
    dprintf( "DBG[%05d]: allocated buckets counted %d\n", __LINE__, dbg_bucket_cnt );
    dprintf( "DBG[%05d]: hotspot %d segments %d buckets\n", __LINE__, diskHotSpots.segment_cnt, diskHotSpots.bucket_cnt );
    dprintf( "DBG[%05d]: found   %d segments %d buckets %d reads %d writes\n", __LINE__, segcnt, bckcnt, rdcnt, wrcnt );
    return(0);
}


/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int heatmap_disk_access_bucket( long sector, long secsize, float q2c, float d2c, int requeues, int evttype )
{
long end_sector;
int  bucket;
int  segment;
int  offs;
typ_disk_stripe *this;
int  iotype = -1;

    /* in ascending order:
     * read       = IOTYP_READ
     * write      = IOTYP_WRITE, IOTYP_META, IOTYP_BARRIER
     * discard    = IOTYP_DISCARD, treat as a write for heat map purposes 
     */
         if (evttype == IOTYP_READ ) iotype = IOTYP_READ;
    else if (evttype >= IOTYP_WRITE) iotype = IOTYP_WRITE;

    if ((diskHotSpots.flags & DISK_BUCKET_ALLOC_EXCEEDED) != 0) return(0);
    dprintf( "DBG[%05d]: disk_access %016ld %8d %12.8f %s\n", __LINE__, sector, secsize, q2c, (iotype==IOTYP_READ?"read":(iotype==IOTYP_WRITE)?"write":"other") );
    if ((iotype != IOTYP_READ) && (iotype != IOTYP_WRITE))
    {
	printf( "DBG[%05d]: disk_access skipped, io type = %d\n", __LINE__, iotype );
	return(0);
    }
    if ((sector > max_disk_sector) && ((diskHotSpots.flags & DISK_SIZE_EXCEEDED) == 0))
    {
	printf( "DBG[%05d]: sector %ld exceeds current max of %ld - build blktrace_parse.conf w/new values.\n", __LINE__,
	    sector, max_disk_sector );
	diskHotSpots.flags |= DISK_SIZE_EXCEEDED;
	return(0);
    }
    bucket = heatmap_disk_access_to_bucket( sector );					                /* absolute bucket ('bin') number           */
    dprintf( "DBG[%05d]: end_sector:bucket %ld:%d\n", __LINE__, sector, bucket );
    segment= heatmap_disk_access_to_segment( bucket );					                /* which segment the abs bucket is located  */
    dprintf( "DBG[%05d]: end_sector:segment %ld:%d  (bucket:%d)\n", __LINE__, sector, segment, bucket );	
    this   = heatmap_disk_access_mapbucket( segment, bucket );                                          /* abs_bucket:segment => segment:rel_bucket */
    offs   = (bucket - (segment*MAX_SEGMENT_ENTRIES));

    if (diskHotSpots.min_bucket > bucket) diskHotSpots.min_bucket = bucket;
    if (diskHotSpots.max_bucket < bucket) diskHotSpots.max_bucket = bucket;

    dprintf( "DBG[%05d]: disk_access %8d:[%4d,%4d] %016lX %016lX %016lX\n", __LINE__,
        bucket, segment, offs, this->bgn_sector, sector, this->end_sector );

#ifdef DBG_HOTSPOTS
    if (diskHotSpots.min_sector > sector) diskHotSpots.min_sector = sector;
    if (diskHotSpots.max_sector < sector) diskHotSpots.max_sector = sector;
    if (this->bgn_sector == -1)
    {
	this->bgn_sector = (long)bucket     * (disk_stripe_size_in_kb * 2L);
	this->end_sector = this->bgn_sector + (disk_stripe_size_in_kb * 2L) - 1L;
        dprintf( "DBG[%05d]: disk_access %8d:[%4d,%4d] %016ld %016ld %016ld\n", __LINE__,
            bucket, segment, offs, this->bgn_sector, sector, this->end_sector );
    }
    if ((this->bgn_sector > sector) || (this->end_sector < sector))
    {
	PROG_FEATURE_FAULT(NULL,(int),"sector mismatch in heatmap",CTL_FAULT_FORCE);
    }
#endif
    if (this->seeks_in == -1)
    {
	/* this was allocated but unused up to this point, possible we slid into */
	/* this stripe from a previous extended io from previous bucket...       */
	/* or its just newly created just for us now.                            */
	this->seeks_in = 0;  /* no longer *unused* */
    }
    if (iotype == IOTYP_READ)
    {
	this->read_cnt++;
        this->read_req += requeues;
	this->read_sec += (long)secsize;
	this->read_q2c += q2c;
	this->read_d2c += d2c;
	dprintf( "DBG[%05d]: disk_access %8d:[%4d,%4d] r: %d,%ld,%12.4f,%12.4f\n", __LINE__, bucket, segment, offs, this->read_cnt, this->read_sec, this->read_q2c, this->read_d2c );
        if  (d2c >  q2c) printf( "DBG[%05d]: D2C %12.8f > %12.8f Q2C BAD BAD BAD @@@\n", __LINE__, d2c, q2c );
    }
    else if (iotype == IOTYP_WRITE)
    {
	this->write_cnt++;
        this->write_req += requeues;
	this->write_sec += (long)secsize;
	this->write_q2c += q2c;
	this->write_d2c += d2c;
	dprintf( "DBG[%05d]: disk_access %8d:[%4d,%4d] w: %d,%ld,%12.4f,%12.4f\n", __LINE__, bucket, segment, offs, this->write_cnt, this->write_sec, this->write_q2c, this->write_d2c );
        if  (d2c >  q2c) printf( "DBG[%05d]: D2C %12.8f > %12.8f Q2C BAD BAD BAD @@@\n", __LINE__, d2c, q2c );
    }
	
    /* don't count first io on disk as seek into someplace */
    if (diskHotSpots.last != NULL)
    {    
        if (diskHotSpots.last != this)
	{
	    diskHotSpots.last->seeks_out++;
	                 this->seeks_in++;
	    dprintf( "DBG[%05d]: bump seeks out %8d[%4d,%4d] and into this %8d[%4d,%4d] %016ld-%016ld bucket: %d seeks in\n", __LINE__, 
                diskHotSpots.last_bucket, diskHotSpots.last_segment, (diskHotSpots.last_bucket - (diskHotSpots.last_segment * MAX_SEGMENT_ENTRIES)), 
                                  bucket,                   segment, (                  bucket - (                  segment * MAX_SEGMENT_ENTRIES)),                   
	        this->bgn_sector, this->end_sector, this->seeks_in );
	}
    }

    diskHotSpots.last = this;
    diskHotSpots.last_segment = segment;
    diskHotSpots.last_bucket  = bucket;
	
    /* did this io slide out of the bucket?  If so, don't count this as an exit */
    /* just set up the current bucket in the follow-on bucket                   */
    end_sector = sector + secsize;
    if ((bucket = heatmap_disk_access_to_bucket( end_sector )) != diskHotSpots.last_bucket)
    {
	dprintf( "DBG[%05d]: end_sector:bucket %ld:%d\n", __LINE__, end_sector, bucket );
	/* silent move to a new bucket */
	segment = heatmap_disk_access_to_segment( bucket );
	dprintf( "DBG[%05d]: end_sector:segment %ld:%d  (bucket:%d)\n", __LINE__, end_sector, segment, bucket );
	this    = heatmap_disk_access_mapbucket( segment, bucket );
        offs    = bucket - (segment * MAX_SEGMENT_ENTRIES);
	dprintf( "DBG[%05d]: slide into a new bucket %8d:[%4d,%4d] on extended io\n", __LINE__, bucket, segment, offs );
	
	diskHotSpots.last = this;
        diskHotSpots.last_segment = segment;
        diskHotSpots.last_bucket  = bucket;
    }
    return(0);
}



/**
 * ==========================================================================================
 * Function : Take in an absolute bucket ('bin') number within which the current sector lies,
 *            and determine the absolute sector number that absolute bin is located.  Since
 *            there are 4096 segments and each segments hold 4096 buckets, its just the number
 *            of the absolute bucket / max number of segments.
 *            @bucket:     bin number of sector
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int heatmap_disk_access_to_segment( int bucket )
{
   if (bucket > MAX_BUCKET_INDEX)
   {
	/* should not happen */
	printf( "%%F[%05d]-internal error. Bucket index %d > %d MAX_BUCKET_INDEX, sector > %ld\n", __LINE__, bucket, MAX_BUCKET_INDEX, max_disk_sector );
	PROG_FEATURE_FAULT(NULL,(int),"heatmap bucked index issue detected",CTL_FAULT_FORCE);
   }
   return( bucket / MAX_SEGMENT_ENTRIES );
}



/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
typ_disk_stripe *heatmap_disk_access_mapbucket ( int segment, int bucket )
{
typ_disk_segment *myseg;
typ_disk_stripe  *this;
int segment_offset;

    if (segment > MAX_SEGMENT_ENTRIES)
    {
	/* should not happen */
	printf( "%%F[%05d]-internal error: heatmap segment [%d].%d > max allowed segment [%d].*\n", __LINE__, segment, bucket, MAX_SEGMENT_ENTRIES);
	printf( "DBG[%05d]: sector / (disk_stripe_kb * 2L) => bucket, disk_stripe=%ld, bucket=%d sector=%ld\n", __LINE__, (long)disk_stripe_size_in_kb, bucket, (long)bucket * (long)disk_stripe_size_in_kb * 2L );
	printf( "DBG[%05d]: sector / (disk_stripe_kb * 2L) => bucket, 1 bucket = 0..%ld sectors\n", __LINE__, (long)disk_stripe_size_in_kb * 2L );
        printf( "DBG[%05d]: sector range with current disk_stripe_kb 0...%ld (%ld)\n", __LINE__, (long)MAX_SEGMENT_ENTRIES * (long)disk_stripe_size_in_kb * 2L, max_disk_sector );
	PROG_FEATURE_FAULT(NULL,(typ_disk_stripe *),"bad heatmap state detected", CTL_FAULT_FORCE);
    }
    if ((myseg = (typ_disk_segment *)diskHotSpots.segments.ptr[segment]) == NULL)
    {
	diskHotSpots.segments.ptr[segment] = (void *)malloc(sizeof(typ_disk_segment));
	myseg = (typ_disk_segment *)diskHotSpots.segments.ptr[segment];
	diskHotSpots.segment_cnt++;
	bzero(myseg,sizeof(typ_disk_segment));
    }
    segment_offset = bucket - (segment * MAX_SEGMENT_ENTRIES);
    if ((this = (typ_disk_stripe *)myseg->ptr[segment_offset]) == NULL)
    {
	myseg->ptr[segment_offset] = (void *)malloc(sizeof(typ_disk_stripe));
	this = (typ_disk_stripe *)myseg->ptr[segment_offset];
	diskHotSpots.bucket_cnt++;
	bzero(this,sizeof(typ_disk_stripe));
	this->seeks_in   = -1;	/* signify this is *unused* */
	this->bgn_sector = -1;
	if (diskHotSpots.bucket_cnt > MAX_BUCKET_ALLOC)
        {
	     printf( "%%W[%05d]-Disabling disk hot spot tracking too many buckets allocated (>%d)\n", __LINE__, MAX_BUCKET_ALLOC );
	     diskHotSpots.flags |= DISK_BUCKET_ALLOC_EXCEEDED;
	}
	dprintf( "DBG[%05d]: allocated bucket struct for #%d\n", __LINE__, bucket );
    }
    _return(this);
}


/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
/*
 * Accumulate all counters from buckets into passed in stripe.
 * Creating a summation of data across all active stripe/buckets.
 * Return the count of active stripe/buckets accumulated.
 */
int heatmap_disk_access_sum_stripes( typ_disk_stripe *summ )
{
typ_disk_stripe *this;
typ_disk_segment *myseg;
int segno, ndx;
int active_cnt = 0;

    bzero(summ,sizeof(typ_disk_stripe));
    summ->seeks_in   = -1;	/* signify this is *unused* */ /* only useful for "new" buckets */
#   ifdef DBG_HOTSPOTS
    summ->bgn_sector = -1;      /* so min/max range works   */
#   endif

    summ->seeks_in   =  0;      /* flag as used. duh.       */

    /* Walk segments, any valid, then walk pointers to buckets in that segment structure */
    for (segno=0; segno < MAX_SEGMENT_ENTRIES; segno++ )
    {
	if ((myseg = diskHotSpots.segments.ptr[segno]) == NULL) continue;

        for (ndx=0; ndx < MAX_SEGMENT_ENTRIES; ndx++)
        {
	    if ((this = myseg->ptr[ndx]) == NULL) continue;   /* LBA range had no IO */
	    if (this->seeks_in           ==   -1) continue;   /* LBA range slid into from other bucket, but had no io itself */

	    active_cnt++;

	    summ->seeks_in  += this->seeks_in;
	    summ->seeks_out += this->seeks_out;

	    summ->read_cnt  += this->read_cnt;
            summ->read_req  += this->read_req;
	    summ->read_sec  += this->read_sec;
	    summ->read_q2c  += this->read_q2c;
	    summ->read_d2c  += this->read_d2c;
 	    if (this->read_q2c  < this->read_d2c ) fprintf( outf, "@@@ read q2c %10.2f < %10.2f d2c : building summ for %s write\n", this->read_q2c, this->read_d2c, hotfilename );

	    summ->write_cnt += this->write_cnt;
	    summ->write_req += this->write_req;
	    summ->write_sec += this->write_sec;
	    summ->write_q2c += this->write_q2c;
	    summ->write_d2c += this->write_d2c;
 	    if (this->write_q2c < this->write_d2c) fprintf( outf, "@@@ writ q2c %10.2f < %10.2f d2c : building summ for %s write\n", this->write_q2c, this->write_d2c, hotfilename );

#           ifdef DBG_HOTSPOTS
            if (summ->bgn_sector > this->bgn_sector) summ->bgn_sector = this->bgn_sector;
            if (summ->end_sector < this->end_sector) summ->end_sector = this->end_sector;
#           endif
        }
    }
    return(active_cnt);
}


/**
 * ==========================================================================================
 * Function : process_disk_groups  - process the set of group:devices defined in conf file.
 *            @
 * Args     : @:          none
 *
 * Returns :
 *
 * Description
 * For each group:devices defined within the conf file, call process_group(group-definition)
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int process_disk_groups()
{
typ_conf_group *this;

    this = groups;
    while (this != NULL)
    {
        process_disk_group(this);
        this = this->next;
    }
    return(0);
}



/**
 * ==========================================================================================
 * Function : process_disk_group - merge <devname>.blktrace.merged.hotlba.bin set of files for group
 *                                 then output the combined heatmap for the groupname
 *            @
 * Args     : @group:          point to group configuration data structure
 *
 * Returns :
 *
 * Description
 * the hotlba.bin files are output as processing of each device.blktrace.txt file is performed.
 * This routine attempts to read in the set of device.blktrace.merged.hotlba.bin files for each member
 * of the group.  If it is able to read in *ALL* hotlba -- one for each of the devices in the
 * group -- then it outputs a combined heatmap for the group.  Obviously it won't output one
 * until all individual device.blktrace.txt files have been processed.  So the group hotlba 
 * map is generated only when the last member of the group has been processed.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int process_disk_group(typ_conf_group *group )
{
char datfilename[MAXBUF];
int ndx;
int eof, bucket, segment, entry, offs;
int flg = 0;
int match=0;
int files=0;
int datfd;
int segno;
int active_cnt;
int dbg_bucket_cnt;
typ_disk_segment *myseg;
typ_disk_stripe *this;
typ_disk_stripe *grpsumm;
typ_disk_stripe *devsumm;
typ_disk_stripe  all_disks;
unsigned long readbytes;
int datf_exists[256];
char eflags[16]="?*+        ";
int exists;
FILE *save_outf;
char grpfilename[MAXBUF];


    bzero(datf_exists,sizeof(datf_exists));
    bzero(&all_disks, sizeof(typ_disk_stripe));
    printf( "DBG[%05d]: current device '%s'\n", __LINE__, devicename );
    printf( "DBG[%05d]: process group '%s':%2d ", __LINE__, group->group_name, group->device_cnt );
    for (ndx=0; ndx<group->device_cnt; ndx++)
    {
        if ((strlen(devicename) == strlen(group->devices[ndx].device_name)) && (strcmp(devicename,group->devices[ndx].device_name)==0)) flg=1;
        else flg=0;
        match+=flg;
        exists=0;

        /* check to see if the binary file for this device exists */
        sprintf( datfilename, "%s.blktrace.merged.hotlba.bin", group->devices[ndx].device_name );
        if ((datfd = open( datfilename, O_RDONLY, S_IRWXU)) != -1)
        {
            files++;
            exists++;
            if (ndx<256) datf_exists[ndx] = 1;
            close(datfd);
        }

        printf( "%s%s, ", group->devices[ndx].device_name, ((flg!=0)?"(*)":((exists!=0)?"(!)":"")) );
        if (ndx<256) datf_exists[ndx] += flg;
    }
    printf( "\n" );
    printf( "DBG[%05d]: matches %d, files available %d\n", __LINE__, match, files );
    if ((match == 1) && (files == group->device_cnt))
    {
        printf( "DBG[%05d]: all parts available for this group, this device is in the group.\n", __LINE__ );
    }
    else
        return(0);   /* not in this group */


    /* this device can be in multiple groups, so zero out all stats/buckets before starting */
    /* but leave the allocated buckets in place -- they *will* get reused                   */
    dbg_bucket_cnt = 0;
    for (segno=0; segno < MAX_SEGMENT_ENTRIES; segno++ )
    {
        if ((myseg = diskHotSpots.segments.ptr[segno]) == NULL) continue;
        for (ndx=0; ndx < MAX_SEGMENT_ENTRIES; ndx++ )
        {
            if ((this = myseg->ptr[ndx]) == NULL) continue;
            bzero(this,sizeof(typ_disk_stripe));
            this->seeks_in   = -1;      /* signify this is *unused* */
            this->bgn_sector = -1;
            dbg_bucket_cnt++;
        }
    }
    printf( "DBG[%05d]: starting with %d buckets listed as allocated, found %d\n", __LINE__, diskHotSpots.bucket_cnt, dbg_bucket_cnt );

    save_outf=outf;
    sprintf( grpfilename, "%s.blktrace.group.out", group->group_name );
    if ((outf = fopen( grpfilename, "w" )) == NULL)
    {
        printf( "%%W[%05d]-cannot open '%s' for write access, revert to main output file.\n", __LINE__, grpfilename );
        outf = save_outf;
        save_outf = NULL;
        fprintf( outf, "%%W[%05d]-cannot open '%s' for write access, revert to main output file.\n", __LINE__, grpfilename );
    }
    fprintf( outf, "\n" );
    fprintf( outf, "------------------------------------------------------------------------------------------------------------------------------------------\n");
    fprintf( outf, "--- Totals Per Device  -------------------------------------------------------------------------------------------------------------------\n");
    fprintf( outf, "               |_________Bucket__________| |___Seeks___| |_______________Reads__________________| |________________Writes_________________|\n");
    fprintf( outf, "  Bucket#      bgn sector       end sector     in    out     count  sectors  await(ms)    d2c(ms)      count  sectors  await(ms)    d2c(ms)  requeues\n");


    bzero(group->private,sizeof(typ_disk_stripe));
    grpsumm = (typ_disk_stripe *)group->private;

    /* Do this twice, once for totals and once for averages */
    eof=0;
    for (ndx=0; (eof==0) && (ndx<group->device_cnt); ndx++)
    {
        sprintf( datfilename, "%s.blktrace.merged.hotlba.bin", group->devices[ndx].device_name );
        if ((datfd = open( datfilename, O_RDONLY, S_IRWXU)) != -1)
        {
            if ((readbytes = read( datfd, &hot_header, sizeof( typ_hotbinary_header))) != sizeof(typ_hotbinary_header))
            {
                printf( "%%E[%05d]-binary HotSpots header read failed: %d bytes read, %d requested.\n", __LINE__, readbytes, sizeof(typ_hotbinary_header) );
                eof=2;
                continue;
            }
            else
            {
#               ifdef DBG_HOTSPOTS
                if (diskHotSpots.min_sector > hot_header.diskHotSpots.min_sector) diskHotSpots.min_sector = hot_header.diskHotSpots.min_sector;
                if (diskHotSpots.max_sector < hot_header.diskHotSpots.max_sector) diskHotSpots.max_sector = hot_header.diskHotSpots.max_sector;
#               endif
            }
        } else {eof=1; continue;}

        group->devices[ndx].private = (void *)malloc(sizeof(typ_disk_stripe));
        devsumm = (typ_disk_stripe *)group->devices[ndx].private;
        bzero(devsumm,sizeof(typ_disk_stripe));
        active_cnt = 0;


        for (eof=0; ((readbytes = read( datfd, &hot_entry, sizeof(typ_hotbinary_data))) != 0); )
        {
            if (readbytes != sizeof(typ_hotbinary_data))
            {
                printf( "%%E[%05d]-binary HotSpots record data failed: %d bytes written, %d requested.\n", __LINE__, readbytes, sizeof(typ_hotbinary_data) );
                eof=3;
                break;
            }
            if (hot_entry.rectyp  != RECTYP_HOT_DATA) { printf( "DBG[%5d]: rectyp invalide %08X != %08X\n", __LINE__, hot_entry.rectyp != RECTYP_HOT_DATA); eof=5; break; }

            this = &hot_entry.bucket;
            xprintf( "DBG[%05d]: add bin %6d %16ld-%16ld %6d:%6d  %8d,%8d,%8.2f,%8.2f %8d,%8d,%8.2f,%8.2f \n", __LINE__,
                hot_entry.bucket_number,
                this->bgn_sector, this->end_sector,
                this->seeks_in,   this->seeks_out,
                this->read_cnt,   this->read_sec,  this->read_q2c,  this->read_d2c,
                this->write_cnt,  this->write_sec, this->write_q2c, this->write_d2c );


            /* if seeks_in is -1, then this is an empty bucket and we're only summing active buckets */
            /* this bucket was created due ot an io in previous bucket that ended in this one.       */
            /* but no io actually started in this bucket                                             */
            if (this->seeks_in != -1)
            {
                /* This is per-device summary data */
                active_cnt++;

                devsumm->seeks_in  += this->seeks_in;
                devsumm->seeks_out += this->seeks_out;

                devsumm->read_cnt  += this->read_cnt;
                devsumm->read_req  += this->read_req;
                devsumm->read_sec  += this->read_sec;
                devsumm->read_q2c  += this->read_q2c;
                devsumm->read_d2c  += this->read_d2c;


                devsumm->write_cnt += this->write_cnt;
                devsumm->write_req += this->write_req;
                devsumm->write_sec += this->write_sec;
                devsumm->write_q2c += this->write_q2c;
                devsumm->write_d2c += this->write_d2c;

#               ifdef DBG_HOTSPOTS
                if (devsumm->bgn_sector > this->bgn_sector) devsumm->bgn_sector = this->bgn_sector;
                if (devsumm->end_sector < this->end_sector) devsumm->end_sector = this->end_sector;
#               endif

                grpsumm->seeks_in  += this->seeks_in;
                grpsumm->seeks_out += this->seeks_out;

                grpsumm->read_cnt  += this->read_cnt;
                grpsumm->read_req  += this->read_req;
                grpsumm->read_sec  += this->read_sec;
                grpsumm->read_q2c  += this->read_q2c;
                grpsumm->read_d2c  += this->read_d2c;

                grpsumm->write_cnt += this->write_cnt;
                grpsumm->write_req += this->write_req;
                grpsumm->write_sec += this->write_sec;
                grpsumm->write_q2c += this->write_q2c;
                grpsumm->write_d2c += this->write_d2c;

#               ifdef DBG_HOTSPOTS
                if (grpsumm->bgn_sector > this->bgn_sector) grpsumm->bgn_sector = this->bgn_sector;
                if (grpsumm->end_sector < this->end_sector) grpsumm->end_sector = this->end_sector;
#               endif
            }


            if (hot_entry.bucket_number == -1)
            {
                /* This was a skip or other type of bucket that we don't care about */
                ;
            }
            else
            {
                /* this is per-group:per-bucket summary data */
                bucket = hot_entry.bucket_number;
                segment= heatmap_disk_access_to_segment( bucket );
                this   = heatmap_disk_access_mapbucket( segment, bucket );
                offs   = (bucket - (segment*MAX_SEGMENT_ENTRIES));

                if (diskHotSpots.min_bucket > bucket) diskHotSpots.min_bucket = bucket;
                if (diskHotSpots.max_bucket < bucket) diskHotSpots.max_bucket = bucket;

#               ifdef DBG_HOTSPOTS
                if (this->bgn_sector == -1)
                {
                    this->bgn_sector = (long)bucket     * (disk_stripe_size_in_kb * 2L);
                    this->end_sector = this->bgn_sector + (disk_stripe_size_in_kb * 2L) - 1L;
                }
#               endif

                if (this->seeks_in == -1) this->seeks_in = 0;

                this->seeks_in  += hot_entry.bucket.seeks_in;
                this->seeks_out += hot_entry.bucket.seeks_out;

                this->read_cnt  += hot_entry.bucket.read_cnt;
                this->read_req  += hot_entry.bucket.read_req;
                this->read_sec  += hot_entry.bucket.read_sec;
                this->read_q2c  += hot_entry.bucket.read_q2c;
                this->read_d2c  += hot_entry.bucket.read_d2c;

                this->write_cnt += hot_entry.bucket.write_cnt;
                this->write_req += hot_entry.bucket.write_req;
                this->write_sec += hot_entry.bucket.write_sec;
                this->write_q2c += hot_entry.bucket.write_q2c;
                this->write_d2c += hot_entry.bucket.write_d2c;
            }
        }
        close(datfd);
        /* output per-device summary */
        this = (typ_disk_stripe *)group->devices[ndx].private;
        fprintf( outf, "%8s %16ld-%16ld %6d:%6d  %8d,%8d,%10.2f,%10.2f  %8d,%8d,%10.2f,%10.2f  %8d\n",
            group->devices[ndx].device_name,
                           this->bgn_sector, this->end_sector, this->seeks_in, this->seeks_out,
                           this->read_cnt,   this->read_sec,   this->read_q2c, this->read_d2c,
                           this->write_cnt,  this->write_sec,  this->write_q2c,this->write_d2c, this->read_req+this->write_req );
        this = NULL;
        printf( "DBG[%05d]: ending with %d buckets listed as allocated, found %d\n", __LINE__, diskHotSpots.bucket_cnt, dbg_bucket_cnt );
    }
    /* output per-group summary */
    this = (typ_disk_stripe *)group->private;
    fprintf( outf, "%8s %16ld-%16ld %6d:%6d  %8d,%8d,%10.2f,%10.2f  %8d,%8d,%10.2f,%10.2f  %8d\n",
            group->group_name,
                           this->bgn_sector, this->end_sector, this->seeks_in, this->seeks_out,
                           this->read_cnt,   this->read_sec,   this->read_q2c, this->read_d2c,
                           this->write_cnt,  this->write_sec,  this->write_q2c,this->write_d2c, this->read_req+this->write_req );
    this = NULL;

    /* output averages per-device and total */
    fprintf( outf, "--- Avg ----------------------------------------------------------------------------------------------------------------------------------\n");
    for (ndx=0; (ndx<group->device_cnt); ndx++)
    {
        this = (typ_disk_stripe *)group->devices[ndx].private;
        fprintf( outf, "%8s %16ld-%16ld %6d:%6d  %8d,%8d,%10.2f,%10.2f  %8d,%8d,%10.2f,%10.2f  %8s (avg per io)\n",
            group->devices[ndx].device_name,
                           this->bgn_sector, this->end_sector, this->seeks_in, this->seeks_out,
                           (this->read_cnt == 0)?0:1,
                           (this->read_cnt == 0)?0:(this->read_sec / this->read_cnt),
                           (this->read_cnt == 0)?0.0:(this->read_q2c / (float)this->read_cnt ),
                           (this->read_cnt == 0)?0.0:(this->read_d2c / (float)this->read_cnt ),
                           (this->write_cnt == 0)?0:1,
                           (this->write_cnt == 0)?0:(this->write_sec / this->write_cnt),
                           (this->write_cnt == 0)?0.0:(this->write_q2c / (float)this->write_cnt ),
                           (this->write_cnt == 0)?0.0:(this->write_d2c / (float)this->write_cnt ), " " );
        this = NULL;
    }
    /* output per-group summary */
    this = (typ_disk_stripe *)group->private;
    fprintf( outf, "%8s %16ld-%16ld %6d:%6d  %8d,%8d,%10.2f,%10.2f  %8d,%8d,%10.2f,%10.2f  %8s (avg per io)\n",
            group->group_name,
                           this->bgn_sector, this->end_sector, this->seeks_in, this->seeks_out,
                           (this->read_cnt == 0)?0:1,
                           (this->read_cnt == 0)?0:(this->read_sec / this->read_cnt),
                           (this->read_cnt == 0)?0.0:(this->read_q2c / (float)this->read_cnt ),
                           (this->read_cnt == 0)?0.0:(this->read_d2c / (float)this->read_cnt ),
                           (this->write_cnt == 0)?0:1,
                           (this->write_cnt == 0)?0:(this->write_sec / this->write_cnt),
                           (this->write_cnt == 0)?0.0:(this->write_q2c / (float)this->write_cnt ),
                           (this->write_cnt == 0)?0.0:(this->write_d2c / (float)this->write_cnt ), " " );
    this = NULL;

    /* Out the merged group */
    fprintf( outf, "\n\n");
    fprintf( outf, "------------------------------------------------------------------------------------------------------------------------------------------\n");
    fprintf( outf, "--- Hot LBA Map   ------------------------------------------------------------------------------------------------------------------------\n");
    fprintf( outf, "--- Group: %-16s --------------------------------------------------------------------------------------------------------------\n", group->group_name );
    fprintf( outf, "    Members: ");
    for (ndx=0; ndx<group->device_cnt; ndx++)
        fprintf( outf, "%s(%c) ", group->devices[ndx].device_name, ((ndx<256)?eflags[datf_exists[ndx]]:'-') );
    fprintf( outf, "\n" );
    heatmap_disk_access_dump(conf_disk_group_count_threshold,0);

    show_configuration(outf,1);
    if (save_outf != NULL)
    {
        fclose(outf);
        outf = save_outf;
    }

    return(0);

}



/* SECTION: FUNCTION BLOCK ; STATE TRACKING */
/* ================================================================================================================= */
/* === STATE TRACKING ============================================================================================== */
/* ================================================================================================================= */

/*
 * Track raw counts of event types within input file 
 * Called from parse_event() only.
 */
int state_event_count( typ_event *event )
{
    switch (event->prmact)
    {
        case 'A': state.event_count_remap++;    break;
        case 'Q': state.event_count_queue++;    break;
        case 'S': state.event_count_sleep++;    break;
        case 'G': state.event_count_getrq++;    break;
        case 'M': state.event_count_merge++;    break;
        case 'F': state.event_count_front++;    break;
        case 'I': state.event_count_insert++;   break;
        case 'D': state.event_count_dispatch++; break;
        case 'R': state.event_count_requeue++;  break;
        case 'C': state.event_count_complete++; break;

        case 'P': state.event_count_plug++;     break;
        case 'U': state.event_count_unplug++;   break;
        case 'T': state.event_count_unplug++;
                  state.event_count_timer++;    break;
	case 'X': state.event_count_xsplit++;   break;
	case 'm': state.event_count_message++;  break;
        default : state.event_count_other++ ;
                  printf( "DBG[%05d]: %%W-event count for '%c' skipped\n", __LINE__, event->prmact );
                  break;
    }
    return(0);
}

/* SECTION: FUNCTION BLOCK ; EVENT PROCESSING HELPERS */
/* ================================================================================================================= */
/* === EVENT PROCESSING HELPERS ==================================================================================== */
/* ================================================================================================================= */

/*
int annotate       ( typ_io *io, int  mask  );
int set_event_mask1( typ_io *io, int    action_evtndx      );
int clr_event_mask1( typ_io *io, int    action_evtndx      );
int set_event_mask1( typ_io *io, int    action_evtndx1, int action_evtndx2, int action_evtndx3, int action_evtndx3 );
int clr_event_mask4( typ_io *io, int    action_evtndx1, int action_evtndx2, int action_evtndx3, int action_evtndx3 );
int clr_event_mask ( typ_io *io, char action, int count);
int cnt_event_type ( typ_io *io, char action);
int add_dbg_event  ( typ_io *io, typ_event *this);

* char   *_showmask()             - build a fixed length string with primary event characters if present in the mask
* typ_io *check_2ndhand_merging() - check for 2ndhand merging if D event and no typ_io found yet
* typ_io *check_io_found()        - check to see if this is orphan and take any necessary steps for same
* typ_io *ghost_create()          - create a ghost typ_io/request/context for the current orphan event
*/
int set_event_mask1( typ_io *io, int    action_evtndx      )
{
    _assert( (action_evtndx >= 0) && (action_evtndx <= 15) );
    _assert( io != NULL );

    io->event_mask  |=  1<<action_evtndx;
    io->event_count[       action_evtndx ]++;
    return(io->event_count[action_evtndx ]);
}
int clr_event_mask1( typ_io *io, int    action_evtndx      )
{
    _assert( (action_evtndx >= 0) && (action_evtndx <= 15) );
    _assert( io != NULL );

    io->event_mask  &= ~(1<<action_evtndx );
    io->event_count[        action_evtndx ]--;
    return(io->event_count[ action_evtndx ]);
}
int set_event_mask4( typ_io *io, int action_evtndx1, int action_evtndx2, int action_evtndx3, int action_evtndx4 )
{
    _assert( (action_evtndx1 >= 0) && (action_evtndx1 <= 15) );
    _assert( io != NULL );

    io->event_mask  |=  1<<action_evtndx1;
    io->event_count[       action_evtndx1]++;

    if ((action_evtndx2 >= 0) && (action_evtndx2 <= 15))
    {
        io->event_mask  |=  1<<action_evtndx2;
        io->event_count[       action_evtndx2]++;
    }
    if ((action_evtndx3 >= 0) && (action_evtndx3 <= 15))
    {
        io->event_mask  |=  1<<action_evtndx3;
        io->event_count[       action_evtndx3]++;
    }
    if ((action_evtndx4 >= 0) && (action_evtndx4 <= 15))
    {
        io->event_mask  |=  1<<action_evtndx4;
        io->event_count[       action_evtndx4]++;
    }
    return(0);
}
int clr_event_mask4( typ_io *io, int action_evtndx1, int action_evtndx2, int action_evtndx3, int action_evtndx4 )
{
    _assert( (action_evtndx1 >= 0) && (action_evtndx1 <= 15) );
    _assert( io != NULL );

    io->event_mask  &= ~(1<<action_evtndx1);
    io->event_count[        action_evtndx1]--;

    if ((action_evtndx2 >= 0) && (action_evtndx2 <= 15))
    {
        io->event_mask  &= ~(1<<action_evtndx2);
        io->event_count[        action_evtndx2]--;
    }
    if ((action_evtndx3 >= 0) && (action_evtndx3 <= 15))
    {
        io->event_mask  &= ~(1<<action_evtndx3);
        io->event_count[        action_evtndx3]--;
    }
    if ((action_evtndx4 >= 0) && (action_evtndx4 <= 15))
    {
        io->event_mask  &= ~(1<<action_evtndx4);
        io->event_count[        action_evtndx4]--;
    }
    return(0);
}


char *_showmask(int mask)
{
static char sbuf[4][16];
static int  ndx=0;
char  *buf = &sbuf[(ndx++)&0x3][0];

    ndx = ndx & 0x3;
    strcpy(buf,"..........." );
    if ((mask & EVTMSK_A) != 0) buf[0] = 'A';
    if ((mask & EVTMSK_Q) != 0) buf[1] = 'Q';
    if ((mask & EVTMSK_S) != 0) buf[2] = 'S';
    if ((mask & EVTMSK_G) != 0) buf[3] = 'G';
    if ((mask & EVTMSK_M) != 0) buf[4] = 'M';
    if ((mask & EVTMSK_F) != 0) buf[5] = 'F';
    if ((mask & EVTMSK_R) != 0) buf[6] = 'R';
    if ((mask & EVTMSK_I) != 0) buf[7] = 'I';
    if ((mask & EVTMSK_D) != 0) buf[8] = 'D';
    if ((mask & EVTMSK_C) != 0) buf[9] = 'C';
    if ((mask & EVTMSK_x) != 0) buf[10] = 'x';
    return(buf);
}

/**
 * ==========================================================================================
 * Function : check_2ndhand_merging
 *            @
 * Args       @this:	    current event info
 *          : @io:          existing request address found to match, be the target for, this event
 *          : @eventame:    string of current event name (full)
 *          ; @onmain:      flag of whether on staged (0) or main/active (1)
 * Returns  : io            io structure to be used, if any.
 *
 * Description
 * This function handles policy for any necessary checks for 2nd hand merging: merge two or more
 * existing active io on mainio list into one.  Look for a sector match and length that is less
 * then 'D'ispatch event we're trying to match.  Then look for other existing io on mainio list
 * that start at the end of that match and fill out the 'D' request.  Each time we find a next
 * match, restart the search as requests could be before we're we find the match.  Keep doing
 * this until we have an *exact* match to the 'D'ispatch event.  The set of such io requests on
 * mainio are the set of 2nd hand merges that the scheduler would have done back at the 'M|F' 
 * time that resulted in filling in a hole between to adjacent sorted requests on the scheduler
 * sort queue (or fifo queue for noop scheduler... but that would be a lot more less likely).
 * Since we don't know if the scheduler is going to do this, we cannot pre-emptively look and
 * guess at 'M|F' time -- we need to wait until 'D'ispatch time and be poked/invoked to do it
 * when no match is found.  This still could end up a orphan event that creates a ghost, but
 * we need to cover this corner case first.  Added logic in the search is to guarantee that
 * there is 1 and *only* 1 additional match for 2nd hand (scheduler) merging.  If there are 
 * more than one this will create a fatal:internal logic fault as it is uncertain if a) such
 * a condition exists, and b) what we should do about it if it does. [ if it does the logic
 * might be first match is best match, but until we have one or more data sets that trigger
 * the internal logic fault we won't guess]
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * DBG[00411931] 33128744:33128776 '  8,0    6    14244    24.720548384  1794  A  WS 33128752 + 8 <- (8,2) 32102704'
 * DBG[00411932] 33128744:33128776 '  8,0    6    14245    24.720548583  1794  Q  WS 33128752 + 8 [jbd2/dm-0-8]'
 * DBG[00411933] 33128744:33128776 '  8,0    6    14246    24.720549114  1794  G  WS 33128752 + 8 [jbd2/dm-0-8]'
 * DBG[00411934] 33128744:33128776 '  8,0    6    14247    24.720549730  1794  I  WS 33128752 + 8 [jbd2/dm-0-8]'
 *
 * DBG[00411936] 33128744:33128776 '  8,0    6    14249    24.720555365  1794  A  WS 33128760 + 8 <- (8,2) 32102712'
 * DBG[00411937] 33128744:33128776 '  8,0    6    14250    24.720555536  1794  Q  WS 33128760 + 8 [jbd2/dm-0-8]'
 * DBG[00411938] 33128744:33128776 '  8,0    6    14251    24.720556225  1794  M  WS 33128760 + 8 [jbd2/dm-0-8]'
 * >> ok, this was merged on one above as this is back merge. new length = 16.
 *
 * DBG[00431710] 33128744:33128776 '  8,0    7    50202    26.096735324     0  D  WS 33128752 + 24 [swapper]'  
 * >> but this is 24 sectors long at dispatch, no match found, assumed orphan, ghost created as result...
 * >> which is very very wrong.
 *
 * The issue is prior in the input list there was this:
 * DBG[00411926] 33128744:33128776 '  8,0    6    14239    24.720539741  1794  A  WS 33128768 + 8 <- (8,2) 32102720'  
 * DBG[00411927] 33128744:33128776 '  8,0    6    14240    24.720540496  1794  Q  WS 33128768 + 8 [jbd2/dm-0-8]'
 * DBG[00411928] 33128744:33128776 '  8,0    6    14241    24.720542340  1794  G  WS 33128768 + 8 [jbd2/dm-0-8]'
 * DBG[00411929] 33128744:33128776 '  8,0    6    14242    24.720542707  1794  I  WS 33128768 + 8 [jbd2/dm-0-8]'
 *
 * The *scheduler* merged these two request together while they were on the sorted queue.  The steps were
 * io of 3,1,2.  At io 1 time, it can't be merged onto 3 or vice versa -- there is a hole ('2') between the
 * two so both end up as active io request contexts on the mainio queue.  Then '2' comes along, merges onto
 * '1' and ends up filling the hole between 1 & 3 and the scheduler merges these two requests together out of
 * sight of the event stream.  We have to infer that this happened at 'D'ispatch time when we find a match to
 * sector but not a match to length.  
 *
 *
 * [1] it can happen that we do not find a base io with the starting sector specified within the 
 *     Dispatch if another 2ndhand merge happened at the front of the requests that we have in mainio
 *     that obviously didn't see since it was internal to the scheduler.  This 2ndhand merge changed
 *     the starting sector of the request we have in our mainio list, and that changed sector is what
 *     is in the Dispatch we're trying to match.  This is like 3 nested corner cases so am hoping that
 *     doesn't happen at all or so rarely that we won't see a data set with that type of thing.  But if
 *     or when we do, then we can come up with yet another strategy to ferret it out and glue all the
 *     individual requests we have on our mainio into the one this dispatch is looking for....
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
typ_io *check_2ndhand_merging(typ_event *this, typ_io *in_io, char *eventname, int *onmain)
{
typ_io *temp, *io, *subio, *tmpio;
typ_event *event, *clone;
int rw;
int valid = 0;
long next_sector, length_to_be_covered, len;
int io_ndx, ndx;
int lstndx;
static typ_io *io_2ndhand[256];

    /*
     * This logic only applies if the event is a 'D'ispatch as this
     * is first place we'll see the larger request size and if the 
     * program hasn't found a fully qualified matching io context.
     * Otherwise, just return the io that was passed in.
     *
     * Note: this test could be performed before the call to be more
     * efficient, but for now want it in one place until we know its
     * all stable/works as expected.
     */
    if ((in_io != NULL) || (this->prmact != 'D')) _return(in_io);
    dprintf( "DBG[%05d]: check_2ndhand_merging(%10ld:%6ld)\n", __LINE__, this->sector, this->length );

    /*
     * 1st stage, find 1 and only 1 match against the starting sector with the
     * request length < event length
     */
    TRACE_FUNCTION;
    io = NULL;
    if ((rw = R_OR_W(this))                    >= 0) valid++;
    if ((this->evtflags & EVTFLG_VALID_SECTOR) != 0) valid++;
    if ((this->evtflags & EVTFLG_VALID_SIZE  ) != 0) valid++;
    if (valid != 3) _return( io );

    _assert( io == NULL );

    /* Search mainio/active list for this event -- should be here      */
    /* Go through the mainio list once to find our "base" match, if any*/
    /* The base match will be sector plus everything else *except* len */
    /* The length has to be be less the the current Dispatch event     */ 
    dprintf( "DBG[%05d]: mainio list[%5d]  check for %10ld:%6ld...(base)\n", __LINE__, mainio_on_list, this->sector, this->length );
    for (lstndx=1,temp = mainio_list; temp != (typ_io *)NULL; temp = temp->next, lstndx++)
    {
       d3printf( "DBG[%05d]: mainio list[%5d]  %p %10ld:%6ld...\n", __LINE__, lstndx, temp, temp->sector, temp->length );
       if ( temp->sector != this->sector              ) continue;
       dprintf( "DBG[%05d]: matching sector!\n", __LINE__ );
       if ( temp->length >= this->length              ) continue;
       printf( "DBG[%05d]: mainio list[%5d]  %p %10ld:%6ld... match!\n", __LINE__, lstndx, temp, temp->sector, temp->length );
       if ( R_OR_W(temp)                         != rw) continue; /* not the same (broad) type of io */
       if ((temp->evtflags & EVTFLG_VALID_SECTOR) == 0) continue; /* doesn't have valid sector numb  */
       if ((temp->evtflags & EVTFLG_VALID_SIZE  ) == 0) continue; /* doesn't have valid size   numb  */
       if ( temp->minor  != this->minor               ) continue; /* not the same device             */
       if ( temp->major  != this->major               ) continue; /* not even same major device type */
       printf( "DBG[%05d]: mainio list[%5d]  %p %10ld:%6ld... passed other filters!\n", __LINE__, lstndx, temp, temp->sector, temp->length );
    
       if (io == NULL)
       {
           /* first match! */
           io = temp;
           printf( "DBG[%05d]: mainio list  %p %10ld:%6ld... <= 1st hit\n", __LINE__, temp, temp->sector, temp->length );
       }
       else
       {
           /* @@@TBD - resolve conflicting io for same lba & size */
           /*          which is different than detection overlap  */
           /*          in that overlap can be diff lba+len but    */
           /*          still partially overlap this new one       */
           dprintf( "DBG[%05d]: mainio list  %p %10ld:%6ld... <= 1st hit\n", __LINE__,   io,   io->sector,   io->length );
           dprintf( "DBG[%05d]: mainio list  %p %10ld:%6ld... <= Nth hit\n", __LINE__, temp, temp->sector, temp->length );
	   printf( "DBG[%05d]: %s()\n", __LINE__, __func__ );
           dump_staged_list(__LINE__);
	   dump_mainio_list(__LINE__);
           printf( "%%F[%05d]-tbd, resolve conflict %s in mainio queue, multiple matches for lba+length; [%13.9f] %s %s %10ld:%6ld\n", __LINE__,
		eventname,
		this->timeinfo.time, this->evtact, this->evttyp, this->sector, this->length );
           io = temp;
  	   DATA_FEATURE_FAULT(this,(typ_io *),"2ndhand merging failed",CTL_FAULT_DEFAULT);
        }
    }
    dprintf( "DBG[%05d]: <eol>\n", __LINE__ );
    if (io == NULL) dprintf( "DBG[%05d]: no matching base io @starting sector %08ld:%6ld, return null.\n", __LINE__, this->sector, this->length );
    if (io == NULL) _return( NULL );  /* couldn't even find a base io with starting sector, bummed[1] */

    /* Ok, we *really* only expect to find one more event on the mainio list */
    /* but we could have ended up with a bunch of ghost requests for hole    */
    /* merges that happened because we were unaware of the 2ndhand merging   */
    /* that was happening within the scheduler.  So, worse case we might have*/
    /* 1024/8 or somewhere around 128 requests in the mainio list we need to */
    /* grab and merge into this one base io we found above.  So allow a list */
    /* of 256 typ_io pointers to be on the safe side.  Keep iterating through*/
    /* the following look until either we find no additional matches -or- the*/
    /* specified length of the Dispatch event gets covered.  Terminate the   */
    /* while(1) on either of those two conditions...                         */
    io_ndx = 0;
    bzero(io_2ndhand,sizeof(io_2ndhand));

    io_2ndhand[io_ndx++] = io;
    io->evtflags |= EVTFLG_2NDHAND_MERGE;
    next_sector = io->sector + io->length;
    length_to_be_covered = this->length - io->length;

    while (length_to_be_covered > 0)
    {
	io = NULL;
        printf( "DBG[%05d]: %2d.mainio list[%5d] check for next  %10ld:%6ld...\n", __LINE__, io_ndx, mainio_on_list, next_sector, length_to_be_covered );
        for (lstndx=1,temp = mainio_list; temp != (typ_io *)NULL; temp = temp->next,lstndx++)
        {
	    if ((temp->evtflags & EVTFLG_2NDHAND_MERGE) != 0) continue;

            d3printf( "DBG[%05d]: mainio list[%5d]  %p %10ld:%6ld...\n", __LINE__, lstndx, temp, temp->sector, temp->length );
            if ( temp->sector != next_sector              ) continue;
            printf( "DBG[%05d]: matching sector!\n", __LINE__);
	    if ( temp->length >  length_to_be_covered     ) continue;
            printf( "DBG[%05d]: mainio list[%5d]  %p %10ld:%6ld... match!\n", __LINE__, lstndx, temp, temp->sector, temp->length );
            if ( R_OR_W(temp)                         != rw) continue; /* not the same (broad) type of io */
            if ((temp->evtflags & EVTFLG_VALID_SECTOR) == 0) continue; /* doesn't have valid sector numb  */
            if ((temp->evtflags & EVTFLG_VALID_SIZE  ) == 0) continue; /* doesn't have valid size   numb  */
            if ( temp->minor  != this->minor               ) continue; /* not the same device             */
            if ( temp->major  != this->major               ) continue; /* not even same major device type */
            printf( "DBG[%05d]: mainio list[%5d]  %p %10ld:%6ld... passed other filters!\n", __LINE__, lstndx, temp, temp->sector, temp->length );
    
            if (io == NULL)
            {
                /* first match! */
                io = temp;
                printf( "DBG[%05d]: mainio list  %p %10ld:%6ld... <= 1st hit\n", __LINE__, temp, temp->sector, temp->length );
            }
            else
            {
                /* @@@TBD - resolve conflicting io for same lba & size */
                /*          which is different than detection overlap  */
                /*          in that overlap can be diff lba+len but    */
                /*          still partially overlap this new one       */
                dprintf( "DBG[%05d]: mainio list  %p %10ld:%6ld... <= 1st hit\n", __LINE__,   io,   io->sector,   io->length );
                dprintf( "DBG[%05d]: mainio list  %p %10ld:%6ld... <= Nth hit\n", __LINE__, temp, temp->sector, temp->length );
	        printf( "DBG[%05d]: %s()\n", __LINE__, __func__ );
                dump_staged_list(__LINE__);
	        dump_mainio_list(__LINE__);
                printf( "%%F[%05d]-tbd, resolve conflict %s in mainio queue, multiple matches for lba+length; [%13.9f] %s %s %10ld:%6ld\n", __LINE__,
		    eventname,
		    this->timeinfo.time, this->evtact, this->evttyp, this->sector, this->length );
                io = temp;
		DATA_FEATURE_FAULT(this,(typ_io *),"multiple conflicting matched io",CTL_FAULT_DEFAULT);
            }
        }
        printf( "DBG[%05d]: search for base in mainio concluded, found %p\n", __LINE__, io );
        if (io == NULL) break;

	printf( "DBG[%05d]: add %10ld:%6ld to 2ndhand merge list...\n", __LINE__, io->sector, io->length );
        io_2ndhand[io_ndx++] = io;
        io->evtflags |= EVTFLG_2NDHAND_MERGE;
        next_sector = io->sector + io->length;
        length_to_be_covered -= io->length;
	printf( "DBG[%05d]: length left to cover: %08ld\n", __LINE__, length_to_be_covered );
	_assert( io_ndx < 255 );
	printf( "DBG[%05d]: respin...\n", __LINE__ );
    }
  
    /* clear the temp 2ndhand flag set in evtflags */
    for (temp = mainio_list; temp != (typ_io *)NULL; temp = temp->next)
	temp->evtflags &= ~EVTFLG_2NDHAND_MERGE;


    /* show what was found, if anything            */
    printf( "DBG[%05d]: 2nd Hand Merging detected.  Merge the following requests on mainio into 1!\n", __LINE__ );
    printf( "DBG[%05d]: %2d io on list, %6ld of %6ld length left uncovered\n", __LINE__, io_ndx, length_to_be_covered, this->length );
    for (len=this->length,ndx=0; ndx < io_ndx; ndx++)
    { int cnt;
	if (io_2ndhand[ndx] == NULL)
	    printf( "DBG[%05d]: %2d.[%p] is null.\n", __LINE__, ndx, io_2ndhand[ndx] );
        else
        {
	    len -= io_2ndhand[ndx]->length;
	    printf( "DBG[%05d]: %2d. %10ld:%6ld -> %10ld (remaining: %6ld)\n", __LINE__, 
	        ndx, io_2ndhand[ndx]->sector, io_2ndhand[ndx]->length, (io_2ndhand[ndx]->sector + io_2ndhand[ndx]->length), len );
            printf( "DBG[%05d]:  -- list of events in this io:\n", __LINE__ );
	    dbg_out_events_in_io(io_2ndhand[ndx],stdout);
            printf( "DBG[%05d]:  -- list of subio  in this io:\n", __LINE__ );
	    for (cnt=1,subio=io_2ndhand[ndx]->subio; subio != NULL; subio=subio->subio, cnt++)
	       printf( "DBG[%05d]: %2d.%p %10ld:%6ld\n", __LINE__, cnt, subio, subio->sector, subio->length );
            printf( "DBG[%05d]:  -- end subio --\n\n", __LINE__ );
	}
    }
    printf( "DBG[%05d]: <eol>\n", __LINE__ );

    if (length_to_be_covered > 0) _return(NULL);

    /* Ok, merge all the requests in the array onto the "base" io that has the starting sector number */
    /* This is kind of a bitter pill in that we've pulled the deli ticket numbers to stamp the request*/
    /* and all the events based on the fact that an actual request was created and put into the sched */
    /* Also, each request typically affects inProgress by 1 -- so either we walk those counters back  */
    /* now as we removed requests from the mainio list (which is what the scheduler does), or we add  */
    /* weighted counter into the typ_io that is used to decrement the counters at complete time.  Go  */
    /* with what the scheduler does, decrement inProgress counter now as we peel off requests for 2nd */
    /* hand merging.                                                                                  */
    io = io_2ndhand[0];
    for (ndx=1; ndx<io_ndx; ndx++)
    { int cnt;
	temp = io_2ndhand[ndx];
	printf( "DBG[%05d]: %2d.merge %10ld:%6ld into base io\n", __LINE__, ndx, temp->sector, temp->length);
	/*
         * basically steal the bmerge logic from bmerge_event() as we've added the io 
         * in sector order on the io_2ndhand list...
         */
        if (temp->subio == NULL)
        {
            subio = clone_to_subio(temp); /* create a "subio" structure from a "mainio" */
            add_subio_to_mainio(io,subio," <= add converted subio for 2ndhand merge to base subio list" );
            io->length += subio->length;
            printf( "DBG[%05d]: %2d.merge completed, next!\n", __LINE__, 0 );
        }
	else
	{
	    for (cnt=1, subio = temp->subio; subio != NULL; subio = subio->next, cnt++)
	    {
		printf( "DBG[%05d]: %2d.%p %10ld:%6ld clone subio\n", __LINE__, cnt, subio, subio->sector, subio->length );
		tmpio = clone_to_subio(subio);
		add_subio_to_mainio(io,tmpio," <= move cloned subio for 2ndhand merge to base subio list" );
	    }
            io->length += temp->length;
            printf( "DBG[%05d]: %2d.merge completed, next!\n", __LINE__, cnt );
	}

	/* Any events on the typ_ioinfo list, move over now.  Add flag that there are there due to 2ndhand merge */
#       ifdef DEBUG
	if (temp->info->dbg_num_events != 0)
        {
	    for (event=temp->info->dbg_events; event != NULL; event=event->next)
	    {
	        event->evtflags |= EVTFLG_2NDHAND_MERGE;
		clone = clone_event(event);
                dbg_add_event_to_io(clone, io, __LINE__, "2ndhand merge" );
	    }
	}
#       endif

	/* Ok, if 'temp' has A|Q|S|G|I events from an earlier time, capture  */
        /* them so that the merge io request has accurate longevity info     */
	if ((temp->info->events.first.line != LINENUM_NONE) && 
	    (temp->info->events.first.time < io->info->events.first.time))
	{
	    io->info->events.first.line = temp->info->events.first.line;
	    io->info->events.first.time = temp->info->events.first.time;
	}
	if ((temp->info->events.remap.line != LINENUM_NONE) && 
	    (temp->info->events.remap.time < io->info->events.remap.time))
	{
	    io->info->events.remap.line = temp->info->events.remap.line;
	    io->info->events.remap.time = temp->info->events.remap.time;
	}
	if ((temp->info->events.queue.line != LINENUM_NONE) && 
	    (temp->info->events.queue.time < io->info->events.queue.time))
	{
	    io->info->events.queue.line = temp->info->events.queue.line;
	    io->info->events.queue.time = temp->info->events.queue.time;
	}
	if ((temp->info->events.sleep.line != LINENUM_NONE) && 
	    (temp->info->events.sleep.time < io->info->events.sleep.time))
	{
	    io->info->events.sleep.line = temp->info->events.sleep.line;
	    io->info->events.sleep.time = temp->info->events.sleep.time;
	    io->info->events.sleep_first.line = temp->info->events.sleep_first.line;
	    io->info->events.sleep_first.time = temp->info->events.sleep_first.time;
	    io->info->cnt_sleeps             += temp->info->cnt_sleeps;
	}
	if ((temp->info->events.getrq.line != LINENUM_NONE) && 
	    (temp->info->events.getrq.time < io->info->events.getrq.time))
	{
	    io->info->events.getrq.line = temp->info->events.getrq.line;
	    io->info->events.getrq.time = temp->info->events.getrq.time;
	}
	if ((temp->info->events.insert.line != LINENUM_NONE) && 
	    (temp->info->events.insert.time < io->info->events.insert.time))
	{
	    io->info->events.insert.line = temp->info->events.insert.line;
	    io->info->events.insert.time = temp->info->events.insert.time;
	}

	/* Ok, we're done with this io - move it to done, which also updates the inProgress counts for us */
	move_mainio_to_done(temp);
	temp = io_2ndhand[ndx] = NULL;
    }

    printf( "DBG[%05d]: post merging...\n", __LINE__ );
    { int cnt;
        printf( "DBG[%05d]:  -- subio       --\n", __LINE__ );
	for (cnt=1,subio=io->subio; subio != NULL; subio=subio->subio, cnt++)
	   printf( "DBG[%05d]: %2d.%p %10ld:%6ld\n", __LINE__, cnt, subio, subio->sector, subio->length );
        printf( "DBG[%05d]:  -- subio : end --\n", __LINE__ );
        printf( "DBG[%05d]:  -- events      --\n", __LINE__ );
	dbg_out_events_in_io(io,stdout);
        printf( "DBG[%05d]:  -- events: end --\n\n", __LINE__ );
    }
    printf( "DBG[%05d]: <eol>\n", __LINE__ );

    _assert(this->sector == io->sector);
    _assert(this->length == io->length);

    /* All subio added/merged into base, all event on dbg_events list added */
    /* The inProgress counters adjusted if not ghosted in move to done      */
    /* That should be it!                                                   */
    printf( "DBG[%05d]: io %10ld:%6ld after 2ndhand merging...\n", __LINE__, io->sector, io->length );
    _return(io);
}

/**
 * ==========================================================================================
 * Function : check_io_found
 *            @
 * Args       @this:	    current event info
 *          : @io:          existing request address found to match, be the target for, this event
 *          : @eventame:    string of current event name (full)
 *          ; @onmain:      flag of whether on staged (0) or main/active (1)
 * Returns  : io            io structure to be used, if any.
 *
 * Description
 * This function handles policy for creating ghost requests for orphan events.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
typ_io *check_io_found(typ_event *this, typ_io *io, char *eventname, int *onmain )
{
    if (io != NULL) return(io);
    TRACE_FUNCTION;

    /* OK, the code did not find a suitable io on any of the lists it looked on */
    /* The 'this' event needs a request (typ_io) target to absorb the event     */

    /* First output appropriate events showing we didn't find expected request  */

    /* Not on either list! Better be near top of input list then... */
    /* @@@TBD: Note, event max lines, max events is insufficient to properly screen "orphan" C events */
    /*   8,0   10       93     0.166105929     0  C  WS 2174580848 + 8 [0]
     *   %E[06257]-could not find 'main' io request to completion       2174580848:       8 into @  8,0   10       93     -
     *       0.166105929     0  C  WS 2174580848 + 8 [0], discarding; line=4408 (limit=400), QEvents=888 (limit=200)
     *                                                                ^over limit            ^over limit
     * ...but note the time, 0.16610 or 166ms into the events logged.  So, we may need a third .or. "this"
     * qualifier where "this" is a number of ms into the running event list.  Really event 500-750ms *should* be enough
     * of a limit, but clearly this was a super busy system which flooded the output log with partial/tail-end events
     * which the program didn't expect to see some 4400+ lines and ~900 Q events later... almost 900 new io have been
     * started and the output event list is still occassionaly having orphan C events for I/O that was dispatched before
     * the event logging was started.
     */
    if ((state.line < MAX_TOP_OF_FILE_LINES) || (state.QSeqNo < MAX_TOP_OF_FILE_QEVENTS))
    {
        printf( "%%W[%05d]-could not find 'main' io request to %s %16lu:%8d into @%s, line=%d (limit=%d), Qevents=%d (limit=%d) [near bgn file|event]\n", __LINE__, eventname,
            this->sector, this->length, state.inpline, state.line, MAX_TOP_OF_FILE_LINES, state.QSeqNo, MAX_TOP_OF_FILE_QEVENTS );
        dbg_lineno = __LINE__;
	/* This should qualify for a discard, but lets do that only if this is a 'C' event */
	if (this->prmact == 'C')
	    this->evtflags |= (EVTFLG_DISCARDED | EVTFLG_EXCEPTION); /* multi-char event type and too long for field */
        annotate_event(this,1,NULL);  /* skipping this one as likely just missing parts of io we want to merge into */
    }
    else
    {
	/* Inhibit the following error if its for a '@vMergeHole' event */
        /* Such an event is injected into the event stream to cover a   */
	/* hole in a discard's dispatch length range due to missing A,Q */
	/* references.  This means that the 'M'erge event is not against*/
        /* a pre-existing io context and so a ghost context will be     */
        /* created to allow processing to work correctly.  So if we do  */
        /* need to inject a merge for a hole in a discard, the ghost is */
        /* expected, so inhibit the reporting of the %Error in output   */
	if (strncmp(this->procname, "[@vMergeHole]", 13) != 0) 
          printf( "%%E[%05d]-could not find 'main' io request to %s %16lu:%8d into @%s, discarding; line=%d (limit=%d), QEvents=%d (limit=%d)\n", __LINE__, eventname,
            this->sector, this->length, state.inpline, state.line, MAX_TOP_OF_FILE_LINES, state.QSeqNo, MAX_TOP_OF_FILE_QEVENTS );
        if (conf_orphan_event_policy == 0)
	{
	    /* do not allow orphans at all			  */ 
            printf( "%%F[%05d]-tbd, missing feature, orphans not allowed via conf_orphan_event_policy=%d.\n", __LINE__, conf_orphan_event_policy );
	    MISS_FEATURE_FAULT(this,(typ_io *),"orphans are not allowed vai conf_orphan_event_policy",CTL_FAULT_DEFAULT);
	} 
	if (conf_orphan_event_policy == 1)
 	{	
	    /* This is the default policy set at program level in absense of value in .conf file */
	    if (strncmp(this->procname, "[@vMergeHole]", 13) != 0) 
	    {
	        /* See notes above on why the code is suppressing this error */
	        output_key_header();
                fprintf( outf, " %%E[%05d]-orphan %s event detected, discarding '%s'; line=%d (limit=%d), QEvents=%d (limit=%d)\n", __LINE__, eventname,
                   state.inpline, state.line, MAX_TOP_OF_FILE_LINES, state.QSeqNo, MAX_TOP_OF_FILE_QEVENTS );
	    }
        }
        /* conf_orphan_event_policy > 1 ; silent */
    }

    /* Ok, policy is to allow ghost creation, if possible              */
    /* create ghost request on appropriate queue and return io address */
    /* With some events, like C, a ghost will not be created and we're */
    /* returning a null request.                                       */
    io = ghost_create(this,GHOST_1STHAND,onmain);
    exceptionevent(this,__LINE__, (io!=NULL)?"detected as orphan event, forced  ghost request creation":
				             "detected as orphan event, skipped ghost request creation" );
    _return(io);
}
/**
 * ==========================================================================================
 * Function : ghost_create
 *            @
 * Args       @this:	    current event info
 *          : @flag:        whether this is first hand or second hand creation request
 *          : @onmain:      whether created ghost was placed on staged (0) or main(1)
 * Returns  : io            io structure to be used, if any.
 *
 * Description
 * This function handles creating ghost requests for orphan events.  
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * -----------------------------------------------------------------------------------------------
 * flag = 1STHAND means we are creating a ghost directly for 'this' event.
 *      = 2NDHAND only happens when we get an M|F and there is no prior mainio event found as
 *        the target to absorb this merge event.  In that case, the ghost we're creating is
 *        indirectly for this event... and the actual sector:length of the mainio request
 *        we're about to create is unknown.  So corner case of a corner case.
 *
 * -----------------------------------------------------------------------------------------------
 *  When create_io() is called herein, it normally will fill in the event info from 'this' event,
 *  by setting the EVTFLG_GHOST flag on the event, this behavior is inhibited.  This helps protect
 *  against downstream affects -- for example we create a ghost for an orphan I event and when we
 *  return the code, before updating the mainio/request block verifies that no prior I events have
 *  occurred. Such guard checks would fail is we captured 'this' event data here vs downstream
 *  after returning from this function.
 *
 * -----------------------------------------------------------------------------------------------
 * Also, first and foremost -- EVERY *blktrace.txt for results in ghost requests being created should be carefully
 * manually analyzed to verify that ghost creation is warranted.
 *
 * A|Q S|G|I  M|F D|R C -- I *think* that is all the cases.
 *
 * A|Q   - no dummy needed as these trigger request to be created on staged
 * S|G|I - create a dummy, flag dummy, set dummy "gradiate" at S|G|I, and set request start time at current event time
 *         + the problem with I is we can't know if this is {A|Q|S|G|I|D|R}...I -- that is the I we're seeing is insert
 *           post requeue.  So I gradiates are much more suspect than S or G.  However, the number of I due to R should
 *           be a corner case so while possible, it is much lower probability.  But we should flag all ghosts forced by
 *           I events to include a warning to this affect (could be corner case post-R).
 * M|F   - create a dummy, flag dummy, set dummy "gradiate" at M|F which is near equivalent to S|G|I, ditto setup of dummy
 *         + however, M|F is the one case that it not only has to find its staged request structure, it then has to find
 *           a 2nd mainio request structure that it will be merged into and *THAT* request might not exist.  So how to 
 *           dummy that up and flag it.  Especially then we can have a C event that more than covers this BIO within the
 *           request.  Also, this logic can end up fracturing via creation of multiple requests when really only 1 exists.
 *           So a C comes along and it really only applies to one request, but the program has dummied up several mainio
 *           requests with disjointed BIO that in truth are all under this other request -- we just don't know it because
 *           we never saw the original BIO that all later BIO were glommed onto.  For example Q and then Q2|M2 but primary
 *           Q not seen so create request for Q2M2 to merge into, results req2 only has this BIO.  Then Q3|F3 happen. Again
 *           no primary exists a new request created/dummied and now we have two dummied requests which really should only
 *           be 1.  Then a C event comes along covering req3, missing request, req2.  This becomes a very complicated case
 *           to deal with -- we'd need to not only allow 1 C to cover multiple requests if those requests were dummied up,
 *           but actively encourage doing so.  For efficiency purposes we should keep a count of the number of ghost requests
 *           created, and number that have been completed and output.  That way if the diff between the two is zero, no
 *           ghosts exist and the code *may* be able to not have to check on corner cases as much.  This type of complication
 *           only exists for M|F and only where the original request the merge is trying to target does not exist.  In this
 *           particular example above it won't happen because we'll have created a request ghost at the G event for that request
 *           that is missing A|Q.
 * D|R    - create a ghost/dummy request, flag dummy, set dummy gradiate to D|R 
 *
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
static int isBarrier(typ_event *this)
{
    /* Start out simply.  Must be WS 0:0 */
    if (this->prmact != 'C') return(0);
    if (this->sector != 0L ) return(0);
    if (this->length != 0L ) return(0);
    if ((strcmp(this->evttyp, "WS") != 0) || (strlen(this->evttyp) != 2)) return(0);
    return(1);
}

/*
 * NOTE: This is the only place that should set EVTFLG_GHOST! 
 */
typ_io *ghost_create(typ_event *this, int flg, int *onmain )
{
char reason[256];
char iotype[256];
char event_type='F';
int gradiant = 0;
typ_io *io = NULL;

    TRACE_FUNCTION;
    if (conf_ghost_policy == 0)
    {
	sprintf( reason, "internal logic fault, conf_ghost_policy=%d: ghost creates disallowed. Exit.", conf_ghost_policy );
	PROG_FEATURE_FAULT(this,(typ_io *),"conf_ghost_policy disallows ghosts",CTL_FAULT_FORCE);
    }

    /* We're going to do slightly different things for the different events */
    this->evtflags |= EVTFLG_GHOST;
    switch (this->prmact)
    {
	case 'A': PROG_FEATURE_FAULT(this,(typ_io *),"internal logic fault, should not create ghosts for A|Q events!",CTL_FAULT_FORCE);
		  break;

	case 'S': if (gradiant == 0) gradiant = GHOST_S_EVT;
        case 'G': if (gradiant == 0) gradiant = GHOST_G_EVT;
		  dprintf( "DBG[%05d]: create ghost, trigger is '%c' event: '%s'\n", __LINE__, this->prmact, state.inpline );
		  io = create_io(this);
		  io->evtflags |= EVTFLG_GHOST;
		  io->ghost_gradiant = gradiant;
		  /* Fill-in prior missing events, just Q event here */
                  io->event_mask                   |= EVTMSK_Q; /* @@ */
		  set_event_mask( io,                 EVTNDX_Q );
                  io->info->events.queue.line       = LINENUM_GHOST;
                  io->info->events.queue.time       = this->timeinfo.time;
		  add_io_to_mainio(io);
		  *onmain = 1;
		  /* Update state info for tracking ghosts */
		  state.ghosts_created++;
		  this->evtflags &= ~EVTFLG_GHOST;
		  _return(io);

	case 'F': if (gradiant == 0) gradiant = GHOST_F_EVT;
	case 'M': if (gradiant == 0) gradiant = GHOST_M_EVT;
		  dprintf( "DBG[%05d]: create ghost, trigger is '%c' event: '%s'\n", __LINE__, this->prmact, state.inpline );
		  io = create_io(this);
		  io->evtflags |= EVTFLG_GHOST;
		  io->ghost_gradiant = gradiant;
		  /* Fill-in prior missing events, just Q event here */
                  io->event_mask                   |= EVTMSK_Q; /* @@ */
		  set_event_mask( io,                 EVTNDX_Q );
                  io->info->events.queue.line       = LINENUM_GHOST;
                  io->info->events.queue.time       = this->timeinfo.time;
		  add_io_to_staged(io);
		  *onmain = 0;
		  /* Update state info for tracking ghosts */
		  state.ghosts_created++;
		  this->evtflags &= ~EVTFLG_GHOST;
		  _return(io);

	case 'I': /* This is tricky one.  The I could be *after* a requeue */
		  /* In that case the Q time is not "nearby", but otherwise*/
	          /* it is.  Since requeues should be a less often event,  */
		  /* still go ahead and set Q time as if it was recent and */
		  /* no requeues (which we have no visibility into since   */
		  /* this is first orphan event for this request) have     */
		  /* occurred prior to the program finding this 'I' event  */ 
		  dprintf( "DBG[%05d]: create ghost, trigger is '%c' event: '%s'\n", __LINE__, this->prmact, state.inpline );
		  io = create_io(this);
		  io->evtflags |= EVTFLG_GHOST;
		  io->ghost_gradiant = GHOST_I_EVT;
		  /* Fill-in prior missing events, just Q event here */
                  io->event_mask                   |= EVTMSK_Q; /* @@ */
		  set_event_mask( io,                 EVTNDX_Q );
                  io->info->events.queue.line       = LINENUM_GHOST;
                  io->info->events.queue.time       = this->timeinfo.time;
		  add_io_to_mainio(io);
		  *onmain = 1;
		  /* Update state info for tracking ghosts */
		  state.ghosts_created++;
		  this->evtflags &= ~EVTFLG_GHOST;
		  _return(io);
	
	case 'R': if (gradiant == 0) gradiant = GHOST_R_EVT;
	case 'D': if (gradiant == 0) gradiant = GHOST_D_EVT;
		  dprintf( "DBG[%05d]: create ghost, trigger is '%c' event: '%s'\n", __LINE__, this->prmact, state.inpline );
		  io = create_io(this);
		  io->evtflags |= EVTFLG_GHOST;
		  io->ghost_gradiant = gradiant;
		  /* Fill-in prior missing events, Q|I events here */
                  io->event_mask                    |= EVTMSK_Q; /* @@ */
		  set_event_mask( io,                  EVTNDX_Q );
                  io->info->events.queue.line        = LINENUM_GHOST;
                  io->info->events.queue.time        = this->timeinfo.time;

                  io->event_mask                    |= EVTMSK_I;/* @@ */
		  set_event_mask( io,                  EVTNDX_I );
                  io->info->events.insert.line       = LINENUM_GHOST;
                  io->info->events.insert.time       = this->timeinfo.time;

                  io->info->events.insert_first.line = LINENUM_GHOST;
                  io->info->events.insert_first.time = this->timeinfo.time;
		  add_io_to_mainio(io);
		  *onmain = 1;
		  /* Update state info for tracking ghosts */
		  state.ghosts_created++;
		  this->evtflags &= ~EVTFLG_GHOST;
		  _return(io);

	case 'C': /* Whelp, nothing can be done here as this *should* be final event(s) for a request we don't have */
		  /* Log and discard the event (by which is meant return null for io)                               */
		  if (!isBarrier(this))
		  {
		      event_type='E';
                      if ((state.line < MAX_TOP_OF_FILE_LINES) || (state.QSeqNo < MAX_TOP_OF_FILE_QEVENTS))
		          event_type='W';
		      strcpy(iotype,"event  ");
		  }
		  else
		  {
		      /* is orphan "barrier" type command like "C  WS 0 [0]" -- completion of a write/sync at sector 0 with 0 length */
                      /* yup, that would be a barrier io, write 0:0 is the key no data to be written.                                */
		      event_type='W';
		      strcpy(iotype,"barrier");
		  }
		  output_key_header();
		  /* @@@TBD design better */
		  /* inhibit these if this->imbtyp is non-zero, we'll likely find a match in code below */
		  if (this->imbtyp == IMBTYP_NONE)
		  {
                  fprintf( outf, " %%%c[%05d]-orphan 'C'ompletion %s discarded          %16lu:%8d from '%s' discard at line=%d (limit=%d), QEvents=%d (limit=%d)\n",
			event_type, __LINE__, iotype, this->sector, this->length, state.inpline,
			state.line, MAX_TOP_OF_FILE_LINES, state.QSeqNo, MAX_TOP_OF_FILE_QEVENTS );
		  }
                   printf(        "%%%c[%05d]-orphan 'C'ompletion %s discarded          %16lu:%8d from '%s' discard at line=%d (limit=%d), QEvents=%d (limit=%d)\n",
			event_type, __LINE__, iotype, this->sector, this->length, state.inpline,
			state.line, MAX_TOP_OF_FILE_LINES, state.QSeqNo, MAX_TOP_OF_FILE_QEVENTS );
		  _return(NULL);

	default  : printf( "%%F[%05d]-fatal internal logic fault, request for ghost on '%c' event.\n", __LINE__, this->prmact );
		   MISS_FEATURE_FAULT(this,(typ_io *),"ghosts not processed for this event type",CTL_FAULT_DEFAULT);
		   break;
    }
    PROG_FEATURE_FAULT(NULL,(typ_io *),"internal logic fault:should not get here!",CTL_FAULT_FORCE);
}



/**
 * ==========================================================================================
 * Function : search_staged1 
 *            @
 * Args       @this:	    current event info
 *          : @eventname:   char string of event name
 *            @lineno:      routine line number calling this routine (diag purposes)
 * Returns  : io            io structure found matching 'this' event, if any, null otherwise
 *
 * Description
 * Search the staged list of io for a match to this event
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
typ_io *search_staged1(typ_event *this,char *eventname, int lineno )
{
typ_io *temp, *io, *best, *xsplit;
int rw;

    TRACE_FUNCTION;
    xsplit = NULL;
    io = NULL;
    rw = R_OR_W(this);
    for (temp = staged_list; temp != (typ_io *)NULL; temp = temp->next)
    {
        /* Look 1st for matching lba+len 		*/
        /* d1printf( "DBG[%05d]: stage list %10ld:%6ld %p\n", __LINE__, temp->sector, temp->length, temp ); */
        d3printf( "DBG[%05d]: stage list %12ld:%6ld %p | [%08d] %13.9f %-4s %-4s \n", __LINE__, temp->sector, temp->length, temp,
	    temp->timeinfo.line, temp->timeinfo.time, temp->evtact, temp->evttyp );

        if ( temp->sector != this->sector                  ) continue;
        if ( temp->length != this->length                  ) continue;
	d1printf( "DBG[%05d]: stage list %12ld:%6ld %p matched!\n", __LINE__, temp->sector, temp->length, temp );
        nprintf( "DBG[%05d]: stage list rw %d flg %04X %d,%d %4d :: %4s %d,%d %4s flg %d rw\n", __LINE__,
		R_OR_W(temp), temp->evtflags, temp->major, temp->minor, temp->info->events.queue.line,
	        " ", this->major, this->minor, " ", rw );
        if ( R_OR_W(temp)                         != rw) continue; /* not the same (broad) type of io */
        if ((temp->evtflags & EVTFLG_VALID_SECTOR) == 0) continue; /* doesn't have valid sector numb  */
        if ((temp->evtflags & EVTFLG_VALID_SIZE  ) == 0) continue; /* doesn't have valid size   numb  */
	if ( temp->minor  != this->minor               ) continue; /* not the same device             */ 
        if ( temp->major  != this->major               ) continue; /* not even same major device type */

	/* One final 4.18'ism filter								      */
	/* Only allow 1 match to xplit								      */
	if (conf_xsplits != CFG_XSPLITS_PRESENT)
	{
	    if (xsplit == NULL) xsplit = temp; else xsplit = NULL;
	    if (((temp->specials & SPCFLG_XPARENT)     != 0 ) &&
	         (temp->major                          ==253))continue; /* dm- device and XPARENT set      */
	}

	d1printf( "DBG[%05d]: stage list %12ld:%6ld %p passed filters!\n", __LINE__, temp->sector, temp->length, temp );

	if (io == NULL)
	{
                io = temp;
                d1printf( "DBG[%05d]: staged list  %p %12ld:%6ld... <= 1st hit\n", __LINE__, temp, temp->sector, temp->length );
        }
        else
        {
	    /* @@@TBD - temporarily try and resolve conflicts due  */
	    /*          to LV splits, enough splits and there is   */
	    /*          no C events ever.  In that case prevent C  */
	    /*          event matching to X *if* the later event   */
	    /*          only is a Q event.                         */
	    if ((io->major == 253) &&
	        ((io->specials & SPCFLG_XPARENT) == 0) &&
	        ((io->specials & SPCFLG_XTARGET) != 0))
	    {
	    	/* Then the first io seems to be a good choice, unless the */
	        /* temp event is a Q event w/o X event in the mask and the */
	        /* time of the Q event is later than the X event ... then  */
	        /* likely the whole X-split chain was orphaned.            */
		printf( "DBG[%05d]: Completion conflict detected between X-splits and later Q event in LV device\n", __LINE__ );
                printf( "DBG[%05d]: staged list  %p %12ld:%6ld %2d %c %04X... <= Nth hit\n", __LINE__,   temp, temp->sector, temp->length, 
			    temp->xsplit_level, temp->prmact, temp->specials );
                printf( "DBG[%05d]: staged list  %p %12ld:%6ld %2d %c %04X... <= 1st hit\n", __LINE__, io, io->sector, io->length,
			    io->xsplit_level, io->prmact, io->specials );
	        if (( temp->major == 253) &&
		    ((temp->event_mask & EVTMSK_X) == 0) &&
		    ( temp->timeinfo.time > io->timeinfo.time))
		{
		    /* Use the later Q event 				   */
		    /* but first dump out the whole X-split io chain       */
		    printf( "DBG[%05d]: Completion conflict detected between X-splits and later Q event in LV device\n", __LINE__ );
                    printf( "DBG[%05d]: staged list  %p %10ld:%6ld %2d %c %04X... <= Nth hit\n", __LINE__,   temp, temp->sector, temp->length, 
			    temp->xsplit_level, temp->prmact, temp->specials );
		    while (io->xparent != NULL)
		    {
                        printf( "DBG[%05d]: staged list  %p %10ld:%6ld %2d %c %04X... <= 1st hit\n", __LINE__, io, io->sector, io->length,
			    io->xsplit_level, io->prmact, io->specials );
			io = io->xparent;
		    }
		    io = temp;
		}
	    }
	    if (io != temp)
	    {
            /* @@@TBD - resolve conflicting io for same lba & size */
            /*          which is different than detection overlap  */
            /*          in that overlap can be diff lba+len but    */
            /*          still partially overlap this new one       */
            d1printf( "DBG[%05d]: staged list  %p %12ld:%6ld... <= 1st hit\n", __LINE__,   io,   io->sector,   io->length );
            d1printf( "DBG[%05d]: staged list  %p %12ld:%6ld... <= Nth hit\n", __LINE__, temp, temp->sector, temp->length );
	    printf( "DBG[%05d]: %s()\n", __LINE__, __func__ );
            dump_staged_list(__LINE__);
	    dump_mainio_list(__LINE__);
	    if ((best = best_match(this,io,temp)) != NULL) io = best;
	    }
        }
    }
    if ((io == NULL) && (xsplit != NULL))
    {
        state.xsplit_match_count++;
	printf( "%%W[%05d]: cnt=%4d staged matched to xsplit io %p:[%ld:%ld] at line %d when not expecting to, using this match\n", __LINE__, state.xsplit_match_count,
		xsplit, xsplit->sector, xsplit->length, state.line );
	if (state.xsplit_match_count == 1000)
	    logHprintf( "%%I[%05d]: recommended to add -XX option to command line!\n", __LINE__ );
	io = xsplit;
    }
    return(io);
}

/**
 * ==========================================================================================
 * Function : search_staged2 
 *            @
 * Args       @this:	    current event info
 *          : @eventname:   char string of event name
 *            @lineno:      routine line number calling this routine (diag purposes)
 * Returns  : io            io structure found matching 'this' event, if any, null otherwise
 *
 * Description
 * **USED FOR X SPLIT EVENTS ONLY**
 * Search the staged list of io for a match to this event
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * Used for X Split event matching.  These only have a starting sector, not a length.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
typ_io *search_staged2(typ_event *this,char *eventname, int lineno )
{
typ_io *temp, *io, *best;
int reject;
int rw;
int len = this->length - this->sector;		/* Found io must be at least this big */

    TRACE_FUNCTION;
    io = NULL;
    rw = R_OR_W(this);

    /* 1.  253,470 122    14377    17.252122378 1343941  X   W    307342496 / 307342592 [kworker/u291:3]  << size of difference between these to numbers.	*/
    /* 2.    8,96    6     3241    22.305786048 1621409  X   W 201980276200 / 116813800 [kworker/u18:2]   << size is unknown until 'G' event, diff ref bases	*/
    if ((len <= 0) || ( len > MAX_IO_SIZE))
    {
        /* The base refrence in the event for the two sectors are not 'disk absolute' */
	/* The second is some other referenced base, cannot calculate a size          */
	/* Default to MAX_IO_SPLIT_SIZE for now					      */
	len = MAX_IO_SPLIT_SIZE;
    }

    reject = 0;
    for (temp = staged_list; temp != (typ_io *)NULL; temp = temp->next)
    {
        /* Look 1st for matching lba+len 		*/
	if (reject != 0) d1printf( "DBG[%05d]: stage list rejected rsn %d\n", __LINE__, reject );
        d1printf( "DBG[%05d]: stage list %12ld:%10ld %p | [%08d] %13.9f %-4s %-4s \n", __LINE__, temp->sector, temp->length, temp,
	    temp->timeinfo.line, temp->timeinfo.time, temp->evtact, temp->evttyp );
        if ( temp->sector != this->sector                  ) continue;
        if ( temp->length <  len                           ) continue;
	d1printf( "DBG[%05d]: stage list %12ld:%10ld %p matched!\n", __LINE__, temp->sector, temp->length, temp );
         nprintf( "DBG[%05d]: stage list rw %d flg %04X %d,%d %4d :: %4s %d,%d %4s flg %d rw\n", __LINE__,
		R_OR_W(temp), temp->evtflags, temp->major, temp->minor, temp->info->events.queue.line,
	        " ", this->major, this->minor, " ", rw );
        if ( R_OR_W(temp)                         != rw) { reject = 1; continue; /* not the same (broad) type of io */ }
        if ((temp->evtflags & EVTFLG_VALID_SECTOR) == 0) { reject = 2; continue; /* doesn't have valid sector numb  */ }
        if ((temp->evtflags & EVTFLG_VALID_SIZE  ) == 0) { reject = 3; continue; /* doesn't have valid size   numb  */ }
	if ( temp->minor  != this->minor               ) { reject = 4; continue; /* not the same device             */ }
        if ( temp->major  != this->major               ) { reject = 5; continue; /* not even same major device type */ }
	if(((temp->specials & SPCFLG_XPARENT)      != 0) &&
           ((temp->specials & SPCFLG_XPARENT2)     == 0)){ reject = 6; continue; /* don't allow main/1st/parent io to be split twice */ }

	d1printf( "DBG[%05d]: stage list %10ld:%6ld %p passed filters!\n", __LINE__, temp->sector, temp->length, temp );

	if (io == NULL)
	{
                io = temp;
                d1printf( "DBG[%05d]: stage list  %p %10ld:%6ld... <= 1st hit\n", __LINE__, temp, temp->sector, temp->length );
        }
        else
        {
            /* @@@TBD - resolve conflicting io for same lba & size */
            /*          which is different than detection overlap  */
            /*          in that overlap can be diff lba+len but    */
            /*          still partially overlap this new one       */
            d1printf( "DBG[%05d]: staged list  %p %10ld:%6ld... <= 1st hit\n", __LINE__,   io,   io->sector,   io->length );
            d1printf( "DBG[%05d]: staged list  %p %10ld:%6ld... <= Nth hit\n", __LINE__, temp, temp->sector, temp->length );
	    printf( "DBG[%05d]: %s()\n", __LINE__, __func__ );
            dump_staged_list(__LINE__);
	    dump_mainio_list(__LINE__);
	    _EXIT( printf( "%%F[%05d]-fatal, split_event(%ld,%ld) found more than 1 match!\n", __LINE__) );

	    if ((best = best_match(this,io,temp)) != NULL) io = best;
        }
    }
    if (reject != 0) d1printf( "DBG[%05d]: stage list rejected rsn %d\n", __LINE__, reject );
    d1printf( "DBG[%05d]: stage list  %p returned.\n", __LINE__, io );
    return(io);
}


/**
 * ==========================================================================================
 * Function : search_mainio1 - find matching sector:length on mainio list
 *            @
 * Args       @this:	    current event info
 *          : @eventname:   char string of event name
 *            @lineno:      routine line number calling this routine (diag purposes)
 * Returns  : io            io structure found matching 'this' event, if any, null otherwise
 *
 * Description
 * Search the mainio list of io for a match to this event -- this is "normal" search in
 * that we're looking for a direct match between sector:lenght in 'this' vs an io on mainio list
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * There are other variants of searches, specifically bmerge and fmerge use different criteria
 * to match between this and current/active mainio contexts.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
typ_io *search_mainio1(typ_event *this, typ_io *in_io, char *eventname, int *onmain)
{
int rw;
int lstndx;
typ_io *io, *temp, *best;

    if (in_io != NULL) _return(in_io);  /* @@@shouldn't require this, function should only be called when don't have io yet */

    TRACE_FUNCTION;
    io = NULL;
    rw = R_OR_W(this);
    d1printf( "DBG[%05d]: mainio list[%5d]  check for %10ld:%6ld match for %s...\n", __LINE__, mainio_on_list, this->sector, this->length, eventname );
    for (lstndx=1, temp = mainio_list; temp != (typ_io *)NULL; temp = temp->next, lstndx++)
    {
        d3printf( "DBG[%05d]: mainio list[%5d]  %p %10ld:%6ld...\n", __LINE__, lstndx, temp, temp->sector, temp->length );
        if ( temp->sector != this->sector              ) continue;
        if ( temp->length != this->length              ) continue;
        d1printf( "DBG[%05d]: mainio list[%5d]  %p %10ld:%6ld... match!\n", __LINE__, lstndx, temp, temp->sector, temp->length );
        if ( R_OR_W(temp)                         != rw) continue; /* not the same (broad) type of io */
        if ((temp->evtflags & EVTFLG_VALID_SECTOR) == 0) continue; /* doesn't have valid sector numb  */
        if ((temp->evtflags & EVTFLG_VALID_SIZE  ) == 0) continue; /* doesn't have valid size   numb  */
        if ( temp->minor  != this->minor               ) continue; /* not the same device             */
        if ( temp->major  != this->major               ) continue; /* not even same major device type */
        d1printf( "DBG[%05d]: mainio list[%5d]  %p %10ld:%6ld... passed other filters!\n", __LINE__, lstndx, temp, temp->sector, temp->length );

        if (io == NULL)
        {
            /* first match! */
            io = temp;
            *onmain = 1;
            d1printf( "DBG[%05d]: mainio list  %p %10ld:%6ld... <= 1st hit\n", __LINE__, temp, temp->sector, temp->length );
        }
        else
        {
            /* @@@TBD - resolve conflicting io for same lba & size */
            /*          which is different than detection overlap  */
            /*          in that overlap can be diff lba+len but    */
            /*          still partially overlap this new one       */
            if (((io->sector != 0) && (io->length != 0)) || (flag_debug >=1 ))
	    { int save_flag = -1;
		/* Detected non-barrier duplicate io | forced 	  */
	        logEprintf( "\n%%E[%05d]-%s() duplicate io detected, same [Sect:Len] at line %d, procesing '%c'\n", __LINE__, __func__, state.line, this->prmact );
                logEprintf( "%%E[%05d]-mainio list  %p[%10ld:%6ld] %9.6f line %8d... <= 1st hit\n", __LINE__, io  , io->sector,  io->length,   io->timeinfo.time,  io->timeinfo.line);
                logEprintf( "%%E[%05d]-mainio list  %p[%10ld:%6ld] %9.6f line %8d... <= Nth hit\n", __LINE__, temp,temp->sector,temp->length,temp->timeinfo.time,temp->timeinfo.line);
		if (flag_debug == 0) {save_flag = 0; flag_debug = 1; }
                dump_staged_list(__LINE__);
	        dump_mainio_list(__LINE__);
		if (save_flag >= 0) {flag_debug = save_flag;         }
	    }
	    if ((best = best_match(this,io,temp)) != NULL) io = best;
        }
    }

    /* The following are not done for 'C' events here... see 'C' processing for more info */
    if ((this->prmact != 'C') && (this->prmact != 'M') && (this->prmact != 'F'))
    {
        /* If we didn't find one:
         *    a) is this a dispatch:discard with missing explicit merge events, or
         *    b) is this a dispatch:r/w     with missing explicit merge events (named
         *       2nd hand merging as it appears they are done in the scheduler a btree
         *       insert time
         * The difference between the two is that (a) can literally have 100s of merges that
         * should be present but aren't, vs in-scheduler merging @btree time which will only
         * happen between 2 contexts (as far as ever seen in the wild).
         *
	 * Since both are issues related to dispatch, but (a) is more specific and limited to 
	 * discards, attempt to apply that one first and only if that fails try the second type.
	 * Need to do this here instead of in dispatch_event() as the later code paths will create
	 * a ghost io context if no matches are available and we need to prevent that by searching
         * performing the search for virtual merges now.  Otherwise the ghost is created and the
         * ghost io context is returned to dispatch_event() and that will prevent (or complicate)
         * the search for virtual merging (missing M events that should be present but aren't).
         */
        if ((io == NULL) && (this->prmact == 'D') && (this->prmtyp == IOTYP_DISCARD))
	{
            /* (a) Didn't find a straight up match, possibly due to missing*/
            /* merges for this discard, try harder.                        */
            io = search_staged4_vmerges(this,eventname,__LINE__);
        }

        if ((io == NULL) && (this->prmact == 'D')) 
	{
            /* (b)
             *   . .AND. action if Dispatch, check for 2nd hand merging that may have been done by scheduler,
             *   . then check is we still didn't find a matching io context this is orphan event and determine
             *     and create a ghost request (if the event type warrants it -- we don't for 'C' for instance)
             */ 
            io = check_2ndhand_merging(this,io,eventname,onmain);   	/* if this sets NOTARGET on event */
	}

	if ((this->evtflags & EVTFLG_NOTARGET) == 0)			/* set in 2nd hand, "data processing fault has occurred, event not tagged to existing io context */
        {
	    if (io == NULL)						/* ... one last qualified try     */
	        io = search_staged_x360(this,io,eventname,__LINE__);

            io = check_io_found(this,io,eventname,onmain);		/* ... then skip this, io is null */
	}
    }
    _return(io);
}

/**
 * ==========================================================================================
 * Function : check_mainio_special1 - search for an io on the mainio list that matches special1
 *            @
 * Args       @this:	    current event info
 * Returns  : 1             found special matching criteria
 *
 * Description
 * Search the mainio list of special matching io.
 * if event == Q, then its is an io that matches the same full event type (FWS for example),
 *                and has valid sector:length of 0:0.
 * if other     , then its an io that is marked special and has 0:0 present.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int check_mainio_special1(typ_event *this, char *eventname)
{
int rw;
int lstndx;
typ_io *io, *temp;

    TRACE_FUNCTION;
    io = NULL;
    rw = R_OR_W(this);
    dprintf( "DBG[%05d]: check_mainio_special1() - do possible 'barrier' type specials match on mainio (called from parse_event()).\n", __LINE__ );
    /* dump_mainio_list(); */
    dprintf( "DBG[%05d]: mainio list[%5d] check for %10ld:%6ld match for %s...\n", __LINE__, mainio_on_list, 0L, 0L, eventname );
    for (lstndx=1, temp = mainio_list; temp != (typ_io *)NULL; temp = temp->next, lstndx++)
    {
        d3printf( "DBG[%05d]: mainio list[%5d]  %p %10ld:%6ld...\n", __LINE__, lstndx, temp, temp->sector, temp->length );
        if ( temp->sector != 0L                        ) continue;
        if ( temp->length != 0L                        ) continue;
        dprintf( "DBG[%05d]: mainio list[%5d]  %p %10ld:%6ld... match!\n", __LINE__, lstndx, temp, temp->sector, temp->length );
        if ( R_OR_W(temp)                         != rw) continue; /* not the same (broad) type of io */
        if ((temp->evtflags & EVTFLG_VALID_SECTOR) == 0) continue; /* doesn't have valid sector numb  */
        if ((temp->evtflags & EVTFLG_VALID_SIZE  ) == 0) continue; /* doesn't have valid size   numb  */
        if ( temp->minor  != this->minor               ) continue; /* not the same device             */
        if ( temp->major  != this->major               ) continue; /* not even same major device type */
        dprintf( "DBG[%05d]: mainio list[%5d]  %p %10ld:%6ld... passed other filters!\n", __LINE__, lstndx, temp, temp->sector, temp->length );

	/* Ok, final matching.  If Q, no special set, if anything else it must have SPCFLG_00 set from */
	/* prior Q event matching A event							       */
	if ((this->prmact != 'Q') && ((temp->specials & SPCFLG_00     ) ==            0)) continue;
	if ((this->prmact == 'C') && ( temp->info->events.dispatch.line != LINENUM_NONE)) continue;

        if (io == NULL)
        {
            /* first match! */
            io = temp;
            dprintf( "DBG[%05d]: mainio list  %p %10ld:%6ld... <= 1st hit\n", __LINE__, temp, temp->sector, temp->length );
        }
        else
        {
            /* @@@TBD - resolve conflicting io for same lba & size */
            /*          which is different than detection overlap  */
            /*          in that overlap can be diff lba+len but    */
            /*          still partially overlap this new one       */
            dprintf( "DBG[%05d]: mainio list  %p %10ld:%6ld... <= 1st hit\n", __LINE__, io  ,  io->sector,   io->length );
            dprintf( "DBG[%05d]: mainio list  %p %10ld:%6ld... <= Nth hit\n", __LINE__, temp, temp->sector, temp->length );
            dprintf( "DBG[%05d]: continue, best_match_special1() will be used to determine which to use\n", __LINE__);
        }
    }
    if (io != NULL) _return(1);
    _return(0);
}

/*
 * ==========================================================================================
 * Function : search_mainio_special1 - find matching sector:length on mainio list
 *            @
 * Args       @this:	    current event info
 * Returns  : io            io structure found matching 'this' event, if any, null otherwise
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
typ_io *search_mainio_special1(typ_event *this, typ_io *in_io, char *eventname, int *onmain)
{
int rw;
int lstndx;
typ_io *io, *temp;

    if (in_io != NULL) return(in_io);  /* @@@shouldn't require this, function should only be called when don't have io yet */

    TRACE_FUNCTION;
    io = NULL;
    rw = R_OR_W(this);
    dprintf( "DBG[%05d]: search_mainio_special1()\n", __LINE__ );
    dprintf( "DBG[%05d]: mainio list[%5d] check for %10ld:%6ld match for %s...\n", __LINE__, mainio_on_list, this->sector, this->length, eventname );
    for (lstndx=1, temp = mainio_list; temp != (typ_io *)NULL; temp = temp->next, lstndx++)
    {
        d3printf( "DBG[%05d]: mainio list[%5d]  %p %10ld:%6ld...\n", __LINE__, lstndx, temp, temp->sector, temp->length );
        if ( temp->sector != 0L                        ) continue;
        if ( temp->length != 0L                        ) continue;
        dprintf( "DBG[%05d]: mainio list[%5d]  %p %10ld:%6ld... match!\n", __LINE__, lstndx, temp, temp->sector, temp->length );
        if ( R_OR_W(temp)                         != rw) continue; /* not the same (broad) type of io */
        if ((temp->evtflags & EVTFLG_VALID_SECTOR) == 0) continue; /* doesn't have valid sector numb  */
        if ((temp->evtflags & EVTFLG_VALID_SIZE  ) == 0) continue; /* doesn't have valid size   numb  */
        if ( temp->minor  != this->minor               ) continue; /* not the same device             */
        if ( temp->major  != this->major               ) continue; /* not even same major device type */
        dprintf( "DBG[%05d]: mainio list[%5d]  %p %10ld:%6ld... passed other filters!\n", __LINE__, lstndx, temp, temp->sector, temp->length );

	/* Ok, final matching.  If Q, no special set, if anything else it must have SPCFLG_00 set from */
	/* prior Q event matching A event							       */
	if ((this->prmact != 'Q') && ((temp->specials & SPCFLG_00     ) ==            0)) continue;
	if ((this->prmact == 'C') && ( temp->info->events.dispatch.line != LINENUM_NONE)) continue;

        if (io == NULL)
        {
            /* first match! */
            io = temp;
            *onmain = 1;
            dprintf( "DBG[%05d]: mainio list  %p %10ld:%6ld... <= 1st hit\n", __LINE__, temp, temp->sector, temp->length );
        }
        else
        {
            /* @@@TBD - resolve conflicting io for same lba & size */
            /*          which is different than detection overlap  */
            /*          in that overlap can be diff lba+len but    */
            /*          still partially overlap this new one       */
            dprintf( "DBG[%05d]: mainio list  %p %10ld:%6ld... <= 1st hit\n", __LINE__, io  ,  io->sector,   io->length );
            dprintf( "DBG[%05d]: mainio list  %p %10ld:%6ld... <= Nth hit\n", __LINE__, temp, temp->sector, temp->length );
	    printf( "DBG[%05d]: %s()\n", __LINE__, __func__ );
            dump_staged_list(__LINE__);
	    dump_mainio_list(__LINE__);
	    /* Call best_match() to resolve which one to use       */
	    /* This (special1) is the easy case for this logic     *//* I hope */
	    io = best_match_special1(this,io,temp);	
        }
    }
    if ((io != NULL) && (this->prmact == 'C'))
    {
        /* If we get here, then dispatch didn't exist */
	/* We could be dealing with a device that has no I events, for example */
        /*    252,17   0      669     6.542686846  3957  A FWS 0 + 0 <- (253,7) 0
         *    252,16   0      670     6.542687640  3957  Q FWS [jbd2/dm-7-8]
         *    252,16   0      671     6.542688799  3957  G FWS [jbd2/dm-7-8]
         *    252,16   0      672     6.542925016     0  C  WS 0 [0]
	 *
	 *    Barrier, has no I or D events.
	 */
	if (io->info->events.insert.line != 0)
        {
	    io->info->events.dispatch.time = io->info->events.insert.time;
	    io->info->events.dispatch.line = LINENUM_SPEC1;
	} 
	else if (io->info->events.first.line != 0)
	{
	    io->info->events.dispatch.time = io->info->events.first.time;
	    io->info->events.dispatch.line = LINENUM_SPEC1;
	}
	/* else nothing to use to dummy fill in D event info */

        /* in ascending order:
         * read       = IOTYP_READ
         * write      = IOTYP_WRITE, IOTYP_META, IOTYP_BARRIER
         * discard    = IOTYP_DISCARD, treat as write for inflight counter purposes
         */
        state.inFlight++;
        if (io->prmtyp == IOTYP_READ ) state.inFlight_Read++;
        if (io->prmtyp >= IOTYP_WRITE) state.inFlight_Write++;	/* Covers write, meta, barrier... */
	cnt_printf( "DBG[%05d]: %24s() iocnt (%5d) inFlight++   %5d: %5d,%5d %s\n", __LINE__, __func__, state.inProgress, state.inFlight, state.inFlight_Read, state.inFlight_Write,
			(((state.inFlight_Read < 0.0) || (state.inFlight_Write < 0.0))?" : counter is negative":"") );
        cnt_fprintf( outf, "DBG[%05d]: %c:%08ld.%06ld iocnt (%5d) inFlight++   %5d: %5d,%5d\n", __LINE__, 
		_prmtyp(this->prmtyp), this->sector, this->length, state.inProgress, state.inFlight, state.inFlight_Read, state.inFlight_Write );
	if (state.inFlight > state.inProgress)
        {
	    _EXIT( printf( "DBG[%05d]: %s()\n", __LINE__, __func__ ) );
	}
    }
    _return(io);
}

/**
 * ==========================================================================================
 * Function : search_staged_special1 - find matching sector:length on staged list
 *            @
 * Args       @this:	    current event info
 * Returns  : io            io structure found matching 'this' event, if any, null otherwise
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
typ_io *search_staged_special1(typ_event *this, char *eventname, int lineno)
{
int rw;
int lstndx;
typ_io *io, *temp;

    TRACE_FUNCTION;
    io = NULL;
    rw = R_OR_W(this);
    dprintf( "DBG[%05d]: search_staged_special1()\n", __LINE__ );
    dprintf( "DBG[%05d]: staged list[%5d] check for %10ld:%6ld match for %s...\n", __LINE__, staged_on_list, this->sector, this->length, eventname );
    for (lstndx=1, temp = staged_list; temp != (typ_io *)NULL; temp = temp->next, lstndx++)
    {
        dprintf( "DBG[%05d]: staged list[%5d]  %p %10ld:%6ld...\n", __LINE__, lstndx, temp, temp->sector, temp->length );
        if ( temp->sector != 0L                        ) continue;
        if ( temp->length != 0L                        ) continue;
        dprintf( "DBG[%05d]: staged list[%5d]  %p %10ld:%6ld... match!\n", __LINE__, lstndx, temp, temp->sector, temp->length );
        if ( R_OR_W(temp)                         != rw) continue; /* not the same (broad) type of io */
        if ((temp->evtflags & EVTFLG_VALID_SECTOR) == 0) continue; /* doesn't have valid sector numb  */
        if ((temp->evtflags & EVTFLG_VALID_SIZE  ) == 0) continue; /* doesn't have valid size   numb  */
        if ( temp->minor  != this->minor               ) continue; /* not the same device             */
        if ( temp->major  != this->major               ) continue; /* not even same major device type */
        dprintf( "DBG[%05d]: staged list[%5d]  %p %10ld:%6ld... passed other filters!\n", __LINE__, lstndx, temp, temp->sector, temp->length );

	/* Ok, final matching.  If Q, no special set, if anything else it must have SPCFLG_00 set from */
	/* prior Q event matching A event							       */
	if ((this->prmact != 'Q') && ((temp->specials & SPCFLG_00     ) ==            0)) continue;
	if ((this->prmact == 'C') && ( temp->info->events.dispatch.line != LINENUM_NONE)) continue;

        if (io == NULL)
        {
            /* first match! */
            io = temp;
            dprintf( "DBG[%05d]: staged list  %p %10ld:%6ld... <= 1st hit\n", __LINE__, temp, temp->sector, temp->length );
        }
        else
        {
            /* @@@TBD - resolve conflicting io for same lba & size */
            /*          which is different than detection overlap  */
            /*          in that overlap can be diff lba+len but    */
            /*          still partially overlap this new one       */
            printf( "DBG[%05d]: staged list  %p %10ld:%6ld... <= 1st hit\n", __LINE__, io  ,  io->sector,   io->length );
            printf( "DBG[%05d]: staged list  %p %10ld:%6ld... <= Nth hit\n", __LINE__, temp, temp->sector, temp->length );
	    printf( "DBG[%05d]: %s()\n", __LINE__, __func__ );
            dump_staged_list(__LINE__);
	    dump_mainio_list(__LINE__);
	    /* Call best_match() to resolve which one to use       */
	    /* This (special1) is the easy case for this logic     *//* I hope */
	    io = best_match_special1(this,io,temp);	
        }
    }
    if (io != NULL) io->specials |= SPCFLG_00;
    _return(io);
}

/**
 * ==========================================================================================
 * Function : search_staged_duplicate1 - find next matching io after passed in io
 *            @
 * Args       @this:	    current event info
 *            @io:          current matched io
 * Returns  : io            io structure found matching 'this' event, if any, null otherwise
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
typ_io *search_staged_duplicate1(typ_event *this, typ_io *io, char *eventname, int lineno)
{
int rw;
int len = strlen(eventname);
int lstndx;
typ_io *temp;
int disqualified;
unsigned long evtmask;
unsigned long my_mask;

    TRACE_FUNCTION;
    io = NULL;
    rw = R_OR_W(this);
    dprintf( "DBG[%05d]: search_staged_duplicate1()\n", __LINE__ );
    dprintf( "DBG[%05d]: staged list[%5d] check for %10ld:%6ld match for %s...\n", __LINE__, staged_on_list, this->sector, this->length, eventname );

    /* Which prior events are expected? */
    switch (this->prmact)
    {
	case 'G': my_mask = EVTMSK_G; evtmask = (EVTMSK_A | EVTMSK_Q);            break;
	case 'I': my_mask = EVTMSK_I; evtmask = (EVTMSK_A | EVTMSK_Q | EVTMSK_G); break;
	default : assert(0==1); evtmask = 0L; break;		/* should not happen */
    }

    for (lstndx=1, temp = staged_list; temp != (typ_io *)NULL; temp = temp->next, lstndx++)
    {
        /*d2*/printf( "DBG[%05d]: staged list[%5d]  %p %10ld:%6ld %s...\n", __LINE__, lstndx, temp, temp->sector, temp->length, temp->evttyp );

        if ( temp->sector != this->sector              ) continue;	
        if ( temp->length != this->sector              ) continue;
        if ( R_OR_W(temp)                         != rw) continue; /* not the same (broad) type of io */
        if ((temp->evtflags & EVTFLG_VALID_SECTOR) == 0) continue; /* doesn't have valid sector numb  */
        if ((temp->evtflags & EVTFLG_VALID_SIZE  ) == 0) continue; /* doesn't have valid size   numb  */
        if ( temp->minor  != this->minor               ) continue; /* not the same device             */
        if ( temp->major  != this->major               ) continue; /* not even same major device type */

	if ( temp         == io                        ) continue; /* the one we passed in            */

	/* Ok, the one we're looking for is missing my_mask but has all of the critical pre-req events*/
	if ((temp->event_mask & my_mask)     != 0      ) continue; /* this event already present      */

	/* Ohhhh, yes we did find a duplicate that is missing this event type. Now does it pre-reqs?  */
	disqualified = 0;
        switch (this->prmact)
        {
	    case 'G': if ((temp->event_mask & evtmask) == 0); disqualified++; break;
	    case 'I': if ((temp->event_mask & evtmask) == 0); disqualified++; break;
        }
	if (disqualified                     != 0      ) continue;

        printf( "DBG[%05d]: staged list[%5d]  %p %10ld:%6ld... passed other filters!\n", __LINE__, lstndx, temp, temp->sector, temp->length );

	/* Ok, this is 1st match (should be after passed in io), return! */
	_return(temp);
    }
    /* no new match found, returned the passed in io context */
    _return(io);
}


/**
 * ==========================================================================================
 * Function : check_staged_x360 - search for an io on the staged list that matches 'this'
 *                                under tight qualifing restrictions
 *            @
 * Args       @this:        current event info
 *          : @eventname:   char string of event name
 *            @lineno:      routine line number calling this routine (diag purposes)
 * Returns  : io            io structure found matching 'this' event, if any, null otherwise
 *
 * Description
 * Search the staged list of io for a match to this event -- this is "x360" search in
 * that we're looking for a direct match between sector:lenght in 'this' vs an io on mainio list
 * and one that only has an 'A' event present.
 *
 * This is used for A,D.C event type sequences where at 'D' time, there has been no S,G,I
 * events that would push the io context from staged to main where 'D' events look in normal
 * event sequences.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * + The conf_x360_policy must be non-zero allowing this type of search
 * + The current event type must be a 'D' only, no others are allowed
 * + There cannot be any 'Q' events encountered within the blktrace data to date
 *   - if 'Q' event count is non-zero, then verify the matched by x360 policy vis
 *     this routine is also zero.  If it is not, then fatal out -- but first build
 *     local .conf with x360 policy set to zero so we can run a second time and
 *     have this logic force disabled.
 * + Matching events can only have 'A' events -- so 'S' are disallowed at this 
 *   time but *may* need to be added later (although technically a 'S' should have
 *   pushed a staged io to main queue as you should only sleep while waiting for
 *   a request context which means S,G,I all indicate that the io is to be moved
 *   to main io queue as separate request structure in kernel would be intented, implied.
 *
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
typ_io *search_staged_x360(typ_event *this, typ_io *in_io, char *eventname, int lineno)
{
static int _x360_match_count = 0;
int rw;
int lstndx;
int bad = 0;
typ_io *io, *temp, *best;
FILE *conf;

    TRACE_FUNCTION;
    if (in_io                   != NULL) _return(in_io);  /* @@@shouldn't require this, function should only be called when don't have io yet */
    if (conf_x360_policy        ==  0  ) _return(in_io);  /* x360 search turned off/disallowed		   */
    if (this->prmact            != 'D' ) _return(in_io);  /* x360 search only valid for 'D' events         */
    if (state.event_count_remap ==  0  ) _return(in_io);  /* x360 search only valid if  'A' events present */
    if (state.event_count_queue !=  0  )
    {
	if (_x360_match_count   ==  0  ) _return(in_io);  /* x360 search only valid if  'Q' count is zero  */
	if (conf_x360_policy    <   4  )
	{
	    /* Ok, this says we've done x360 matches prior */
	    /* but now Q events exist so boom! logic needs */
            /* to be forced off and re-run to prevent bad  */
            /* match logic from possibly happening         */
            printf( "%%F[%05d]-%s() x360_policy=%d but Q events detected and logic previously used for successful matches. Exit.\n", __LINE__, __func__, conf_x360_policy);
	    if ((conf = fopen(thisdirloc,"a")) == NULL)
            {
	        printf( "%%E[%05d]-unable to open %s for append access.\n", __LINE__, thisdirloc );
	    }
            else
	    {
	        fprintf( conf, "x360_policy=0		# turn off x360 to prevent A,D,C event stream matching as Q events present\n");
	        fclose( conf );
	        logHprintf( "%%I[%05d]-%s() created local %s file with x360_policy=0, re-run parse should now avoid this issue.\n", __LINE__, __func__, thisdirloc );
	    }
            _EXIT( /* %%F */ 1 );
	}
	/* We cannot turn off x360 policy... its forced into 'ON' position */
	/* Results can be unpredictable!                                   */
	/* Lets not just set the X360 FORCE alert flag here, but prime it  */
	/* Set it only if we generate a match and the logic indicates that */
	/* is potentially bad decision.				           */
	/* But avoid exiting here like we'd normally do.                   */

	/* continuing...						   */
        bad = 1;
    }

    /*
     * Ok, made it through the selection criteria/gatekeepers
     *
     * This doesn't mean we'll actually find a match, just that its not disallowed at this point.
     * Note: barriers don't have 'D' events so we haven't explicitly search for those to disqualify.
     *       I suppose x360 could have A,C events for 0+0 that are barriers, but haven't seen any
     *       to date.
     */
    dprintf( "DBG[%05d]: check_staged_x360() - do possible 'A,D,C' event sequence special matching within staged.\n", __LINE__ );

    io = NULL;
    rw = R_OR_W(this);
    /* dump_staged_list(); */
    dprintf( "DBG[%05d]: staged list[%5d] check for %10ld:%6ld match for %s...\n", __LINE__, mainio_on_list, this->sector, this->length, eventname );
    for (lstndx=1, temp = staged_list; temp != (typ_io *)NULL; temp = temp->next, lstndx++)
    {
        dprintf( "DBG[%05d]: staged list[%5d]  %p %10ld:%6ld...\n", __LINE__, lstndx, temp, temp->sector, temp->length );
        if ( temp->sector != this->sector              ) continue;
        if ( temp->length != this->length              ) continue;
        dprintf( "DBG[%05d]: staged list[%5d]  %p %10ld:%6ld... match!\n", __LINE__, lstndx, temp, temp->sector, temp->length );
        if ( R_OR_W(temp)                         != rw) continue; /* not the same (broad) type of io */
        if ((temp->evtflags & EVTFLG_VALID_SECTOR) == 0) continue; /* doesn't have valid sector numb  */
        if ((temp->evtflags & EVTFLG_VALID_SIZE  ) == 0) continue; /* doesn't have valid size   numb  */
        if ( temp->major            != this->major     ) continue; /* not even same major device type */
        if ((temp->minor & 0xFFF0)  != this->minor     ) continue; /* not the same device             */
        dprintf( "DBG[%05d]: staged list[%5d]  %p %10ld:%6ld... passed other filters!\n", __LINE__, lstndx, temp, temp->sector, temp->length );

        if (io == NULL)
        {
            /* first match! */
            io = temp;
            dprintf( "DBG[%05d]: staged list  %p %10ld:%6ld... <= 1st hit\n", __LINE__, temp, temp->sector, temp->length );
        }
        else
        {
            /* @@@TBD - resolve conflicting io for same lba & size */
            /*          which is different than detection overlap  */
            /*          in that overlap can be diff lba+len but    */
            /*          still partially overlap this new one       */
            printf( "DBG[%05d]: staged list  %p %10ld:%6ld... <= 1st hit\n", __LINE__, io  ,  io->sector,   io->length );
            printf( "DBG[%05d]: staged list  %p %10ld:%6ld... <= Nth hit\n", __LINE__, temp, temp->sector, temp->length );
            printf( "DBG[%05d]: continue, best_match_special1() should be used to determine which to use?\n", __LINE__);
	    printf( "%F[%05d]-%s() internal logic fault.  Currently disallow duplicate io of x360 A,D,C type. Contact maintainer.\n", __LINE__, __func__ );
        }
    }
    if (io != NULL) 
    { 
        if (_x360_match_count++ <= conf_x360_completions)
        {
	     if (conf_x360_policy <= 2)
		fprintf( outf, "%%W[%05d]-A,D...C event sequencing matching performed. Will warn only %d times.\n", __LINE__, conf_x360_completions );
	}
	if (bad != 0)
	{
	    /* Okay, this was forced by policy setting, set alert flag */
            state.alerts |= ALERTFLG_X360_FORCED;
	}

	/* Now, move the io from staged to main queue */
        move_staged_to_mainio(io);

	_return(io);
    }
    _return(in_io);
}


/**
 * ==========================================================================================
 * Function : search_staged4_vmerges
 *            @
 * Args       @this:	    current event info
 *          : @eventname:   char string of event name
 *            @lineno:      routine line number calling this routine (diag purposes)
 * Returns  : io            io structure found matching 'this' event, if any, null otherwise
 *
 * Description
 * First search mainio for a full match with the exception of length.  The length must be less
 * than the current io length.  This context acts as a front anchor for the current io, while
 * the current io is the back anchor.
 *
 * If above is found, now search staged queue for a list of io between the front and back anchors
 * that fill in the full current io length.  Each such match must be type,sector within the full
 * io context as defined by the current (back) anchor.  Create a sorted list of the events that
 * match and if at the end the list covers the front to end context, then manually build a merge
 * event text string, parse it, then call merge_event() to make the merge happen. 
 *
 * Once all merges have happened, verify the io context the code originally found on the mainio
 * queue now fully matches the current io (type,sector,length) and return that io to be used by
 * the caller.  (And if that isn't the case throw %E messages!)
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * This is currently ONLY used for discards at 'D'ispatch event time.  There may be other cases
 * where a bug in the event stream does not include a necessary event to either move the io from
 * the pre-stage to mainio queue or merge (associate) it with an existing io on the mainio queue.
 * The results for the current discard case where merges are not present is a bunch of io context
 * stuck in the prestage queue (which can grow to 100,000s of contexts), and io stuck on the mainio
 * queue due to insufficient length matching, and ghost D,C contexts that are not counted towards
 * statistics (because that's a design choice for ghost io contexts -- of which there should be 
 * very few).
 *
 * Example, front anchor is sector+8, back anchor is sector+2016.  In between there were a bunch
 * of A,Q events missing a Merge event to get them added to the front anchor.  This code finds
 * the front anchor and then anything stuck in the pre-stage queue of same iotype,sector that, 
 * if added to the front anchor, builds that context out to the point that it will match the
 * back anchor.
 * 259,15  79        2     0.001169651  2271  A   D 3231873472 + 8 <- (9,126) 29084482240
 * 259,15  79        3     0.001169851  2271  Q   D 3231873472 + 8 [md126_raid5]
 * 259,15  79        4     0.001170381  2271  G   D 3231873472 + 8 [md126_raid5]
 * ...
 * 259,15  79        5     0.001177641  2271  A   D 3231873480 + 8 <- (9,126) 29084482248
 * 259,15  79        6     0.001177841  2271  Q   D 3231873480 + 8 [md126_raid5]		<< gets stuck on per-stage, missing M event.
 * 259,15  79        7     0.001181831  2271  A   D 3231873488 + 8 <- (9,126) 29084482256
 * 259,15  79        8     0.001181971  2271  Q   D 3231873488 + 8 [md126_raid5]
 * 259,15  79        9     0.001185581  2271  A   D 3231873496 + 8 <- (9,126) 29084482264
 * 259,15  79       10     0.001185711  2271  Q   D 3231873496 + 8 [md126_raid5]
 * 259,15  79       11     0.001190281  2271  A   D 3231873504 + 8 <- (9,126) 29084482272
 * 259,15  79       12     0.001190411  2271  Q   D 3231873504 + 8 [md126_raid5]
 * 259,15  79       13     0.001194831  2271  A   D 3231873512 + 8 <- (9,126) 29084482280
 * 259,15  79       14     0.001194981  2271  Q   D 3231873512 + 8 [md126_raid5]
 * --
 * 259,15  79      508     0.002449572  2271  D   D 3231873472 + 2016 [md126_raid5]		<< length covers initial A,Q,G plus setof {A,Q}... that are missing merge events.
 * 259,15  79     3673     0.028397610     0  C   D 3231873472 + 2016 [0]
 * 
 * As first pass logic, use a bitmap where each bit 0...n maps a sector.  Assume that the
 * max length of one of these bugged discards has a max length of 16k sectors (0xFFFF) / 64
 * mean the bitmap must be [1024], any current io larger than 65,536 sectors in length will
 * generate a %F event as not dealing with such event streams will just about hang the processing
 * anyway with tons of io contexts getting stuck in prestage and mainio queues.  The bitmap
 * will allow relatively each determination of whether the sector/length was previously
 * covered by another io in the list and track io being added to the list.  Plus a final
 * check that all sectors from front to back anchor contexts have been covered.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
typ_io *search_staged4_vmerges(typ_event *this,char *eventname, int lineno )
{
static unsigned long bitmap[1024];
static char _prmtyp[32]="xoNSRWMBD-----------------------";
static typ_io *merge_list[1024];
static typ_event mrg_event;
char mrg_inpline[MAXBUF];
char sav_inpline[MAXBUF];
char rsn        [MAXBUF];
typ_action *lst_action;
typ_io *temp, *io, *best, *xsplit;
int lstndx;
int rwd;
long nxt_sector;
long bgn_sector, end_sector;
long hole_sector, hole_count;
int  cur_sector, cur_length, mapndx, bitndx, nrbits, okbits;
int  found;
int  mrgndx = 0;

    TRACE_FUNCTION;
    xsplit = NULL;
    io = NULL;

    /* 1. find an exact match on the mainio list (minus length)		*/
    rwd = R_OR_W(this);
    dxprintf( "DBG[%05d]: mainio list[%5d]  check for %12ld:%6ld match for %s...\n", __LINE__, mainio_on_list, this->sector, this->length, eventname );
    for (lstndx=1, temp = mainio_list; temp != (typ_io *)NULL; temp = temp->next, lstndx++)
    {
        if ( temp->sector != this->sector              ) continue; /* not the front anchor's sector   */
        if ( R_OR_W(temp)                        != rwd) continue; /* not the same (broad) type of io */
        if ((temp->evtflags & EVTFLG_VALID_SECTOR) == 0) continue; /* doesn't have valid sector numb  */
        if ((temp->evtflags & EVTFLG_VALID_SIZE  ) == 0) continue; /* doesn't have valid size   numb  */
        if ( temp->minor  != this->minor               ) continue; /* not the same device             */
        if ( temp->major  != this->major               ) continue; /* not even same major device type */
        d1printf( "DBG[%05d]: mainio list[%5d]  %p %12ld:%6ld... match+passed other filters but not length\n", __LINE__, lstndx, temp, temp->sector, temp->length );

        if ( temp->length >= this->length              ) continue; /* front anchor lenght must be less that back anchor (this) */

        io  = temp;						   /* plan to return this after all merging completed          */
        break;
    }
    if (io == NULL) 
    {
	/* Great, another event stream snafu to be trained on!? */
	/* Welllll maybe not.  This can happen if the processing*/
        /* is still near the beginning of the input event file  */
	printf( "%%E[%05d]-%s(%c:%12ld,%6ld) front anchor not found for oversized Discard (BOF?). Continue...\n", __LINE__, __func__, _prmtyp[ this->prmtyp ], this->sector, this->length );
        return(0);
    }
    /* After this point there should not be any fatals unless   */
    /* there are new brokeness stuff we're not yet aware of     */
    /* So from here on out is succeed or exit.                  */

    if (this->length > 0xFFFF)
    {
	printf( "%%F[%05d]-%s(length=%ld) > 0xFFFF sector tracking bitmap limit, contact maintainer. Exit\n", __LINE__, __func__, this->length );
	exit(1);
    }

 
    /* 2. find any io on the staged queue that fill in from the mainio 	*/
    /*    found above and the current io context.			*/
    bzero(bitmap,sizeof(bitmap));
    bzero(merge_list,sizeof(merge_list));
    nrbits     = 0;
    bgn_sector = this->sector;
    end_sector = this->sector + this->length - ((this->length!=0)?1:0);
    dxprintf( "DBG[%05d]: sector range %12ld .. %12ld\n", __LINE__, bgn_sector, end_sector );

    /* first, cover the anchor io found above 				*/
    cur_sector = 0;
    cur_length = (int)io->length;
    mapndx     = cur_sector >> 6;
    bitndx     = cur_sector & 0x3F;
    while (--cur_length >= 0)
    {
	bitmap[mapndx] |= 1UL<<bitndx; nrbits++;
	if (bitndx++ >= 0x3F) { bitndx = 0; mapndx++; }
    }
    dxprintf( "DBG[%05d]: bitmap[   0]=%016LX, %016lX\n", __LINE__, bitmap[0], bitmap[1] );
	
    /* Now scan the prestage list for io that have sectors between the 	*/
    /* sector and end/anchor sector.  Perform checks. Add to list       */    
    for (lstndx = 1, temp = staged_list; temp != (typ_io *)NULL; temp = temp->next, lstndx++)
    {
        dxprintf( "DBG[%05d]: staged list[%5d]  %p %c:%12ld:%6ld... missing sectors found: %5d vs %5ld\n", __LINE__, lstndx, temp, _prmtyp[ temp->prmtyp ], temp->sector, temp->length, nrbits, this->length );
        /*dump_io_dbg(temp);*/
        if ( R_OR_W(temp)                        != rwd) continue; /* not the same (broad) type of io */
        if ( temp->sector <   bgn_sector               ) continue;
        if ( temp->sector >   end_sector               ) continue;
        if ((temp->evtflags & EVTFLG_VALID_SECTOR) == 0) continue; /* doesn't have valid sector numb  */
        if ((temp->evtflags & EVTFLG_VALID_SIZE  ) == 0) continue; /* doesn't have valid size   numb  */
        if ( temp->minor  != this->minor               ) continue; /* not the same device             */
        if ( temp->major  != this->major               ) continue; /* not even same major device type */
        dxprintf( "DBG[%05d]: staged list[%5d]  %p %c:%12ld:%6ld... match+passed other filters but not length\n", __LINE__, lstndx, temp, _prmtyp[ temp->prmtyp ], temp->sector, temp->length );

	/* Test and set bits						*/
        okbits     = 1;
	cur_sector = (int)(temp->sector - bgn_sector);
        cur_length = (int) temp->length;
        mapndx     = cur_sector >> 6;
        bitndx     = cur_sector & 0x3F;
        dxprintf( "DBG[%05d]: chkmap %5d,%5d\n", __LINE__, cur_sector, cur_length );
        dxprintf( "DBG[%05d]: chkmap[%4d.%02d]=%016LX, %016lX\n", __LINE__, mapndx, bitndx, bitmap[mapndx], bitmap[mapndx+1] );
        while (--cur_length >= 0)
        {
	    if ((bitmap[mapndx] & (1UL<<bitndx)) != 0)
            {
		/* This is possible, but unlikely.  	*/
		/* Its an artifact of missing merges    */
		/* A 1st discard is done and then 2nd   */
		/* before 1st Dispatch happens, then we */
		/* have multiple chunks in prestage that*/
		/* are for two different discards, only */
		/* accept 1st match but complain.       */
		okbits = 0;
		printf( "%%W[%05d]-%s(%c:%ld,%ld) previously found, skipping...\n", __LINE__, __func__, _prmtyp[ temp->prmtyp ], temp->sector, temp->length );
		break;
	    }
	    if (bitndx++ >= 0x3F) { bitndx = 0; mapndx++; }
            dxprintf( "DBG[%05d]: chkmap[%4d.%02d]=%016LX, %016lX\n", __LINE__, mapndx, bitndx, bitmap[mapndx], bitmap[mapndx+1] );
	}
	if (okbits != 0)
        {
	    cur_sector = (int)(temp->sector - bgn_sector);
            cur_length = (int) temp->length;
            mapndx     = cur_sector >> 6;
            bitndx     = cur_sector & 0x3F;
            dxprintf( "DBG[%05d]: setmap[%4d.%02d]=%016LX, %016lX\n", __LINE__, mapndx, bitndx, bitmap[mapndx], bitmap[mapndx+1] );
            while (--cur_length >= 0)
            {
		bitmap[mapndx] |= 1UL<<bitndx; nrbits++;
		if (bitndx++ >= 0x3F) { bitndx = 0; mapndx++; }
                dxprintf( "DBG[%05d]: setmap[%4d.%02d]=%016LX, %016lX\n", __LINE__, mapndx, bitndx, bitmap[mapndx], bitmap[mapndx+1] );
	    }
	    /* Add this context to the list		*/
	    merge_list[mrgndx++] = temp;
	    if (nrbits >= this->length)
	    {
		/* We have found enough prestage context to cover the missing */
		/* merges needed for the this (discard/dispatch) context, done*/
		break;
	    }
	}
    }

    /* Setup complete, report findings, leave a breadcrumb event in the output file on issue */
    q2printf( "DBG[%05d]: discard D:%12ld,%6ld missing merges. found %6d sectors, %6d missing in 'holes' in discard range.\n", __LINE__,
        this->sector, this->length, nrbits, (int)(this->length - (long)nrbits) );
    /* Is this a %Warning (manual merging found all the parts needed) or %Error whereby there*/
    /* are holes in the merge map. Be unquiet about Errors, but quiet about warnings as when */
    /* this discard issue happens, there are LOTS and LOTs of "warnings" but only a few of   */
    /* the errors -- which are still a mystery as to why a discard @dispatch is covering     */
    /* sectors never referenced in other bkltrace events.                                    */
    summ.cnt_vmerges++;
    if (nrbits >= this->length)
    {
	/* Warnings : inhibit with -q as these as "normal" in one sense */
	summ.cnt_vmerges_holes++;
	if (flag_quiet < 1)
	{
            q1printf(        "%%%c[%05d]-discard @%13.9f D:%12ld,%6ld missing merges, found %6d sectors in %3d contexts.\n",
 	        ((nrbits >= this->length)?'W':'E'), __LINE__, this->timeinfo.time, 
                this->sector, this->length, nrbits, mrgndx+1 );
            fprintf( outf, " %%%c[%05d]-discard @%13.9f D:%12ld,%6ld missing merges. found %6d sectors in %3d contexts.\n", 
 	        ((nrbits >= this->length)?'W':'E'), __LINE__, this->timeinfo.time,
                this->sector, this->length, nrbits, mrgndx+1 );
	}
    } else {
	/* Errors  : always report as odd to have a hole in the discard */
            printf(          "%%%c[%05d]-discard @%13.9f D:%12ld,%6ld missing merges, found %6d sectors in %3d contexts, %6d sectors missing in 'holes' in discard range.\n",
 	        ((nrbits >= this->length)?'W':'E'), __LINE__, this->timeinfo.time, 
                this->sector, this->length, nrbits, mrgndx+1, (int)(this->length - (long)nrbits) );
            fprintf( outf, " %%%c[%05d]-discard @%13.9f D:%12ld,%6ld missing merges. found %6d sectors in %3d contexts, %6d sectors missing in 'holes' in discard range.\n", 
 	        ((nrbits >= this->length)?'W':'E'), __LINE__, this->timeinfo.time,
                this->sector, this->length, nrbits, mrgndx+1, (int)(this->length - (long)nrbits) );
    }

    /* Dump out whatever we found in terms of missing merges		*/
    if (flag_debug != 0)
    {
    d1printf( "DBG[%05d]: %s() found %d missing merges with %d sectors for %c:%ld,%ld\n", __LINE__, __func__, mrgndx, nrbits, _prmtyp[ this->prmtyp ], this->sector, this->length );
    d1printf( "DBG[%05d]: %s() mainio[   0] %c:%12ld,%6ld -> %12ld\n", __LINE__, __func__, _prmtyp[ io->prmtyp ], io->sector, io->length, io->sector+io->length );
    nxt_sector = io->sector + io->length;
    for (lstndx=0; lstndx < mrgndx; lstndx++)
    {
        rsn[0] = 0;
	if (merge_list[lstndx]->sector != nxt_sector)
	    strcpy( rsn, " {ed: hole in merge list just above this point}" );
        d1printf( "DBG[%05d]: %s() mrglst[%4d] %c:%12ld,%6ld -> %12ld %s\n", __LINE__, __func__, lstndx+1, _prmtyp[ merge_list[lstndx]->prmtyp ], 
		merge_list[lstndx]->sector, merge_list[lstndx]->length,
		merge_list[lstndx]->sector +merge_list[lstndx]->length, rsn );
        nxt_sector = merge_list[lstndx]->sector + merge_list[lstndx]->length;
    }
    for (lstndx=0; (lstndx <= ((this->length+63)>>6)) && (lstndx < 1024); lstndx++)
	d1printf( "DBG[%05d]: %s() bitmap[%4d] %016lX\n", __LINE__, __func__, lstndx, bitmap[lstndx] );

    if (nrbits < this->length)
    {
	/* We failed to find the missing chunks of this io context :-(	*/
        /* This seems to be a feature vs a bug.  A guess is the missing */
	/* chunks are not in use so don't get explicit blktrace events  */
        /* mentioning them but are just added into the dispatch event   */
        /* by magic.                                                    */
	q1printf( "%%E[%05d]-%s(length=%ld, found=%d, missing %d).\n", __LINE__, __func__, this->length, nrbits, this->length-nrbits );
	/* Report number and size of the holes that are present         */
	bgn_sector = 0;
        mapndx     = 0;
        bitndx     = 0;
        hole_sector=-1;
        hole_count = 0;
	while (bgn_sector++ < this->length)
        {
	    if ((bitmap[mapndx] & (1UL<<bitndx)) != 0)
	    {
		if (bitndx++ >= 0x3F) { bitndx = 0; mapndx++; }
		if (hole_sector != -1)
		{
	            q2printf( "%%E[%05d]-%s(discard hole %12ld,%ld detected at offset)\n", __LINE__, __func__, this->sector + hole_sector, hole_count, hole_sector );
		    hole_sector = -1;
		    hole_count  =  0;
		}
		continue;
	    }
	    if (bitndx++ >= 0x3F) { bitndx = 0; mapndx++; }
	    if (hole_sector == -1)
		hole_sector = bgn_sector-1;
	    hole_count++;
        } 
	if (hole_sector != -1)
	    q2printf( "%%E[%05d]-%s(discard hole %12ld,%ld detected at offset)\n", __LINE__, __func__, this->sector + hole_sector, hole_count, hole_sector );
    }
    }

    /* Ok, synthesize a merge event as if read from input file		*/
    /* While we tracked 'nrbits' above, remember that it might not      */
    /* account for any holes in the list, so recompute nrbits to account*/
    /* for the whole expected length below as we're going to process    */
    /* the holes.                                                       */
    nrbits     = this->length - io->length;
    bgn_sector = io->sector   + io->length;
    while (nrbits > 0)
    {
	found = 0;
	d2printf( "DBG[%05d]: search next staged io @sector=%12ld, sectors remaining %d\n", __LINE__, bgn_sector, nrbits);
        for (lstndx=0; lstndx < mrgndx; lstndx++)
        {
	    if (merge_list[lstndx]->sector != bgn_sector) continue;

	    /* Matching next missing segment, process  */
	    temp       = merge_list[lstndx];
	    nrbits    -= temp->length;
            bgn_sector = temp->sector + temp->length;
	    found++;
	    d1printf( "DBG[%05d]: search next staged io @sector=%12ld,%6ld found at merge_list[%4d/%4d]\n", __LINE__, bgn_sector, temp->length, lstndx+1, mrgndx );

	    if (temp->info->events.queue.line != 0)
	        lst_action = &temp->info->events.queue;
	    else if (temp->info->events.remap.line != 0)
		lst_action = &temp->info->events.remap;
	    else
	    {
		printf( "%%F[%05d]: %s() neither Q nor A event context found in mergeing io context from staged. Exit\n", __LINE__, __func__ );
		exit(1);
	    }

            /* #Maj,Mn CPU   SeqNo     Seconds     PID  Evt Typ Sector   +Len Description				*/
            /* #------ --- ------- --------------- -----|--|---|---------+--- -------------------------------------	*/
	    sprintf( mrg_inpline,     "%d,%d           ", temp->major, temp->minor );
	    sprintf(&mrg_inpline[ 8], "%3d %8d %15.9f %5d  M   %c %10ld + %ld [vMerge]", 
		lst_action->cpu, lst_action->seqnum, lst_action->time, lst_action->pid,
		_prmtyp[ temp->prmtyp ], temp->sector, temp->length );

	    d1printf( "\nDBG[%05d]: -------------------------------------------\n", __LINE__ );
	    q1printf( "DBG[%05d]: inject '%s'\n", __LINE__, mrg_inpline );

	    strcpy(sav_inpline, state.inpline);
	    strcpy(state.inpline, mrg_inpline);
            if (parse_event(&mrg_event, state.inpline) != 0) 
	    {
		printf( "%%F[%05d]-%s() fatal parse of constructed virtual merge event! Exit\n", __LINE__, __func__ );
		exit(1);
	    }
    	    bmerge_event(&mrg_event); /* Merge this event onto the end/back of an existing request */
	    strcpy(state.inpline, sav_inpline);

	    d1printf( "DBG[%05d]: post merge mainio %p %12ld,%6ld (next:%12ld)\n", __LINE__, io, io->sector, io->length, (io->sector + io->length) );
	    d1printf( "DBG[%05d]: -------------------------------------------\n\n", __LINE__ );
	    break;
	}
        /* Ok, there are two found == 0 cases, the normal one where the code has */
        /* found all the sectors needed and one where it hit a 'hole' in the     */
        /* discard..                                                             */
        if (found == 0) dxprintf( "DBG[%05d]: found %d bgn_sector %12ld end_sector %12ld\n", __LINE__, found, bgn_sector, end_sector );
	if ((found == 0) && (bgn_sector < end_sector))
	{
	    /* This must be one of those holes in the discard mentioned earlier */
	    /* So accumulate sectors in the hole and build a phantom merge for  */
	    /* the hole in the discard.  bad. really bad. So error log it.      */
            hole_sector= bgn_sector;				/* track end of hole            */
            hole_count = 0;
	    cur_sector = (int)(bgn_sector - this->sector);	/* offset from start of discard */
            cur_length = (int) temp->length;
            mapndx     = cur_sector >> 6;
            bitndx     = cur_sector & 0x3F;
	    d1printf( "DBG[%05d]: search next staged io @sector=%12ld missing from bitmap[%5d.%02d]=%016lX\n", __LINE__, bgn_sector, mapndx, bitndx, bitmap[mapndx] );
            while (cur_sector++ < this->length)
            {
                if ((bitmap[mapndx] & (1UL<<bitndx)) != 0) break;
                if (bitndx++ >= 0x3F) { bitndx = 0; mapndx++; }
		hole_sector++;
		hole_count++;
	    }
	    d1printf( "DBG[%05d]: search next staged io @sector=%12ld hole located:%12ld - %12ld,%ld (offset:%ld)\n", __LINE__, bgn_sector, bgn_sector,hole_sector-1,hole_count, (bgn_sector - this->sector) );
	    assert(hole_count != 0);
	
	    /* Hole is bgn_sector...(hole_sector-1) length=hole_count */
            /* #Maj,Mn CPU   SeqNo     Seconds     PID  Evt Typ Sector   +Len Description                               */
            /* #------ --- ------- --------------- -----|--|---|---------+--- -------------------------------------     */
            sprintf( mrg_inpline,     "%d,%d           ", this->major, this->minor );
            sprintf(&mrg_inpline[ 8], "%3d %8d %15.9f %5d  M   %c %10ld + %ld [@vMergeHole]",
                this->timeinfo.cpu, this->timeinfo.seqnum, this->timeinfo.time, this->timeinfo.pid,
                _prmtyp[ io->prmtyp ], bgn_sector, hole_count );

            d1printf( "\nDBG[%05d]: -------------------------------------------\n", __LINE__ );
            q1printf( "DBG[%05d]: hole   '%s'\n", __LINE__, mrg_inpline );

            strcpy(sav_inpline, state.inpline);
            strcpy(state.inpline, mrg_inpline);
            if (parse_event(&mrg_event, state.inpline) != 0)
            {
                printf( "%%F[%05d]-%s() fatal parse of constructed virtual merge event! Exit\n", __LINE__, __func__ );
                exit(1);
            }
            bmerge_event(&mrg_event); /* Merge this event onto the end/back of an existing request */
            strcpy(state.inpline, sav_inpline);

            d1printf( "DBG[%05d]: post merge mainio %p %12ld,%6ld (next:%12ld)\n", __LINE__, io, io->sector, io->length, (io->sector + io->length) );
            d1printf( "DBG[%05d]: -------------------------------------------\n\n", __LINE__ );
	    /* Continue processing the merge_list[] for additional chunks */
	    bgn_sector += hole_count;
	    nrbits     -= (int)hole_count;
	}
    }
    assert(nrbits == 0);
    assert(io != NULL );
    assert(io->sector == this->sector);
    assert(io->length == this->length);
       
    _return(io);
}



/**
 * ==========================================================================================
 * Function : search_staged_barrier1 - find 1st matching barrier on staged list
 *            @
 * Args       @this:	    current event info
 * Returns  : io            io structure found matching 'this' event, if any, null otherwise
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Must have sector/length = 0,0  -- general barriers with be against sector 0, length 0 aka no io.
 * Must have same/same io type as this event (FWS)
 * Must have KWIOBARRIER set
 * Must have all prior expected events present
 * Must not  have the current event type present
 *
 **/
typ_io *search_staged_barrier1(typ_event *this, char *eventname, int lineno)
{
int rw;
int len = strlen(eventname);
int lstndx;
typ_io *io, *temp;
unsigned long evtmask;
unsigned long my_mask;

    TRACE_FUNCTION;
    io = NULL;
    rw = R_OR_W(this);
    dprintf( "DBG[%05d]: search_staged_barrier1()\n", __LINE__ );
    dprintf( "DBG[%05d]: staged list[%5d] check for %10ld:%6ld match for %s...\n", __LINE__, staged_on_list, this->sector, this->length, eventname );

    /* Which prior events are expected? */
    switch (this->prmact)
    {
	case 'Q': my_mask = EVTMSK_Q; evtmask = (EVTMSK_A); break;
        case 'S': my_mask = 0;        evtmask = (EVTMSK_A | EVTMSK_Q); break;
	case 'G': my_mask = EVTMSK_G; evtmask = (EVTMSK_A | EVTMSK_Q); break;
	default : assert(0==1); evtmask = 0L; break;		/* should not happen */
    }

    for (lstndx=1, temp = staged_list; temp != (typ_io *)NULL; temp = temp->next, lstndx++)
    {
        d2printf( "DBG[%05d]: staged list[%5d]  %p %10ld:%6ld %c %s...\n", __LINE__, lstndx, temp, temp->sector, temp->length, 
			((temp->evtflags & EVTFLG_KWIOBARRIER) != 0)?'1':'0', temp->evttyp );
        if ( temp->sector != 0L                        ) continue;	
        if ( temp->length != 0L                        ) continue;
	if ((temp->evtflags & EVTFLG_KWIOBARRIER) == 0  ) continue;					/* this implies the next already */
	if ((strlen(temp->evttyp) == len) && (strncmp(temp->evttyp,eventname,len) != 0)) continue;
        dprintf( "DBG[%05d]: staged list[%5d]  %p %10ld:%6ld %s... match!\n", __LINE__, lstndx, temp, temp->sector, temp->length, temp->evttyp );
        if ( temp->minor  != this->minor               ) continue; /* not the same device             */
        if ( temp->major  != this->major               ) continue; /* not even same major device type */
	if ((temp->event_mask & my_mask)     != 0      ) continue;
	if ((temp->event_mask & evtmask)     != evtmask) continue;
        dprintf( "DBG[%05d]: staged list[%5d]  %p %10ld:%6ld... passed other filters!\n", __LINE__, lstndx, temp, temp->sector, temp->length );

	/* Ok, this is 1st match, return! */
	io = temp;
        dprintf( "DBG[%05d]: staged list  %p %10ld:%6ld... <= 1st hit\n", __LINE__, temp, temp->sector, temp->length );

	/* We know there can be multiple nested barriers that we could find */
	/* as "duplicates" if we continued to search, but don't.  By rules  */
	/* we match on first one matching all criteria.                     */
    }
    _return(io);
}

/**
 * ==========================================================================================
 * Function : search_mainio_barrier1 - find 1st matching barrier on mainio list
 *            @
 * Args       @this:	    current event info
 * Returns  : io            io structure found matching 'this' event, if any, null otherwise
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Must have sector/length = 0,0  -- general barriers with be against sector 0, length 0 aka no io.
 * Must have same io type of FWS (kinda a given if KWIOBARRIER set)
 * Must have KWIOBARRIER set
 * Must have all prior expected events present
 * Must not  have the current event type present
 *
 * Note: there should be only one active (post-dispatch) general FWS barrier at a time,
 *       there may be a bunch on mainio due to getreq G event, but only 1 D applied at
 *       a time and since all barriers are same/same we just want the first one to keep
 *       the timeline intact.
 *
 **/
typ_io *search_mainio_barrier1(typ_event *this, typ_io *io, char *eventname, int *onmain)
{
int rw;
int len = strlen(eventname);
int lstndx;
typ_io *temp;
unsigned long evtmask;
unsigned long my_mask;

    TRACE_FUNCTION;
    io = NULL;
    rw = R_OR_W(this);
    dprintf( "DBG[%05d]: search_mainio_barrier1()\n", __LINE__ );
    dprintf( "DBG[%05d]: mainio list[%5d]  check for %10ld:%6ld match for %s...\n", __LINE__, mainio_on_list, this->sector, this->length, eventname );

    /* Which prior events are expected? */
    switch (this->prmact)
    {
	case 'D': my_mask = EVTMSK_D; evtmask = (EVTMSK_A | EVTMSK_Q | EVTMSK_G); break;
	default : assert(0==1); evtmask = 0L; break;		/* should not happen */
    }

    for (lstndx=1, temp = mainio_list; temp != (typ_io *)NULL; temp = temp->next, lstndx++)
    { int flg;
	flg = ((temp->evtflags & EVTFLG_KWIOBARRIER) != 0)?1:0;
        d2printf( "DBG[%05d]: mainio list[%5d]  %p %10ld:%6ld %d %s...\n", __LINE__, lstndx, temp, temp->sector, temp->length, flg, temp->evttyp );
        if ( temp->sector != 0L                        ) continue;	
        if ( temp->length != 0L                        ) continue;
	if ((temp->evtflags & EVTFLG_KWIOBARRIER) == 0  ) continue;				/* this implies the next already     */
	if ((strlen(temp->evttyp) == 3) && (strncmp(temp->evttyp,"FWS",3) != 0)) continue;	/* This shouldn't actually be needed */
        dprintf( "DBG[%05d]: mainio list[%5d]  %p %10ld:%6ld %d %s... match!\n", __LINE__, lstndx, temp, temp->sector, temp->length, flg, temp->evttyp );
        if ( temp->minor  != this->minor               ) continue; /* not the same device             */
        if ( temp->major  != this->major               ) continue; /* not even same major device type */
	if ((temp->event_mask & my_mask)     != 0      ) continue; /* already in dispatch state       */ /* error error error will robinson, only 1 barrier @D at a time! */
	if ((temp->event_mask & evtmask)     != evtmask) continue;
        dprintf( "DBG[%05d]: mainio list[%5d]  %p %10ld:%6ld %d %s... passed other filters!\n", __LINE__, lstndx, temp, temp->sector, temp->length, flg, temp->evttyp );

	/* Ok, this is 1st match, return! */
	*onmain = 1;
	io = temp;
        dprintf( "DBG[%05d]: mainio list  %p %10ld:%6ld %d %s... <= 1st hit\n", __LINE__, temp, temp->sector, temp->length, flg, temp->evttyp );

	/* We know there can be multiple nested barriers, and they won't be */
	/* dispatched as only 1 can be dispatched/active at a time, so dont */
	/* continue searching for "duplicates" -- we know they could be     */
	/* present and by rules we only want the first match anyway.        */
    }
    _return(io);
}


/**
 * ==========================================================================================
 * Function : best_match_special1 - given current event and 1st + Nth matched io from list
 *                                  find "best match" for the event to call home
 *            @
 * Args       @this:	    current event info
 * Returns  : io            io structure found matching 'this' event, if any, null otherwise
 *
 * Description
 * This is best_match() specifically for the special case.1 (barrier like) io sequence.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * Normally upon detection of multiple matches, the code was giving up and throws an internal
 * logic fault.  This is not being postponed and moved into this routine if and only if this
 * routine cannot figure out which io context is best to be used for the current event.
 *
 * Multiple matches are on io typ:sector:length.  Nominally there should just be one, but if
 * there are overlapping io for the same sector then this routine needs to figure out which
 * of the N io contexts are "best" target for the event.
 *
 * The "best" is chosen via the following filter:
 *     1) check that each do not have current event type in context already
 *     2) check that pre-requisite events are present
 *     3) check is *exact* full io type, FWS and not just a write.
 *     4) chose earliest timestamp if get here and both still "qualified"
 *     track confidence of choice:
 *         - high: if only 1 of io or temp matches 1-3
 *         - good: if multiple matches and had to use tie breaker of earliest
 *                 time stamp
 * 
 * keep stats on:
 *     1) number of io context where best_match() was called against the context, 
 *     2) number of total calls
 *     3) number of high or good confidence matching
 *     4) fatal error if both events are disqualified, that's a logic error.
 *
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
typ_io *best_match_special1(typ_event *this, typ_io *io, typ_io *temp)
{
typ_io *best;
int io_qualified = 0;
int temp_qualified = 0;
int len;
int event_mask=0;
int debug_mask=0;
char string[64];

    TRACE_FUNCTION;
    dprintf( "DBG[%05d]: best_match_special1(%c,io=%p,temp=%p)\n", __LINE__, this->prmact, io, temp );
    /* Check 1: the current primary event cannot be already present in the io context */
    /*          qualified if the current event type is not present                    */
    switch(this->prmact)
    {
        case 'Q': if (  io->info->events.queue.line == LINENUM_NONE)   io_qualified |= 0x01;
	          if (temp->info->events.queue.line == LINENUM_NONE) temp_qualified |= 0x01;
                  debug_mask =  EVTMSK_Q;
		  event_mask = (EVTMSK_A);
		  break;
        case 'G': if (  io->info->events.getrq.line == LINENUM_NONE)   io_qualified |= 0x01;
	          if (temp->info->events.getrq.line == LINENUM_NONE) temp_qualified |= 0x01;
                  debug_mask =  EVTMSK_G;
	          event_mask = (EVTMSK_A | EVTMSK_Q);
		  break;
        case 'I': if (  io->info->events.insert.line == LINENUM_NONE)   io_qualified |= 0x01;
	          if (temp->info->events.insert.line == LINENUM_NONE) temp_qualified |= 0x01;
                  debug_mask =  EVTMSK_I;
	          event_mask = (EVTMSK_A | EVTMSK_Q | EVTMSK_G);
		  break;
        case 'C': if (  io->info->events.complete.line == LINENUM_NONE)   io_qualified |= 0x01;
	          if (temp->info->events.complete.line == LINENUM_NONE) temp_qualified |= 0x01;
                  debug_mask =  EVTMSK_C;
	          event_mask = (EVTMSK_A | EVTMSK_Q | EVTMSK_G | EVTMSK_I);
		  break;
	case 'A':
	case 'D': /* shouldn't happen. these are barrier 0:0 special case io that are never dispatched */
        default : break;
    }
    dprintf( "DBG[%05d]: [%13.9f] %c %s ; io %02X %04X: temp %02X %04X; debug_mask %04X (event not present)\n", __LINE__,
	this->timeinfo.time, this->prmact, this->evttyp, io_qualified, io->event_mask, temp_qualified, temp->event_mask, debug_mask );

    /* Check 2: the pre-requisites for the current event are present                  */
    /*          if all pre-requsistes events are set and only those events = qualify  */
    /* @@@TBD this one is getting tricker and tricker. Current data set is AQGDC, no I*/
    if ((  io->event_mask ^ event_mask) == 0)   io_qualified |= 0x02;
    if ((temp->event_mask ^ event_mask) == 0) temp_qualified |= 0x02;
    dprintf( "DBG[%05d]: [%13.9f] %c %s ; io %02X %04X: temp %02X %04X; event_mask %04X (pre-reqs present )\n", __LINE__,
	this->timeinfo.time, this->prmact, this->evttyp, io_qualified, io->event_mask, temp_qualified, temp->event_mask, event_mask );

    /* Check 3: check full io type is *exactly* the same (with some notable excepts)  */ /* FWFS => WFS later events, for example */
    /*          special in special1: if this is C and evtyp is WS, change this to FWS */
    strcpy(string,this->evttyp);
    len = strlen(string);
    if (this->prmact == 'C')
    {
	/* Do we need to change the event string? */
	if ((strlen(io->evttyp) == 3) && (strncmp(io->evttyp,"FWS",3) == 0))	
	{
	    if ((len == 2) && (strncmp(string,"WS",2)==0))
	    {
		strcpy(string,"FWS");
		len = 3;
	    }
	}
    }
    if ((strlen(  io->evttyp) == len) && (strncmp(  io->evttyp,string,len)==0))   io_qualified |= 0x04;
    if ((strlen(temp->evttyp) == len) && (strncmp(temp->evttyp,string,len)==0)) temp_qualified |= 0x04;
    dprintf( "DBG[%05d]: [%13.9f] %c %s ; io %02X %4s: temp %02X %4s \n", __LINE__,
	this->timeinfo.time, this->prmact, this->evttyp, io_qualified, io->evttyp, temp_qualified, temp->evttyp );

    /* Ok, both, 1, or none typ_io context passed in qualified at this point? */
    /* Check 4: use timestamp to discriminate which to use only if both qual'd*/
    best = NULL;
    if ((io_qualified == 0x07) && (temp_qualified == 0x07))
    {
	/* both qualified.  Use timestamp as tie breaker */
	dprintf( "DBG[%05d]: best_match_special1() both context fully qualified, choosing by time\n", __LINE__ );
	if (io->timeinfo.time <= temp->timeinfo.time)
	{
	    best = io;
	    dprintf( "DBG[%05d]: best_match_special1(), choose   'io' (newest) [%13.9f] %c %s\n", __LINE__, best->timeinfo.time, best->prmact, best->evttyp );
	}
        else
	{
	    best = temp;
	    dprintf( "DBG[%05d]: best_match_special1(), choose 'temp' (oldest) [%13.9f] %c %s\n", __LINE__, best->timeinfo.time, best->prmact, best->evttyp );
	}
	state.best_match_special1_good++;
    }
    else if ((io_qualified == 0x07) && (temp_qualified != 0x07))
    {
	best = io;
	dprintf( "DBG[%05d]; best_match_special1(), Nth 'temp' disqualified (oldest)\n", __LINE__ );
	dprintf( "DBG[%05d]: best_match_special1(), 1st   'io'    qualified (newest) [%13.9f] %c %s\n", __LINE__, best->timeinfo.time, best->prmact, best->evttyp );
	state.best_match_special1_high++;
    }
    else if ((io_qualified != 0x07) && (temp_qualified == 0x07))
    {
	best = temp;
	dprintf( "DBG[%05d]; best_match_special1(), 1st   'io' disqualified (newest)\n", __LINE__ );
	dprintf( "DBG[%05d]: best_match_special1(), Nth 'temp'    qualified (oldest) [%13.9f] %c %s\n", __LINE__, best->timeinfo.time, best->prmact, best->evttyp );
	state.best_match_special1_high++;
    }
    else if ((io_qualified != 0x07) && (temp_qualified != 0x07))
    { int   io_score1,     io_score2;
      int temp_score1,   temp_score2;
      int  flg_guess1,    flg_guess2;
      int   flg_weak1,     flg_weak2,   flg_weak3;
      int flg_oldest1,   flg_oldest2, flg_oldest3;
      typ_io *choice1,      *choice2;
      int   mask;

	/* ---Special--------------------------------------------------*/
	/* neither matched? Huh? Need to call a manager for assistance */
	if (((io_qualified != 0x05) && (temp_qualified != 0x05)) || 
            ((this->prmact != 'I' ) && (this->prmact   != 'C' )))
	{
	    /* Neither passed rules 1&3? hmmm.				  */
	    /* In this case, if conf_barrier_match_policy is set to allow */
	    /* a choice, just return io or better yet null -- but define  */
	    /* this config to allow an imposed choice to avoid a logic    */
	    /* fault because the code cannot find a reasonable match and  */
	    /* actually considers both to be disqualified from matching   */
	    /* and thus use.                                              */
	    switch (conf_barrier_match_policy)
	    {
	        case  2: _return(     io       );
		case  1: _return((typ_io *)NULL);
		case  0:
		default: printf( "%%F[%05d]-internal logic fault: best_match_special1() found neither qualified: [%13.9f] %c %s :: [%13.9f] %c %s , [%13.9f] %c %s\n", __LINE__,
	        		this->timeinfo.time, this->prmact, this->evttyp,
                		io->timeinfo.time,   io->prmact,   io->evttyp,
                		temp->timeinfo.time, temp->prmact, temp->evttyp );
			DATA_FEATURE_FAULT(this,(typ_io *),"best_match failed to resolve to target io",CTL_FAULT_DEFAULT);
	    }
	}
	dprintf( "DBG[%05d]:best_match_special1(0x%02X v 0x%02X) found neither is fully qualified: [%13.9f] %c %s :: [%13.9f] %c %s , [%13.9f] %c %s\n", __LINE__,
				io_qualified, temp_qualified, 
	        		this->timeinfo.time, this->prmact, this->evttyp,
                		io->timeinfo.time,   io->prmact,   io->evttyp,
                		temp->timeinfo.time, temp->prmact, temp->evttyp );

	/* If one of both are 0x05, that means test 1 and 3 are ok, its test 2 -- pre-requisite events */
	/* that is the issue... and we know that one is sticky.  The event_mask is the allowable pre   */
	/* events are preference is that all are present.  We need to look for what is present .. and  */
	/* choose better choice.                                                                       */
	/* The problem here is we're choosing better of current two choices.  Hopefull reiteration     */
	/* gets us the "best" choice of the set.                                                       */
	io_score1   = io_score2   = 0;
	temp_score1 = temp_score2 = 0;

	/* Whether I or C events, the first part about A|Q is the same */
	/* For I we'd like but not require G                           */
	/* For C we'd like but not require G|I                         *//* but having one or both makes this a better choice than one without */
	/* We need to choose one of these events as "best" choice event*/
	/* when that choice is a weak or less optimal choice than we'd */
	/* like.  At least until a dataset comes along that shows that */
	/* making a suboptimal choice is fundamentally wrong           */
	if (  io->info->events.remap.line != LINENUM_NONE)   io_score1 |= 0x1;
	if (  io->info->events.queue.line != LINENUM_NONE)   io_score1 |= 0x2;
	if (  io->info->events.getrq.line != LINENUM_NONE)   io_score2 |= 0x1;
	if (  io->info->events.insert.line!= LINENUM_NONE)   io_score2 |= 0x2;
	if (temp->info->events.remap.line != LINENUM_NONE) temp_score1 |= 0x1;
	if (temp->info->events.queue.line != LINENUM_NONE) temp_score1 |= 0x2;
	if (temp->info->events.getrq.line != LINENUM_NONE) temp_score2 |= 0x1;
	if (temp->info->events.insert.line!= LINENUM_NONE) temp_score2 |= 0x2;


	/* For 'I' and 'C' event, the first part of this is same/same for both */
        /* A good choice vs weak won't need G event test -- only need that for tie breaker */
	/* We want the most "mature" choice.  This means the one with the most meaningful  */
	/* total event count.  The A|Q are more heavily weighed than the G which is option */
	choice1 = (typ_io *)NULL;
	flg_weak1 = flg_guess1 = 0; flg_oldest1 = 0;
	switch (io_score1 + (temp_score1*4))
	{
            case  0: /* --  | --- */ /* neither is good choice, go with io */ /* guess */ choice1 = io; flg_weak1++; flg_guess1++; break;
            case  1: /* A|Q | --- */ /* weak io             | weak = A|Q, good = A+Q   */ choice1 = io; flg_weak1++; break;
            case  2: /* A&Q | --- */ /* good io				               */ choice1 = io;              break;
	    case  3: printf( "DBG[%05d]: best match failed? io_score1=%d ; temp_score1=%d ; case=%d\n", __LINE__,
				     io_score1, temp_score1, (io_score1 + (temp_score1*4)) );
	                             __assert(0==1);
            case  4: /* --- | A|Q */ /*          weak temp			       */ choice1 = io; flg_weak1++; break;
            case  5: /* A|Q | A|Q */ /* weak io, weak temp			       */ flg_oldest1++;flg_weak1++; break;
            case  6: /* A&Q | A|Q */ /* good io, weak temp                             */ choice1 = io;              break;
	    case  7: printf( "DBG[%05d]: best match failed? io_score1=%d ; temp_score1=%d ; case=%d\n", __LINE__,
				     io_score1, temp_score1, (io_score1 + (temp_score1*4)) );
	                             __assert(0==1);
            case  8: /* --- | A&Q */ /*          good temp                             */ choice1 = temp ;           break;
	    case  9: /* A|Q | A&Q */ /* weak io, good temp                             */ choice1 = temp;            break;
	    case 10: /* A&Q | A&Q */ /* good io, good temp                             */ flg_oldest1++;             break;

	    case 15: /* A&Q + A&Q */ /* evenly matched, can't choose so choose earliest io based on first.time only */
		     flg_oldest1++;
	             if (io->info->events.first.time <= temp->info->events.first.time)  choice1 = io;
		     else                                                               choice1 = temp;
		     printf( "%%W[%05d]: no best match located, choosing earliest io %11.8f from (%11.8f,%11.8f) set.\n", __LINE__,
				  choice1, io, temp );
		     break;
	    default: printf( "DBG[%05d]: best match failed? io_score1=%d ; temp_score1=%d ; case=%d\n", __LINE__,
				     io_score1, temp_score1, (io_score1 + (temp_score1*4)) );
		     		     __assert(0==1);
	}
	if (flg_oldest1 != 0)
	{
	    if (io->timeinfo.time <= temp->timeinfo.time) choice1 = io;
            else                                          choice1 = temp;
	}

	/* For 'I' and 'C' the 2nd part about G|I events is event specific */
	/* Except not.  To get this far, rule #1 has to have passed -- in  */
	/* case of I event, the io/temp can not have had I event present to*/
	/* pass rule 1 and get to here.  So, the score affecting I score   */
	/* won't ... so use same logic for both I and C events             */
	choice2 = (typ_io *)NULL;
	flg_weak2 = flg_guess2 = flg_oldest2 = 0;
	switch (io_score2 + (temp_score2*4))
	{
	    case  0: /* --- | --- */ /* neighter is a good choice, go with io */ /* guess */ choice2 = io; flg_weak2++; flg_guess2++; break;
	    case  1: /* G|I | --- */ /* weak  io  |           */ choice2 = io;   flg_weak2++; break;
	    case  2: /* G&I | --- */ /* good  io  |           */ choice2 = io;                break;
	    case  3:                __assert(0==1);
	    case  4: /* --- | G|I */ /*           | weak temp */ choice2 = temp; flg_weak2++; break;
	    case  5: /* G|I | G|I */ /* weak io   | weak temp */ flg_oldest2++;  flg_weak2++; break;
	    case  6: /* G&I | G|I */ /* good io   | weak temp */ choice2 = io;                break;
	    case  7:                __assert(0==1);
	    case  8: /* --- | G&I */ /*           | good temp */ choice2 = temp;              break;
	    case  9: /* G|I | G&I */ /* weak io   | good temp */ choice2 = temp;              break;
	    case 10: /* G&I | G&I */ /* good io   | good temp */ flg_oldest2++;               break;
	    default:                __assert(0==1);
	}

	if (flg_oldest2 != 0)
	{
	    if (io->timeinfo.time <= temp->timeinfo.time) choice2 = io;
            else                                          choice2 = temp;
	}

	/* Ohkay. time for final answer */
        mask = 0; flg_oldest3 = 0;
	if (flg_weak1 ==  0 ) mask |= 0x1;
	if (choice1   == io ) mask |= 0x2;
	if (flg_weak2 ==  0 ) mask |= 0x4;
	if (choice2   == io ) mask |= 0x8;
	switch(mask)
        {
	    case  0: /* weak;temp | weak|temp */ best = temp;  flg_weak3++; break;
	    case  1: /* good;temp | weak|temp */ best = temp;               break;
	    case  2: /* weak;  io | weak|temp */ flg_oldest3++;flg_weak3++; break;
	    case  3: /* good;  io | weak|temp */ best =   io;               break;
	    case  4: /* weak;temp | good|temp */ best = temp;               break;
	    case  5: /* good;temp | good|temp */ best = temp;               break;
	    case  6: /* weak;  io | good|temp */ best = temp;               break;
	    case  7: /* good;  io | good|temp */ flg_oldest3++;             break;

	    case  8: /* weak;temp | weak|  io */ flg_oldest3++;flg_weak3++; break;
	    case  9: /* good;temp | weak|  io */ best = temp;               break;
	    case 10: /* weak;  io | weak|  io */ best =   io;  flg_weak3++; break;
	    case 11: /* good;  io | weak|  io */ best =   io;               break;
	    case 12: /* weak;temp | good|  io */ best =   io;               break;
	    case 13: /* good;temp | good|  io */ flg_oldest3++;             break;
	    case 14: /* weak;  io | good|  io */ best =   io;               break;
	    case 15: /* good;  io | good|  io */ best =   io;               break;
	    default: __assert(0==1);
	}

	if (flg_oldest3 != 0)
	{
	    if (choice1->timeinfo.time <= choice2->timeinfo.time) best = choice1;
            else                                                  best = choice2;
	}

	dprintf( "DBG[%05d]: best_match_special1(0x%02X v 0x%02X) %p v %p ; best = %p\n", __LINE__,
				io_qualified, temp_qualified, io, temp, best );
	dprintf( "DBG[%05d]:   event  [%13.9f] %c %s '%s'\n", __LINE__,
	        		this->timeinfo.time, this->prmact, this->evttyp, this->event_text );
	dprintf( "DBG[%05d]:      io  [%13.9f] %c %s '%s'\n", __LINE__,
                		io->timeinfo.time,   io->prmact,   io->evttyp, _showmask(io->event_mask));
	dprintf( "DBG[%05d]:    temp  [%13.9f] %c %s '%s'\n", __LINE__,
                		temp->timeinfo.time,   temp->prmact,   temp->evttyp, _showmask(temp->event_mask));
	dprintf( "DBG[%05d]:      io %p %d %d   (ptr, score1, score2)\n", __LINE__, io, io_score1, io_score2 );
	dprintf( "DBG[%05d]:    temp %p %d %d   (ptr, score1, score2)\n", __LINE__, io, io_score1, io_score2 );
        dprintf( "DBG[%05d]: choice1 %p %d %d %d (ptr, flg_weak, flg_oldest, flg_guess)\n", __LINE__, choice1, flg_weak1, flg_oldest1, flg_guess1 );
        dprintf( "DBG[%05d]: choice2 %p %d %d   (ptr, flg_weak, flg_oldest)\n", __LINE__, choice2, flg_weak2, flg_oldest2 );
        dprintf( "DBG[%05d]:    best %p %d %d   (ptr, flg_weak, flg_oldest)\n", __LINE__,    best, 0,         flg_oldest3 );
	dprintf( "DBG[%05d]:---------------------------------------------------------------------------------\n", __LINE__ );

	/* Ok, a quick sanity */
	if ((best == io) && (io_qualified != 0x05))
	{
	    PROG_FEATURE_FAULT(NULL,(typ_io *), "fatal internal logic fault, wrong tie breaker chosen (  io)",CTL_FAULT_FORCE);
	}
	if ((best == temp) && (temp_qualified != 0x05))
	{
	    PROG_FEATURE_FAULT(NULL,(typ_io *),"fatal internal logic fault, wront tie breaker chosen (temp)",CTL_FAULT_FORCE);
	}
    }
    else
    {
	/* neither matched? Huh? Need to call a manager for assistance. ok karen. */
        PROG_FEATURE_FAULT(NULL,(typ_io *),"internal logic fault, should never get here!",CTL_FAULT_FORCE);
    }
	

    state.best_match_special1_checks++;
    if (((  io->evtflags & EVTFLG_BESTMATCH) == 0) &&
        ((temp->evtflags & EVTFLG_BESTMATCH) == 0))
        state.best_match_special1_contexts++;
      io->evtflags &= ~EVTFLG_BESTMATCH;	/* Clear this flag on both input contexts */
    temp->evtflags &= ~EVTFLG_BESTMATCH;
    best->evtflags |=  EVTFLG_BESTMATCH;	/* And set on found best match            */
    dprintf( "DBG[%05d]: return best match %p\n", __LINE__, best );

    _return(best);
}



/**
 * ==========================================================================================
 * Function : check_staged_special1 - search for an io on the staged list that matches special1
 *            @
 * Args       @this:	    current event info
 * Returns  : 1             found special matching criteria
 *
 * Description
 * Search the mainio list of special matching io.
 * if event == Q, then its is an io that matches the same full event type (FWS for example),
 *                and has valid sector:length of 0:0.
 * if other     , then its an io that is marked special and has 0:0 present.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int check_staged_special1(typ_event *this, char *eventname )
{
int rw;
int lstndx;
typ_io *io, *temp;

    TRACE_FUNCTION;
    io = NULL;
    rw = R_OR_W(this);
    dprintf( "DBG[%05d]: check_staged_special1() - do possible 'barrier' type specials match on mainio (called from parse_event()).\n", __LINE__ );
    /* dump_staged_list(); */
    dprintf( "DBG[%05d]: staged list[%5d] check for  %10ld:%6ld match for %s...\n", __LINE__, staged_on_list, 0L, 0L, eventname );
    for (lstndx=1, temp = staged_list; temp != (typ_io *)NULL; temp = temp->next, lstndx++)
    {
        dprintf( "DBG[%05d]: staged list[%5d]  %p %10ld:%6ld...\n", __LINE__, lstndx, temp, temp->sector, temp->length );
        if ( temp->sector != 0L                        ) continue;
        if ( temp->length != 0L                        ) continue;
        dprintf( "DBG[%05d]: staged list[%5d]  %p %10ld:%6ld... match!\n", __LINE__, lstndx, temp, temp->sector, temp->length );
        if ( R_OR_W(temp)                         != rw) continue; /* not the same (broad) type of io */
        if ((temp->evtflags & EVTFLG_VALID_SECTOR) == 0) continue; /* doesn't have valid sector numb  */
        if ((temp->evtflags & EVTFLG_VALID_SIZE  ) == 0) continue; /* doesn't have valid size   numb  */
        if ( temp->major            != this->major     ) continue; /* not even same major device type */
        if ((temp->minor & 0xFFF0)  != this->minor     ) continue; /* not the same device             */
        dprintf( "DBG[%05d]: staged list[%5d]  %p %10ld:%6ld... passed other filters!\n", __LINE__, lstndx, temp, temp->sector, temp->length );

	/* Ok, final matching.  If Q, no special set, if anything else it must have SPCFLG_00 set from */
	/* prior Q event matching A event							       */
	if ((this->prmact != 'Q') && ((temp->specials & SPCFLG_00     ) ==            0)) continue;
	if ((this->prmact == 'C') && ( temp->info->events.dispatch.line != LINENUM_NONE)) continue;
	if ( this->prmact == 'Q') temp->minor &= 0xFFF0;	/* remove any partition for this special corner case, no idea why... */

        if (io == NULL)
        {
            /* first match! */
            io = temp;
            dprintf( "DBG[%05d]: staged list  %p %10ld:%6ld... <= 1st hit\n", __LINE__, temp, temp->sector, temp->length );
        }
        else
        {
            /* @@@TBD - resolve conflicting io for same lba & size */
            /*          which is different than detection overlap  */
            /*          in that overlap can be diff lba+len but    */
            /*          still partially overlap this new one       */
            printf( "DBG[%05d]: staged list  %p %10ld:%6ld... <= 1st hit\n", __LINE__, io  ,  io->sector,   io->length );
            printf( "DBG[%05d]: staged list  %p %10ld:%6ld... <= Nth hit\n", __LINE__, temp, temp->sector, temp->length );
            printf( "DBG[%05d]: continue, best_match_special1() will be used to determine which to use\n", __LINE__);
        }
    }
    if (io != NULL) _return(1);
    _return(0);
}



/**
 * ==========================================================================================
 * Function : dbg_add_event_to_io(typ_event *this, typ_io *io, int srcline, char *annotation)
 *            @
 * Args     : @this:       current parsed event being processed
 *            @io:	   io structure/context the event is being "absorbed" into
 *            @annotation: optional string to be added to cloned event, if null then
 *                         any current string in event is not changed [although the 
 *                         srcline is added to the beginning to indicate the srcline
 *                         that added this event to the io context).
 *
 * Returns  : 0
 *
 * Description
 * Clone the event and add it to the debug list attached to the specified io/request.  This 
 * list is in "as processed" order -- which nominally means input line number/time order...
 * except for cases of 2nd hand merging as events in one event will be added to another and
 * those will be "out of time/line" order but are in "as processed" order.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * typ_ioinfo:
 *     int           dbg_num_events;       /- Number of events on the following process ordered FIFO (first on top)        -/
 *     typ_event    *dbg_events;           /- First event that was "absorbed" into this context                            -/
 *     typ_event    *dbg_last_event;       /- Last  event on FIFO list, new events as encountered/processed added to end   -/
 *
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int dbg_add_event_to_io(typ_event *this, typ_io *io, int srcline, char *annotation)
{
    TRACE_FUNCTION;
#   ifdef DEBUG
typ_event *clone;

    dprintf( "DBG[%05d]: dbg_add_event_to_io() %c %d:%12ld:%8ld %13.9f -> %p %s\n", __LINE__,
	this->prmact, this->prmtyp, this->sector, this->length, this->timeinfo.time, io, _showmask(io->event_mask));

    clone = clone_event(this);
    if ((annotation != NULL) && (annotation[0] != 0))
	sprintf( clone->reason, "[%05d] %s", srcline, annotation );
    else if (srcline > 0)
    { static char tmpstring[MAXBUF];
	strcpy(tmpstring,clone->reason);
        sprintf( clone->reason, "[%05d] %s", srcline, tmpstring );
    }
    
    if ((io->info->dbg_num_events++) == 0)
	io->info->dbg_events = io->info->dbg_last_event = clone;
    else
    {
	io->info->dbg_last_event->next = clone;
        io->info->dbg_last_event       = clone;
    }
#   endif
    _return(0);
}

/**
 * ==========================================================================================
 * Function : dbg_out_events_in_io(typ_io *io, FILE *filf)
 *            @
 * Args     : @io:	   io structure/context the event is being "absorbed" into
 *
 * Returns  : 0
 *
 * Description
 * If conf_merged_event_debug is '1' and -DDEBUG added the list to typ_io, then output the list of
 * events attached to the io structure/context to main outf file.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * typ_ioinfo:
 *     int           dbg_num_events;       /- Number of events on the following process ordered FIFO (first on top)        -/
 *     typ_event    *dbg_events;           /- First event that was "absorbed" into this context                            -/
 *     typ_event    *dbg_last_event;       /- Last  event on FIFO list, new events as encountered/processed added to end   -/
 *
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int dbg_out_events_in_io(typ_io *io, FILE *filf)
{
    TRACE_FUNCTION;
#   ifdef DEBUG
int slen, spad, cnt;
typ_event *this;

    if (conf_merged_event_debug != 1) _return(0);
    
    if (io->info == NULL)
    {
        fprintf( filf, "xxxx: [%08d] dbg_out_event_io_io(%p %10ld:%6ld) has no info struct to dump\n\n", __LINE__, io, io->sector, io->length );
	_return(0);
    }
    if (io->info->dbg_events == NULL)
    {
        fprintf( filf, "xxxx: [%08d] dbg_out_event_io_io(%p %10ld:%6ld) has no info->dbg_events to dump\n\n", __LINE__, io, io->sector, io->length );
	_return(0);
    }
    for (cnt=1, this=io->info->dbg_events; (cnt<=io->info->dbg_num_events) && (this != NULL); cnt++, this=this->next)
    {
	slen = strlen(this->event_text);
        spad = 80 - slen;
        if (spad <= 0) spad = 1;
	fprintf( filf, "%4d: [%08d] '%s' %*.*s ; %s%s\n", cnt,this->timeinfo.line, this->event_text, spad,spad," ", 
	    ((this->evtflags & EVTFLG_2NDHAND_MERGE)==0?"":"[2ndHand] "), this->reason );
    }
    if (io->info->dbg_num_events != 0)
	fprintf( filf, "\n");
#   endif
    _return(0);
}


/* SECTION: FUNCTION BLOCK ; EVENT PROCESSING */
/* ================================================================================================================= */
/* === EVENT PROCESSING ============================================================================================ */
/* ================================================================================================================= */

/* 
 * exceptionevent()        - event declared exception, process...
 * check_io_found()        - if none found, its orphan, should we create ghost for orphan or not and do so...
 * check_2ndhand_merging() - if no io found, and 'D', rather than assume orphan check active queue for 2nd hand merging
 * ghost_create()          - create a ghost typ_io/request/context if an orphan event is detected
 */


/**
 * ==========================================================================================
 * Function : exceptionevent(typ_event *this, int srcline, char *reason)
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns  : 0
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int exceptionevent(typ_event *this, int srcline, char *reason)
{
typ_event *clone;
int slen, spad;

    TRACE_FUNCTION;
#   ifdef DEEP_DEBUG2
    /* note: we're no longer building/maintaining a list of exceptions */
    /*       but rather immediately output them and be done with them  */
    /*       Retain in case of need to debug using exception list(?)   */

    /* clone the event to a malloc'd structure */
    /* add to end of the exception list so the */
    /* list is time fifo ordered, earliest on  */
    /* top of queue.  Bump the exception list  */
    /* counter                                 */
    clone = clone_event(this);
    if (state.last_exception == NULL)
    {
	state.exceptions     = clone;
        state.last_exception = clone;
    }
    else
    {
        state.last_exception->next = clone;
        state.last_exception       = clone;
    }
    state.num_exceptions;
#   else
    clone = this;
#   endif

    if ((reason != NULL) && (reason[0] != 0) && (clone->reason[0] == 0))
	sprintf( clone->reason, "[%05d] %s", srcline, reason );
    else if (srcline > 0)
    { static char tmpstring[MAXBUF];
	strcpy(tmpstring,clone->reason);
        sprintf( clone->reason, "[%05d] %s", srcline, tmpstring );
    }

    if ((this->evtflags & EVTFLG_EXCEPTDONE) == 0)
    {
	if (conf_exceptions_inhibit == 0)
        {
	    slen = strlen(clone->event_text);
            spad = 80 - slen;
            if (spad <= 0) spad = 1;
	    fprintf( excf, "%4d: [%08d] '%s' %*.*s ; %s [%016lX]\n", state.num_exceptions, 
	        clone->timeinfo.line, clone->event_text, spad,spad," ", clone->reason, this->evtflags );
	}
	printf( "DBG[%05d]: %s() %s\n", __LINE__, __func__, clone->reason );
	printf( "DBG[%05d]: %s() %s\n", __LINE__, __func__, state.inpline );
	this->evtflags |= EVTFLG_EXCEPTDONE;
	state.events_exceptions++;
	if ((this->prmact == 'P') || (this->prmact == 'U'))
	    state.events_exceptplugs++;
    }
    _return(0);
}

/**
 * ==========================================================================================
 * Function : remap_event -- process a reMap event
 * Args     : @this:       current event information
 * Returns  : 0
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Check to see if a staging io already exists (with Q but no A events)... at least until the
 * program figures out whether its  A->Q or Q->A.  That 2nd (Q->A) shouldn't happen -- we've 
 * not seen that in any of our data, but we need to check for it until the program verifies that
 * the event flow is A->Q.
 *
 * But that really should not happen (trust but verify).  It is expected we're going to have
 * to create a new typ_io and place it on the staging queue.  Transfer information from event 
 * to typ_io.  It will come off the staging queue and onto the active list at G/I/... or any
 * other event, really, except for M|F.  In M|F cases the io is turned into a subio and a
 * suitable mainio is searched for and subio added there.  But that's for later.
 *
 * Since remap events can stack, we cannot blindly just create a new typ_io block, but rather
 * look to see if the mapped from sector and length and from major,minor match an existing
 * typ_io block on the staging queue.  Is so, then this is a remap of that io.  So reuse and
 * update the typ_io block so identified. 
 *
 * For example:
 *   8,1   28        1     0.000000000  2682  A  WS 629454088 + 8 <- (253,4) 524594440
 *    ^                                             sector    +len    M,m    sector    (len=8)
 *    |                                               ^
 *    |                                               +-----------------------------------+
 *    |                                                                                   |
 *    +----------------------------------------------------------------+                  |
 *                                                                    +++                 |
 *   8,0   28        2     0.000000496  2682  A  WS 629456136 + 8 <- (8,1) 629454088      |
 *                                                             |                  |      |
 *                                                             +------------------+------+
 * In a remap, take the "from" sector and the length and search the staging list for a match
 * against the 'sector' + length fields, like above.  And also the major,minor from number to
 * the main major,minor of previously staged io -- this is needed to prevent the serendipity
 * matching on a sector that happens to be against, oh say, 8,0 in the above case instead of 8,1
 * as needed.
 * 
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Really should *not* find a matching io present unless there is a previous remap (or we're
 * seeing Q->A event stream sequencing... which shouldn't happen(?)).
 *
 * Blktrace event stream bug.
 * There is one or more blktrace package versions that generate "bad" event stream events for remaps.
 * Prior versions would show 234,9 > 8,7 -> 8,0  but now the dm merge indicates its target is the
 * base (non-partitioned!) device 8,0 and then a follow-on merge takes the same LBA and remaps it 
 * to the base device.  This makes it look like there are two different io, when infact its just one.
 * 08897    8,0    1     8148    10.492196176 28649  A  RA 16037566464 + 4096 <- (253,9) 16037564416     
 * 08897    8,0    1     8149    10.492196918 28649  A  RA 38965301248 + 4096 <- (8,7) 16037566464       
 * This event stream bug results in the first 253,9 remap creating an io merge context that is never
 * ever re-referenced.  So it sits in the staging queue forever resulting in tens to hundreds of 
 * thousands of events to wade through looking for an event match.  That clutter of orphan events 
 * really slows the program down.  Add code that does a 2nd fuzzy match on merging if and only if the
 * merge is from same maj,{partition}.
 *     + look for a LBA:length match to an io context that exists due to 'A' event (and only has 'A' events)
 *     + verify the current merge is from same maj device (aka we're merging from partition to base device)
 *     + and finally, sanity check event distance in time and line numbers.
 * If all of those factors line up, then this is the bug signature within the blktrace utility event stream
 * output and perform a match on that existing io context.  
 *
 *     ** THIS IS NOT FOOLPROOF **
 *
 * There are conditions where this could incorrectly match up to a existing staged io context -- but that is
 * a very small corner case and have very little actual chance of occurring.  IO would have to be simultaneously
 * happening at the dm and device level to same lba range, but independently.  Its possible, just highly unlikey.
 *
 * Also this won't work/be applied for nvme devices at this time as we cannot ensure that a maj,min number is
 * a base nvme0n1 device.
 *
 **/
int remap_event(typ_event *this)
{
typ_io *io, *temp, *best, *fuzzy_io;
typ_remaps *remap;
int     rw;
int     done;
int     nonio = 0;
int     staged= 0;
int     valid = 0;
int     errs  = 0;
int fuzzy_cnt, fuzzy_filter, fuzzy_evtmsk;
static char eventname[16]="remap     ";
#define MAX_FUZZY_REMAP_LINES 5000		/* highest seen in testing was 4000         line difference */
#define MAX_FUZZY_REMAP_TIME  0.100		/* highest seen in testing was 0.0557       time difference */
/* DBG[08914]: looking for @ 2.165115982:1430758112+   496, skip>  2.109355644:1430758112+   496 {fuzzy=0(3996, 0.055760338} */


    TRACE_FUNCTION;
    if (state.a_then_q == 0)
    {
        /* check to see if there is a matching Q event without an A */
        /* in staging event, if yes, then set a_then_q to -1        */
        /* and add the remap to that event                          */
        /* ...and return/done.                                      */
        state.a_then_q = 1; /* just assume for now its normal world */
    }
    if (state.a_then_q < 0)
    {
	/* this is weird, we're expecting Q->A but that is just     */
        /* wrong headed!  We need the remap from device to device   */
        /* for lba *before* we can queue the io                     */
	PROG_FEATURE_FAULT(this,(int),"Unsupported Q->A event flow.",CTL_FAULT_FORCE);
    }
    /* Ok, search the staging list for an existing typ_io block with*/
    /* from_sector in this event as the primary sector number in    */
    /* existing event (and same length and this event's from M,m is */
    /* same as primary M,m on existing typ_io block).               */
    io = NULL;
    if ((rw = R_OR_W(this))                      >= 0) valid++;
    if ((this->evtflags & EVTFLG_VALID_FROMSECT) != 0) valid++;
    if ((this->evtflags & EVTFLG_VALID_SECTOR  ) != 0) valid++;
    if ((this->evtflags & EVTFLG_VALID_SIZE    ) != 0) valid++;
    if (valid == 4)  /* A x Sector + Length <- (M,m) Sector */
    {
        /*   8,10   0      460     0.316492715  3774  A  WS 2196806 + 2 <- (253,3) 294214    */
        /*   8,0    0      461     0.316493483  3774  A  WS 68248934 + 2 <- (8,10) 2196806   */
	/* heat map                                                                          */
        /* find_remaps() and the remap[] array just tracks statistics of how many remaps are */
        /* being performed betweed pairs of devices.  253,3 to 8,10 and 8,10 to 8,0 above    */
        /* are two specific remaps[] statistics blocks tracked.                              */
	if ((remap = find_remaps(this->major, this->minor, this->from_major, this->from_minor)) != NULL)
	{
	    if (this->prmtyp == IOTYP_READ) 
	    {
		remap->read_count++;
	        remap->read_sectors += this->length;
	    }
            else if (this->prmtyp == IOTYP_WRITE)
	    {
		remap->write_count++;
		remap->write_sectors += this->length;
	    }
            else if (this->prmtyp == IOTYP_DISCARD)
            {
		remap->discard_count++;
		remap->discard_sectors += this->length;
	    }
	    else 
	    {
		printf( "%%E[%05d]-remAp type %d not counted.\n", __LINE__, this->prmtyp );
	    }
	}
	else
	{
	    printf( "%E[%05d]-remAp %d,%d to %d,%d not found in remaps[] list.\n", __LINE__,
		this->major, this->minor, this->from_major, this->from_minor );
	}

	if (special_nvme_partition != 0)
	{
	    if (special_nvme_main_major == 0)
	    {
		/* Capture maj,min of main device 				 */
		special_nvme_main_major = this->major;
		special_nvme_main_minor = this->minor;
	        /* Capture maj,min of part device 				 */
	        special_nvme_part_major = this->from_major;
	        special_nvme_part_minor = this->from_minor;
		logHprintf( "%%I[%05d]-capture nvme main device %d,%d and partition %d,%d\n", __LINE__,
		    special_nvme_main_major, special_nvme_main_minor,
	 	    special_nvme_part_major, special_nvme_part_minor );
	    }
	    else
	    {
		/* Verify that maj,min of main device matches */
		/* NOTE: 259,0 and 259,1 could be two different devices */
		/*       nvme0n1 nvme0n2 **OR** or could be partition   */
		/*       on same device nvme0n1p1 nvmeon1p2... until we */
		/*       can verify, output Warning.                    */
		if ((this->major != special_nvme_main_major) ||	
		    (this->minor != special_nvme_main_minor))
		{
		    errs++;
		    printf (        "%%W[%05d]-%d,%d main device from previous A events != %d,%d of this A event.\n", __LINE__,
			special_nvme_main_major, special_nvme_main_minor,
			this->major, this->minor );
		    fprintf( outf, "%%W[%05d]-%d,%d main device from previous A events != %d,%d of this A event.\n", __LINE__,
			special_nvme_main_major, special_nvme_main_minor,
			this->major, this->minor );
		}
		/* Verify that maj,min of part device matches */
		if ((this->from_major != special_nvme_part_major) ||	
		    (this->from_minor != special_nvme_part_minor))
		{
		    errs++;
		    fprintf( outf, "%%W[%05d]-%d,%d part device from previous A events != %d,%d of this A event.\n", __LINE__,
			special_nvme_part_major, special_nvme_part_minor,
			this->from_major, this->from_minor );
		}
	    }
        }
	/*
	 * You can next remaps, for example from lv (dm) to multipath (dm) to partition
	 * base physical device.  Typically there will only be 1 found, but there could
	 * potentially be many and then have to use find best option.
	 */
	dprintf( "DBG[%05d]: check for nested remap of %10ld:%6ld <- %10ld:%6ld(<<this!)...\n", __LINE__, this->sector, this->length, this->from_sector, this->length );
        fuzzy_io  = NULL;
        fuzzy_cnt = 0;
        for (temp = staged_list; temp != (typ_io *)NULL; temp = temp->next)
        {
            /* Look 1st for matching lba+len            */
            /* d1printf( "DBG[%05d]: stage list %10ld:%6ld %p\n", __LINE__, temp->sector, temp->length, temp ); */
            d3printf( "DBG[%05d]: stage list %12ld:%6ld %p | [%08d] %13.9f %-4s %-4s \n", __LINE__, temp->sector, temp->length, temp,
	        temp->timeinfo.line, temp->timeinfo.time, temp->evtact, temp->evttyp );

            if ( temp->sector != this->from_sector           ) continue; /* event 'from' !match prev sector */
            if ( temp->length != this->length                ) continue;
	    d1printf( "DBG[%05d]: stage list %12ld:%6ld [%06d] %p matched!\n", __LINE__, temp->sector, temp->length, temp->timeinfo.line, temp );
            if ( R_OR_W(temp)                           != rw) continue; /* not the same (broad) type of io */
            if ((temp->evtflags & EVTFLG_VALID_SECTOR  ) == 0) continue; /* doesn't have valid sector numb  */
            if ((temp->evtflags & EVTFLG_VALID_SIZE    ) == 0) continue; /* doesn't have valid size   numb  */
            if ((temp->evtflags & EVTFLG_VALID_FROMSECT) == 0) continue; /* can't be a remap, only want As  */

	    /* --- FUZZY MATCH LOGIC ---------------------------------------------------------------------- */	
	    /* Ok, this is where we need to insert logic for fuzzy merge map detection related to the       */
            /* blktrace utility "bug" (FN.102). Just in case. So we don't have to retread the same          */
            /* logic/search a second time.                                                                  */
	    if ( temp->major  == this->from_major            )
	    {
		/* event stream bug: could this be a fuzzy match?  With the bug 253,9 -> 8,0 instead of the */
                /*                   correct 8,7 and then a 2nd remap of 8,7 to 8,0 for same lba:length     */
                /*                   happens                                                                */
                /* + must be same major device (done above)						    */
                /* + must match LBA:length     (done above)						    */
                /* + must only have 'A' events present                                                      */
                /* + sanity:                                                                                */
                /*     . last 'A' event was within MAX_FUZZY_REMAP_LINES of event source input              */
                /*     . last 'A' event was within MAX_FUZZY_REMAP_TIME  of io context block		    */
                /*     . fuzzy_io must still be null (that is only one fuzzy match is allowed): later below */
		fuzzy_filter = 1;
                fuzzy_evtmsk = 0;
                dxprintf( "DBG[%05d]: fuzzy staged io mask %08X\n", __LINE__, temp->event_mask );
                dxprintf( "DBG[%05d]: fuzzy staged io line %8ld vs %8ld (%8ld)\n", __LINE__, 
		    temp->lstevt.timeinfo.line, this->timeinfo.line, (this->timeinfo.line - temp->lstevt.timeinfo.line ) );
                dxprintf( "DBG[%05d]: fuzzy staged io time %12.9f vs %12.9f (%12.9f)\n", __LINE__, 
		    temp->lstevt.timeinfo.time, this->timeinfo.time, (this->timeinfo.time - temp->lstevt.timeinfo.time ) );

		if                         ((temp->event_mask &  EVTMSK_A) == 0)  { fuzzy_evtmsk |= 1; fuzzy_filter = 0; }	/* must have a prior  remap  */
                if ((fuzzy_filter != 0) && ((temp->event_mask & ~EVTMSK_A) != 0)) { fuzzy_evtmsk |= 2; fuzzy_filter = 0; }	/* must not  have any others */
		if ((this->timeinfo.line - temp->lstevt.timeinfo.line) > MAX_FUZZY_REMAP_LINES) { fuzzy_evtmsk |= 4; fuzzy_filter = 0; }
		if ((this->timeinfo.time - temp->lstevt.timeinfo.time) > MAX_FUZZY_REMAP_TIME ) { fuzzy_evtmsk |= 8; fuzzy_filter = 0; }
		if (fuzzy_filter != 0)
		{
		    /* Save this fuzzy match for future in case needed 					    */
		    fuzzy_io = temp;
		    fuzzy_cnt++;
                    printf( "DBG[%05d]: looking for @%12.9f:%8lu+%6lu, found %12.9f:%8lu+%6lu {fuzzy=%d(%d,%12.9f}\n", __LINE__, 
		            this->timeinfo.time, this->from_sector, this->length, 
	                fuzzy_io->timeinfo.time, fuzzy_io->sector,  fuzzy_io->length, fuzzy_cnt,
			(this->timeinfo.line - temp->lstevt.timeinfo.line ),
                        (this->timeinfo.time - temp->lstevt.timeinfo.time ) );
		}
                else
                {
		    /* If we fuzzy matched an event before and all was well *except* line or time limits,   */
                    /* then the evtflags REMAPSKIP was set to avoid reporting a 2nd skip due to a rewrite or*/
                    /* re-read later.                                                                       */
		    if ((temp->evtflags & EVTFLG_REMAPSKIP) == 0) 
                    {
                        printf( "DBG[%05d]: looking for @%12.9f:%8lu+%6lu, skip> %12.9f:%8lu+%6lu {fuzzy=%d(%d,%12.9f} reject=%04X events=%016X\n", __LINE__, 
		            this->timeinfo.time, this->from_sector, this->length, 
	                    temp->timeinfo.time, temp->sector,      temp->length, fuzzy_cnt,
			   (this->timeinfo.line - temp->lstevt.timeinfo.line ),
                           (this->timeinfo.time - temp->lstevt.timeinfo.time ), fuzzy_evtmsk, temp->event_mask );
			if ((fuzzy_evtmsk & 0x3) == 0)
			{
			    /* then this failed soley on line/time limits       */
			    /* set the flag making this io context ineligible   */
			    /* for a fuzzy match later.  missed fuzzy matches   */
                            /* generate orphan staged events that hang around   */
                            /* for the rest of time -- this flag will hide them */
			    temp->evtflags |= EVTFLG_REMAPSKIP;
			}
		    }
		}

	    }
            if ( temp->minor  != this->from_minor            ) continue; /* not the same device             */
            if ( temp->major  != this->from_major            ) continue; /* not even same major device type */

            if ( temp->info->events.queue.line           != 0) continue; /* already has a Q event attached??*/

            dprintf ("DBG[%05d]: stage list passed filters!\n", __LINE__ );

	    /* Ohkay then.  Got through all the filter gates.  This   */
            /* seems to match a previous remap io.  Lets process.     */
            staged++;
            if (io == NULL)
            {
	        /* First (and hopefully only) one */
                io = temp;
                dprintf( "DBG[%05d]: looking for @%12.9f:%8lu+%6lu, found %12.9f:%8lu+%6lu\n", __LINE__, 
		this->timeinfo.time, this->from_sector, this->length, 
	          io->timeinfo.time,        io->sector,   io->length);
            }
            else
            {
                /* @@@TBD - resolve conflicting io for same lba & size */
                /*          which is different than detection overlap  */
                /*          in that overlap can be diff lba+len but    */
                /*          still partially overlap this new one       */
                printf( "DBG[%05d]: staged list  %p %10ld:%6ld... <= 1st hit\n", __LINE__,   io,   io->sector,   io->length );
                printf( "DBG[%05d]: staged list  %p %10ld:%6ld... <= Nth hit\n", __LINE__, temp, temp->sector, temp->length );
	        printf( "DBG[%05d]: %s()\n", __LINE__, __func__ );
                dump_staged_list(__LINE__);
	        dump_mainio_list(__LINE__);
		/* Odd case, but multiple A events for the same sector happening at same time! */
		/* So 2nd A event of nesting hits this.  For example:                          
                 *
                 * 371752   8,3    3    32894    53.330236986 126285  A   R 1575370340 + 2 <- (253,4) 1575368292  < instance #1
                 * 371753   8,3    2    56439    53.330236986 86260  A   R 1575370340 + 2 <- (253,4) 1575368292   < instance #2 -- same freakin' timestamp!!!
                 * 371754   8,0    2    56440    53.330237286 86260  A   R 1577473636 + 2 <- (8,3) 1575370340     < instance #1 -- hits 2 matching events and freaks
                 * 371755   8,0    3    32895    53.330237286 126285  A   R 1577473636 + 2 <- (8,3) 1575370340    <          #2
                 * 371756   8,0    2    56441    53.330237786 86260  Q   R 1577473636 + 2 [db2sysc]
                 * 371757   8,0    3    32896    53.330237886 126285  Q   R 1577473636 + 2 [db2sysc]
                 */
	        if ((best = best_match(this,io,temp)) != NULL) io = best;
            }
        }
    }
    else
    {
        dprintf( "DBG[%05d]: event is non-io, skip looking in stage queue...\n", __LINE__ );
        nonio = 1;
    }

    /* If a match wasn't found, but a fuzzy match was, sub in the fuzzy */
    if ((io == NULL) && (fuzzy_io != NULL) && (fuzzy_cnt == 1))
    {
        if (flag_remap_bug != 0)
        {
            dprintf ("DBG[%05d]: stage list passed (fuzzy) filters! Using %p %ld:%ld\n", __LINE__, fuzzy_io, fuzzy_io->sector, fuzzy_io->length);
            io = fuzzy_io;
	}
        else
        {
            dprintf ("DBG[%05d]: stage list passed (fuzzy) filters! Skipping %p %ld:%ld\n", __LINE__, fuzzy_io, fuzzy_io->sector, fuzzy_io->length);
	    dprintf ("DBG[%05d]: use -M flag to enable\n", __LINE__ );
	}
    }
 
    /* Did we find a nested remap, aka lv -> dm -> partition -> sd? */
    if (io != NULL)
    {
	/* existing io found, probably nesting remaps between block devices */
	/* track/capture A event info in events in context                  */
        io->event_mask       |= EVTMSK_A; /* @@ */
        set_event_mask( io,     EVTNDX_A );
	if (io->imbtyp == 0)
	{	
	    if (this->imbtyp != IMBTYP_NONE)
		printf( "DBG[%05d]: %s() set io imbtyp from event.\n", __LINE__, __func__ );
	    io->imbtyp = this->imbtyp;
	}

	/* show event was matched to an io */
	this->request = io;

	/* Nested remap events */
	dbg_add_event_to_io(this,io,__LINE__,NULL);

	/* nested remaps detected... */
	io->major  = this->major;
        io->minor  = this->minor;
        io->sector = this->sector;

	/* That should be it, don't need to save event as this is A->A->... */
	/* case so we only want to track that initial A event time/line, all*/
	/* other nested remaps are interesting only as far as to the info   */
	/* that leapfrogs to the new sector, new device. That's it.         */

        /* Basic housekeeping as in capture this last event associated w/io */
        io->lstcpu   = this->cpu;
        io->lstact   = this->prmact;
        strcpy(io->lsttyp, this->evttyp );
        bcopy(this, &io->lstevt, sizeof(typ_event));

        _assert(io->info != NULL);
        if (state.isPlugged == 1) io->info->plug_state |= PLUGSTATE_A;

	event_sig_add(io, this);	/* Add matched event signature to io context */

        dbg_lineno = __LINE__;
        annotate_event(this,3,io);
	_return(0);
    }

    /* Not nested remap, start a new io */
    dprintf( "DBG[%05d]: not on stage, new one, create.\n", __LINE__);
     printf( "DBG[%05d]: not on stage, new one, create.\n", __LINE__);
    io = create_io(this); /* reMap event */
        { /* audit */
          dprintf( "DBG[%05d]: event timeinfo line:time %6d:%12.9f  =>  %12.9f:%6d  merged io\n", __LINE__,
                this->timeinfo.line, this->timeinfo.time,
                  io->timeinfo.time,   io->timeinfo.line );
          dprintf( "DBG[%05d]: event first    line:time %6d:%12.9f  =>  %12.9f:%6d  merged io\n", __LINE__,
                this->timeinfo.line, this->timeinfo.time,
                  io->info->events.first.time, io->info->events.first.line );
        }

    /* Ok, Barrier check/mark time as this is newly created io...				*/
    /* An implicit barrier check was performed on the event use that information...		*/
    done = 0;
    if (this->imbtyp != IMBTYP_NONE)
        printf( "DBG[%05d]: check imbtype %d, imb_active_add() if IMBTYP_00(%d) or IMBTYP_S0(%d) set\n", __LINE__, this->imbtyp, IMBTYP_00, IMBTYP_S0 );
    switch (this->imbtyp)
    {
        case IMBTYP_xx  :  /* no   sector, no   length                                                       */ break;
        case IMBTYP_0x  :  /* ==0  sector, no   length                                                       */ break;

        case IMBTYP_00  :  /* ==0  sector, ==0  length                                                       */
        case IMBTYP_S0  :  /* > 0  sector, zero length                                                       */
			/* IO Barrier Detected: sect:len fields are valid/specified and are 0:0 meaning this is */
			/* **not** a data movement command.							*/
			/* @@@TBD really should also assert this is a write, barrier's are always write barrier */
			io->ioflags |= IS_IOBARRIER;
		
			/* We could count the barriers when they complete, but lets instead count them when     */
			/* issued so they show up in the 1s sampling when they were outstanding.                */
             		if (io->prmtyp == IOTYP_READ   ) { samp.cnt_barrier_reads++;    summ.cnt_barrier_reads++;    }
        		else if (io->prmtyp != IOTYP_DISCARD) { samp.cnt_barrier_writes++;   summ.cnt_barrier_writes++;   }
        		else                                  { samp.cnt_barrier_discards++; summ.cnt_barrier_discards++; }
			imb_active_add(io);
			done++;
			break;

        case IMBTYP_Sx  :  /* > 0  sector, no   length                                                       */ break;
        case IMBTYP_NONE:  /* not an implicit barrier                                                        */ break;
        default         : break;
    }

    if ((done == 0) && ((this->evtflags & EVTFLG_KWIOBARRIER) != 0))
    {
	/* The above should work in majority of cases, but this is backup plan                  */
	io->ioflags |= IS_IOBARRIER;
	printf( "%%E[%05d]-force setting IS_IOBARRIER for io: %c:%12ld.%06ld\n", __LINE__, _prmtyp(io->prmtyp), io->sector, io->length );

	/* We could count the barriers when they complete, but lets instead count them when     */
	/* issued so they show up in the 1s sampling when they were outstanding.                */
             if (io->prmtyp == IOTYP_READ   ) { samp.cnt_barrier_reads++;    summ.cnt_barrier_reads++;    }
        else if (io->prmtyp != IOTYP_DISCARD) { samp.cnt_barrier_writes++;   summ.cnt_barrier_writes++;   }
        else                                  { samp.cnt_barrier_discards++; summ.cnt_barrier_discards++; }
    }


    stats_check_boundary(io,1);  /* check for boundary crossing and handle queue idle time too  */
    add_io_to_staged(io);
    dbg_add_event_to_io(this,io,__LINE__,NULL);

    /* Basic housekeeping was performed in the create_io(), so skip  */
    this->request = io;
    if (io->info->ASeqNo == 0)
    {
        state.ASeqNo++;
	io->info->ASeqNo = state.ASeqNo;
    }
    dprintf( "DBG[%05d]: remap_event(), %p assigned ASeqNo = %lu\n", __LINE__, io, io->info->ASeqNo );

    event_sig_add(io, this);	/* Add matched event signature to io context */

    /* last thing before returning, output annotated event           */
    dbg_lineno = __LINE__;
    annotate_event(this,3,io);
    _return(0);
}

/**
 * ==========================================================================================
 * Function : queue_event -- process a 'Q'ueue event
 * Args     : @this:       current event information
 * Returns  : 0
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Find the staging io this belongs to, verify that its a good match.
 *
 * -or- create a new typ_io and place it on the staging
 * queue.  Transfer information from event to typ_io.  A Queue event should be unique per
 * io -- no multiple Q events.  At best there is a typ_io on the staging queue due to a remAp,
 * so if we do find an event that matches the lba+length of this one -- verify that its an 'A'
 * event .and. that the io type is the same.  Its possible (but not probable) that we could
 * have a Read and Write or Write and WS staged by remaps at the same time.  In the first case
 * we will select the correct staging io -or- create a new one if a match is not found.  In the
 * second case (Write + Write but with different modifiers), then we invoke best match for each
 * one of the same type that we find in the staging list.  But again, this will only happen when
 * overlapping io are present in the staging queue due to being there via remaps.  If the staged
 * io already has a Q event - its skipped as it can't possibly match this Q event given that Qs
 * are solitary events per io.
 *
 * We do not update inprogress counts until G or I time to allow the logic to figure out if this
 * is an actual io (+1 inprogress) or is M/F merge event (+0 inprogress). 
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Only have to search staging list, not possible to queue event to be applied to an io on the
 * active list.
 *
 * Really should *not* find a multiple matching io, but have to look for same.  The multiples
 * will occur if there are previous multiple remap events for same lba+length.  We'll also get
 * a lbs+len match on an overlapping io which is inserted by Q event, but that is discarded
 * because such already have a Q event present.
 *
 * Special Case(s)
 *   + KWIOBARRIER: 253,89  39       46     0.076047427 19690  Q FWS [mdX_raid10]
 *     . Search staged queue for 1st match w/KWIOBARRIER set, no Q event
 *     . If a match isn't found, create one... but log a complaint about doing so.
 *
 **/
int queue_event(typ_event *this)
{
typ_io *temp, *io, *best;
int rw;
int valid = 0;
typ_actions *actions, temp_actions;
int line;
int done;
double time;
static char eventname[16]="queue     ";

    TRACE_FUNCTION;
    if (state.a_then_q < 0)
    {
	/* this means we always create io and remap will come later */
        /* skipping for now */
    }
    io = NULL;
    if ((rw = R_OR_W(this))                    >= 0) valid++;
    if ((this->evtflags & EVTFLG_VALID_SECTOR) != 0) valid++;
    if ((this->evtflags & EVTFLG_VALID_SIZE  ) != 0) valid++;
    if (valid == 3)
    { 
        for (temp = staged_list; temp != (typ_io *)NULL; temp = temp->next)
        {
            /* Look 1st for matching lba+len 		*/
            /* d1printf( "DBG[%05d]: stage list %10ld:%6ld %p\n", __LINE__, temp->sector, temp->length, temp ); */
            d3printf( "DBG[%05d]: stage list %12ld:%6ld %p | [%08d] %13.9f %-4s %-4s \n", __LINE__, temp->sector, temp->length, temp,
	        temp->timeinfo.line, temp->timeinfo.time, temp->evtact, temp->evttyp );
	    if ( temp->sector != this->sector              ) continue;
            if ( temp->length != this->length              ) continue;
	    d1printf( "DBG[%05d]: stage list %12ld:%6ld %p matched!\n", __LINE__, temp->sector, temp->length, temp );
            if ( R_OR_W(temp)                         != rw) continue; /* not the same (broad) type of io */
            if ((temp->evtflags & EVTFLG_VALID_SECTOR) == 0) continue; /* doesn't have valid sector numb  */
            if ((temp->evtflags & EVTFLG_VALID_SIZE  ) == 0) continue; /* doesn't have valid size   numb  */
	    if ( temp->minor  != this->minor               ) continue; /* not the same device             */ 
            if ( temp->major  != this->major               ) continue; /* not even same major device type */

	    if ( temp->info->events.queue.line         != 0) continue; /* already has a Q event attached  */

	    d1printf( "DBG[%05d]: stage list %12ld:%6ld %p passed filters!\n", __LINE__, temp->sector, temp->length, temp );

	    if (io == NULL)
	    {
	        io = temp;
	    }
	    else
	    {
	        /* @@@TBD - resolve conflicting io for same lba & size */
	        /*          which is different than detection overlap  */
	        /*          in that overlap can be diff lba+len but    */
                /*          still partially overlap this new one       */
                d1printf( "DBG[%05d]: staged list  %p %10ld:%6ld... <= 1st hit\n", __LINE__,   io,   io->sector,   io->length );
                d1printf( "DBG[%05d]: staged list  %p %10ld:%6ld... <= Nth hit\n", __LINE__, temp, temp->sector, temp->length );
	        printf( "DBG[%05d]: %s()\n", __LINE__, __func__ );
                dump_staged_list(__LINE__);
	        dump_mainio_list(__LINE__);
	        /* Call best_match() to resolve which one to use       */
	        if ((best = best_match(this,io,temp)) != NULL) io = best;
            }
        }
    }
    else if ((this->evtflags & EVTFLG_KWIOBARRIER) != 0)
    {
	io = search_staged_barrier1(this,eventname,__LINE__);	
        if ((io == NULL) && (this->imbtyp == IMBTYP_xx))
        {
	    /* IMB_xx   ::
             *   FWS+KWIO :: 259,0    0        2     2.152242126 138872 Q FWFSM [kworker/0:0]
             *   FWS+KWIO :: 259,0   11       20     5.027074128  1889  Q FWFS  [jbd2/dm-4-8]
             *   FWS+KWIO :: 259,0    6        2     2.128390821 13905  Q FWS   [kworker/u24:6]
	     */

            /* ...might be other formats, but for now only allow this one.                  */
	    if ((this->iomask & (IOMASK_WRITE | IOMASK_SYNC | IOMASK_FLUSH)) == (IOMASK_WRITE | IOMASK_SYNC | IOMASK_FLUSH))
            {
                if ((io = imb_active_find(this)) != NULL)
                {
                    q0printf( "DBG[%05d]: looking for @%12.9f:%8lu+%6lu, found %12.9f:%8lu+%6lu on %s list\n", __LINE__,
                            this->timeinfo.time, this->sector, this->length,
                              io->timeinfo.time,   io->sector,   io->length,
                            "imb_active");
                    dprintf( "DBG[%05d]: looking for @%12.9f:%8lu+%6lu, found %12.9f:%8lu+%6lu on %s list\n", __LINE__,
                            this->timeinfo.time, this->sector, this->length,
                              io->timeinfo.time,   io->sector,   io->length,
                            "imb_active");

                    /* The code is expecting this to still be on the staged queue as it */
		    /* can't be moved until S,G,I type events detected -- or in really  */
		    /* corner cases D,C type events.                                    */
                    printf( "DBG[%05d]: %s(staged = %d)\n", __LINE__, __func__, io->ioflags & IS_STAGED );
		    _assert( ((io->ioflags & IS_STAGED) != 0) );
                }
            }
        }
        if (io == NULL)
        {   
            dprintf( "DBG[%05d]: new io to be created, KWIOBARRIER found no match in staged queue\n", __LINE__ );
        }
    }

    /* If no match and special is set, give a second special look */
    if ((io == NULL) && ((this->specials & SPCFLG_00) != 0))
	io = search_staged_special1(this,eventname,__LINE__);

    if (io == NULL)
    {
        /* new one: its ok to start an io on 'Q' event...		 */ /* ...or */
	/* will never be able to match to staging io so build new io     */ /* ...not read/write or no lba+len */
        io = create_io(this);        /* 'Q'ueue event */
        { /* audit */
	  dxprintf( "DBG[%05d]: event timeinfo line:time (this) %6d:%12.9f  =>  %12.9f:%6d (created io.timeinfo)\n", __LINE__,
		this->timeinfo.line, this->timeinfo.time,
	          io->timeinfo.time,   io->timeinfo.line );
	  dxprintf( "DBG[%05d]: event first    line:time (this) %6d:%12.9f  =>  %12.9f:%6d (created io.events.first)\n", __LINE__,
		this->timeinfo.line, this->timeinfo.time,
		  io->info->events.first.time, io->info->events.first.line );
	}

        /* Ok, Barrier check/mark time as this is newly created io...                               */
	/* An implicit barrier check was performed on the event use that information...             */
        done = 0;
        printf( "DBG[%05d]: check imbtype %d, call if IMBTYP_00(%d) or IMBTYP_S0(%d) set\n", __LINE__, this->imbtyp, IMBTYP_00, IMBTYP_S0 );
        switch (this->imbtyp)
        {
            case IMBTYP_xx  :  /* no   sector, no   length                                                       */ break;
            case IMBTYP_0x  :  /* ==0  sector, no   length                                                       */ break;
            case IMBTYP_S0  :  /* > 0  sector, zero length                                                       */
            case IMBTYP_00  :  /* ==0  sector, ==0  length                                                       */
                            /* IO Barrier Detected: sect:len fields are valid/specified and are 0:0 meaning this is */
                            /* **not** a data movement command.                                                     */
                            /* @@@TBD really should also assert this is a write, barrier's are always write barrier */
                            io->ioflags |= IS_IOBARRIER;
    
                            /* We could count the barriers when they complete, but lets instead count them when     */
                            /* issued so they show up in the 1s sampling when they were outstanding.                */
                            if (io->prmtyp == IOTYP_READ   ) { samp.cnt_barrier_reads++;    summ.cnt_barrier_reads++;    }
                            else if (io->prmtyp != IOTYP_DISCARD) { samp.cnt_barrier_writes++;   summ.cnt_barrier_writes++;   }
                            else                                  { samp.cnt_barrier_discards++; summ.cnt_barrier_discards++; }
			    imb_active_add(io);
                            done++;
                            break;
            case IMBTYP_Sx  :  /* > 0  sector, no   length                                                       */ break;
            case IMBTYP_NONE:  /* not an implicit barrier                                                        */ break;
            default         : break;
        }
        if ((done == 0) && ((this->evtflags & EVTFLG_KWIOBARRIER) != 0))
        {
	    /* The above should work in majority of cases, but this is backup plan                  */
	    io->ioflags |= IS_IOBARRIER;
	    printf( "%%E[%05d]-force setting IS_IOBARRIER for io: %c:%12ld.%06ld\n", __LINE__, _prmtyp(io->prmtyp), io->sector, io->length );

	    /* We could count the barriers when they complete, but lets instead count them when     */
	    /* issued so they show up in the 1s sampling when they were outstanding.                */
                 if (io->prmtyp == IOTYP_READ   ) { samp.cnt_barrier_reads++;    summ.cnt_barrier_reads++;    }
            else if (io->prmtyp != IOTYP_DISCARD) { samp.cnt_barrier_writes++;   summ.cnt_barrier_writes++;   }
            else                                  { samp.cnt_barrier_discards++; summ.cnt_barrier_discards++; }
        }

        stats_check_boundary(io,1);  /* check for boundary crossing and handle queue idle time too */
        add_io_to_staged(io);
        tprintf( "tDBG[%05d]: event %c:%16ld.%8ld assign queue time %13.9f\n", __LINE__, this->prmact, this->sector, this->length, this->timeinfo.time );
	if ((this->evtflags & EVTFLG_KWIOBARRIER) != 0)
	{
	    printf( "DBG[%05d]: event timeinfo line:time %6d:%12.9f  =>  %s\n", __LINE__,
		this->timeinfo.line, this->timeinfo.time, this->event_text );
	}
    }
    else
    {
        /* existing one, with remap but no queue, backfill as needed */
        /* but don't think any backfill actually needed in this type */
        /* of case as remap is optional                              */
        d1printf( "DBG[%05d]: looking for @%12.9f:%8lu+%6lu, found %12.9f:%8lu+%6lu\n", __LINE__, 
	    this->timeinfo.time, this->sector, this->length, 
              io->timeinfo.time,   io->sector,   io->length );

        if (io->info != NULL) actions = &io->info->events;
        else                  actions = &temp_actions;
        line = this->timeinfo.line;
        time = this->timeinfo.time;

        /* capture Q event info in events                           */
        io->event_mask       |= EVTMSK_Q; /* @@ */
	set_event_mask( io,     EVTNDX_Q );
	if (io->imbtyp == 0) io->imbtyp = this->imbtyp;
        actions->queue.line   = line; 
        actions->queue.time   = time;

        io->evtflags |= this->evtflags;
	if ((this->procname[0] != 0) && (io->procname[0] == 0))
        {
	    /* With A->A->...->Q, the first opportunity for a procname is Q */
            strcpy(io->procname, this->procname);
	}
	if ((this->extras[0] != 0) && (io->extras[0] == 0))
        {
            strcpy(io->extras  , this->extras  );
	}

	/* Now general housekeeping needed for a) all events, and b) Q specifically */
        io->lstcpu =  this->cpu;
        io->lstact =  this->prmact;
        strcpy(io->lsttyp, this->evttyp);
        bcopy(this, &io->lstevt, sizeof(typ_event));

        _assert(io->info != NULL);
        if (state.isPlugged == 1) io->info->plug_state |= PLUGSTATE_Q;

        tprintf( "tDBG[%05d]: event %c:%16ld:%8ld assign queue time %13.9f\n", __LINE__, _prmtyp(this->prmtyp), this->sector, this->length, this->timeinfo.time );
    }
    _assert( io != NULL );
    dbg_add_event_to_io(this,io,__LINE__,NULL);


    /* Assigning event Q/I/D/C timestamp processing.  Either we need */
    /* to hold off assigning QSeqNo until actual S/G/I time -or- we  */
    /* use ISeqNo as basis for iosched reordering -- that latter is  */
    /* more correct, so assign QSeqNo here, just know it doesn't mean*/
    /* what it used to mean (or be used for).                        */
    this->request = io;
    if ( io->info->QSeqNo == 0 )
    {
	d1printf( "DBG[%05d]: about to assert(io->info->QSeqNo != 0)!?\n", __LINE__ );
        dump_io_dbg(io);
    }
    _assert(io->info->QSeqNo == 0);
    state.QSeqNo++;
    io->info->QSeqNo = io->info->QSeqNo_Ghost = state.QSeqNo;

    /* inprogress stats are *not* updated here as this could be a    */
    /* merge.  The inprogress stats are only updated at insert time  */
    /* which could end up happening at backfill time                 */

    event_sig_add(io, this);	/* Add matched event signature to io context */

    /* last thing before returning, output annotated event           */
    dbg_lineno = __LINE__;
    annotate_event(this,3,io);
    _return(0);
}

/**
 * ==========================================================================================
 * Function : bmerge_event -- process a back merge event
 * Args     : @this:       current event information
 * Returns  : 0
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * First find the typ_io block on staging queue that this merge lba+length matches.  One should
 * be there specifically as a M is (A)->Q->M... although in some kernels it will be (A)->M only.
 * But for all current kernels, we should already have a typ_io on staged from the 'Q' event that
 * matches this lba+length.  But if not we'll need to create one and backfill Q field.
 *
 * Next, for a back/end merge, find another "mainio" that is the target that this merge is against.
 * "Find" means the other io ends an the sector before this one starts, and is of the same type
 * (read merged to read, write merged to write -- and possibly all the sync et.al. qualifiers
 * of same). While typically we expect us to find that mainio on the active list, it is possible
 * that its still on the staging list, so failing to find one on active list, try looking on the
 * staging list.  It would be on the staging list if we're in a kernel of (A)->Q->I and the insert
 * has not happened yet.  Or in a (A)->Q->(S)->(G)->I and neither a S or G event have happened.
 *
 *
 * If the mainio does not have a subio yet, convert (clone) the mainio into a subio and attach
 * that to the mainio as first/only subio.
 *
 * If the mainio already has a subio link, then convert the typ_io associated with this event and 
 * add it to the subio list.  Free any info data struct attached to the subio -- we don't need it,
 * only 1 per io and that is attached to the mainio itself.
 *     - **NOTE**: make sure to remove any info needed from ->info block on merge events' subio
 *                 before deallocating!
 *
 * Now that the subio list is all done, update the mainio.  This includes doing the actual merge
 * of extending the length to cover this event's io.  Also do the normal event housekeeping, aka
 * capture last event into typ_io "last event" fields, etc.  There are no SeqNo associated with
 * merges, so nothing to do there. However, track any QSegNo assigned to this subio as the 
 * "ghost" QSeqNo as that is used to determine if there was any reordering of io within the scheduler.
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * For 'M'erge, we have to search both the staging list and active list.
 *     a) staging list for the (A)->Q typ_io, this *may not* be present in some kernel versions
 *        aka event stream starts with 'M', but in that case we're going to go ahead and backfill
 *        the Q event for normalization purposes.
 *     b) active list for the (A)->Q->(S)->(G)->I io that we're merging onto.  **NOTE** that the
 *        program's expectations is that the previous io being merged into must have passed the I
 *        gate to guarantee the io being merged into is on the active list.  OR an equivalent gate,
 *        for example:
 *          8,1   30       54    30.030130002  2682  A  WS 629454752 + 8 <- (253,4) 524595104  typ_io -> staged @@@discard for now, not "main" device.
 *          8,0   30       55    30.030130730  2682  A  WS 629456800 + 8 <- (8,1) 629454752    typ_io -> staged, created
 *          8,0   30       56    30.030132631  2682  Q  WS 629456800 + 8 [jbd2/dm-4-8]	                 staged updated w/Q
 *          8,0   30       57    30.030143449  2682  G  WS 629456800 + 8 [jbd2/dm-4-8]                   staged updated w/G, moved to active list
 *          8,0   30       58    30.030146879  2682  P   N [jbd2/dm-4-8]
 *          8,1   30       59    30.030151041  2682  A  WS 629454760 + 8 <- (253,4) 524595112                   @@@discard
 *          8,0   30       60    30.030151187  2682  A  WS 629456808 + 8 <- (8,1) 629454760    typ_io -> staged, created
 *          8,0   30       61    30.030151338  2682  Q  WS 629456808 + 8 [jbd2/dm-4-8]                   staged, updated w/Q
 *          8,0   30       62    30.030154094  2682  M  WS 629456808 + 8 [jbd2/dm-4-8]                   staged, updated w/M, find active above, clone subio, convert to subio
 *          8,1   30       63    30.030157590  2682  A  WS 629454768 + 8 <- (253,4) 524595120   ditto
 *          8,0   30       64    30.030157828  2682  A  WS 629456816 + 8 <- (8,1) 629454768     "
 *          8,0   30       65    30.030158054  2682  Q  WS 629456816 + 8 [jbd2/dm-4-8]          "
 *          8,0   30       66    30.030158820  2682  M  WS 629456816 + 8 [jbd2/dm-4-8]          "
 *        But, if the G didn't exist -- and it won't in some kernel versions -- then the previous io we're merging
 *        has not made it to the active list yet.  But we should assume it has, and if we can't find one there, then
 *        fallback to looking at the staging queue.  There will be no backfill necessary in this case as S/G events
 *        are "optional", we don't use them as main event markers for anything.  We just capture them if they occur.
 *        However, it is true that (S)|G will trigger the io to be moved from staging to active list.  Just at insert
 *        time we have to verify that S|G has happened and 'I' has not as an assert condition.  That is, if its on
 *        the active list either it was moved there by S|G|I -- but you can't have two 'I' events and we should crash
 *        and burn if that is found to be the case for any reason.  It would mean either the program logic is faulty
 *        or there are conflicting multiple io of same type and lba+length (which we know can happen but the logic
 *        hasn't been fully updated to handle that yet).
 *        
 * Exceptions: 
 * 1) mainio not found.  This should only happen for early events within the blkparse
 * list.  For now, we're going to drop this event on the floor (add to exceptions), but otherwise
 * ignore until later. 
 *
 * 2) overlapped/conflicting io could result in us matching multiple io.  For now, just match first
 * and we'll deal with overlapping io later.  That is, the mainio doesn't overlap/confict and then
 * after extending/merging it does -- that is an edge condition on a corner case. lol.
 **/
/*
 * For a back/end merge, find another io of same type that ends on the 
 * sector before this one starts.  If that already has a subio link, then
 * create event and attach it to the subio list, length the main event to
 * cover this new merge io.  That is the 'main' event is request, and subio
 * are equivalent to each bio.
 *
 * If the matched event doesn't have a subio list already, then create a new
 * event, copy the matched event into that and place that as start of subio.
 * Then proceed as above.
 */
int bmerge_event(typ_event *this)
{
typ_io *temp, *staged, *io, *subio, *best;
int rw;
int lstndx;
int onmain= 0;
int nonio = 0;
int valid = 0;
int iomain= 0;
unsigned long bgn_sector;
unsigned long end_sector;
unsigned long xxx_sector;
unsigned long tgt_sector;
char   savact;
static char eventname[16]="bmerge    ";

    TRACE_FUNCTION;
    io = NULL;
    if ((rw = R_OR_W(this))                    >= 0) valid++;
    if ((this->evtflags & EVTFLG_VALID_SECTOR) != 0) valid++;
    if ((this->evtflags & EVTFLG_VALID_SIZE  ) != 0) valid++;
    bgn_sector = this->sector;
    end_sector = this->sector + this->length - ((this->length>0)?1:0);
    xxx_sector = this->sector;
    if (valid == 3)
    { 
	/* Ok, first find the io associated with this event on the staging queue  */
	/* Should have been A|Q events prior to the F to establish context        */
	if ((io = search_staged1(this,eventname,__LINE__)) == NULL)
	{
            /* See FN.101 on bug with F/M merging	                          */
	    /* There are two common cases: 
             * 1) this is an orphan event near the beginning of the trace, or 
             * 2) the io context for this merge is already on the mainio queue
             *    - this latter can happen (see FN.101) when a Bmerge follows
             *      a Fmerge where the Fmerge heals a hole between two io and
             *      both io have hit S, G, or I events that push the io to the
             *      mainio queue.  So, check to see if there is a match on the
             *      mainio queue .AND. that io is recent in time.  That later
             *      requirement is just an FYI/CYA limit to try and prevent the
             *      matching code selecting a mainio that it shouldn't.
             */
	    dprintf( "DBG[%05d]: bmerge - io %ld:%ld not found on stage queue. 2nd chance, look on mainio queue.\n", __LINE__, this->sector, this->length );
	    if ((io = search_mainio1(this,io,eventname,&onmain)) != NULL)
            {
#               define MAX_MERGE_HEAL_TIME 5.000000
	        if ((this->timeinfo.time - io->timeinfo.time) > MAX_MERGE_HEAL_TIME)
                {
                    dprintf( "DBG[%05d]: merge time from %12.5f to %12.5f exceeds %12.5f limi\n", __LINE__, 
			io->timeinfo.time, this->timeinfo.time, MAX_MERGE_HEAL_TIME );
	            io = NULL;
		}
		else
		{
                    dprintf( "DBG[%05d]: corner case: io found on mainio queue\n", __LINE__ );
		    iomain = 1;
	        }
	    }
        }
    }
    else
    {
        dprintf( "DBG[%05d]: io filtered off, will not search stage queue for io\n", __LINE__ );
        /* will never be able to match this to a staging io so just build new io */
        /* Need to create and backfill a mainio ... or just move to exceptions   */
        /* and forget about it.                                                  */
        exceptionevent(this, __LINE__, "Non-IO, discarded/filtered off");
        nonio = 1;
    }

    /* Did we find an io on the staging queue? If not, do we create a 'ghost' tracking io context? */
    /* The io context for 'M' for this io should exist on the staging queue (normally) unless this */
    /* io is missing prior A or Q events.  If that is the case, then we do need to creates a new   */
    /* 'ghost' io context for this M event. And only after that find a mainio event to merge into. */
    /* See FN.101 on bug with F/M merging	                                                   */
    if ((io = check_io_found(this,io,eventname,&onmain)) != NULL)
    {
        /* Now housekeeping, update last event        */
        /* @@@TBD review which fields other lstevt    */
	io->lstcpu =  this->cpu;
        io->lstact =  this->prmact;
        strcpy(io->lsttyp, this->evttyp);
        bcopy(this, &io->lstevt, sizeof(typ_event));

        _assert(io->info != NULL);
        if (state.isPlugged == 1) io->info->plug_state |= PLUGSTATE_M;

	io->EVENTS.merge.line = this->timeinfo.line;
	io->EVENTS.merge.time = this->timeinfo.line;
	io->event_mask |= EVTMSK_M; /* @@ */
	set_event_mask( io, EVTNDX_M );
    }
    staged = io;			/* on mainio if iomain==1 */
    _assert( staged != NULL );

    /* Ok, second find the io associated with this event on the active queue  */
    /* This will be the mainio that is the target for this merge event        */
    dprintf( "DBG[%05d]: mainio list[%5d] check for %10ld:%6ld match... <= looking for base/mainio to merge into that end sector\n", __LINE__, mainio_on_list, this->sector, this->length );
    for (lstndx=1, io=NULL,temp = mainio_list; temp != (typ_io *)NULL; temp = temp->next, lstndx++)
    {
        /* Look 1st for matching lba+len ends on event's starting lba */
        tgt_sector = temp->sector + temp->length;
        d3printf( "DBG[%05d]: mainio list[%5d]  %p %10ld:%6ld;%10ldv%08ld...\n", __LINE__, lstndx, temp, temp->sector, temp->length, tgt_sector, xxx_sector );
	if ((tgt_sector) != xxx_sector                 ) continue;
        dprintf( "DBG[%05d]: mainio list[%5d]  %p %10ld:%6ld;%10ld... match!\n", __LINE__, lstndx, temp, temp->sector, temp->length, tgt_sector );
        if ( R_OR_W(temp)                         != rw) continue; /* not the same (broad) type of io */
        if ((temp->evtflags & EVTFLG_VALID_SECTOR) == 0) continue; /* doesn't have valid sector numb  */
        if ((temp->evtflags & EVTFLG_VALID_SIZE  ) == 0) continue; /* doesn't have valid size   numb  */
	if ( temp->minor  != this->minor               ) continue; /* not the same device             */ 
        if ( temp->major  != this->major               ) continue; /* not even same major device type */
        dprintf( "DBG[%05d]: mainio list[%5d]  %p %10ld:%6ld;%10ld... passed other filters!\n", __LINE__, lstndx, temp, temp->sector, temp->length, end_sector );

        /* So starting sector here picks up where other left off... */
        onmain++;
        if (io == NULL)
        {
            /* first match! */
            io = temp;
            dprintf( "DBG[%05d]: mainio list  %p %10ld:%6ld;%10ld... <= 1st hit\n", __LINE__, temp, temp->sector, temp->length, end_sector );
        }
        else
        {
            /* @@@TBD - resolve conflicting io for same lba & size */
            /*          which is different than detection overlap  */
            /*          in that overlap can be diff lba+len but    */
            /*          still partially overlap this new one       */
            dprintf( "DBG[%05d]: mainio list  %p %10ld:%6ld;%10ld... <= 1st hit\n", __LINE__, temp, temp->sector, temp->length, end_sector );
            dprintf( "DBG[%05d]: mainio list  %p %10ld:%6ld;%10ld... <= Nth hit!?\n", __LINE__, temp, temp->sector, temp->length, end_sector );
	    printf( "DBG[%05d]: %s()\n", __LINE__, __func__ );
            dump_staged_list(__LINE__);
	    dump_mainio_list(__LINE__);
	    /* Call best_match() to resolve which one to use       */
	    if ((best = best_match(this,io,temp)) != NULL) io = best;
        }
    }
    if (io == NULL)
    {
        /* Ok, not on active list, but might still be on staged list...				 */
        dprintf( "DBG[%05d]: check staged list for match %10ld:%6ld... <= looking for base/mainio to merge into that end sector\n", __LINE__, this->sector, this->length );
        for (io=NULL,temp = staged_list; temp != (typ_io *)NULL; temp = temp->next)
        {
            /* Look 1st for matching lba+len ends on event's starting lba */
            tgt_sector = temp->sector + temp->length;
            dprintf( "DBG[%05d]: mainio list  %p %10ld:%6ld;%10ldv%08ld...\n", __LINE__, temp, temp->sector, temp->length, tgt_sector, xxx_sector );
	    if ((tgt_sector) != xxx_sector                 ) continue;
            dprintf( "DBG[%05d]: staged list  %p %10ld:%6ld;%10ld... match!\n", __LINE__, temp, temp->sector,  temp->length, tgt_sector );
            if ( R_OR_W(temp)                         != rw) continue; /* not the same (broad) type of io */
            if ((temp->evtflags & EVTFLG_VALID_SECTOR) == 0) continue; /* doesn't have valid sector numb  */
            if ((temp->evtflags & EVTFLG_VALID_SIZE  ) == 0) continue; /* doesn't have valid size   numb  */
	    if ( temp->minor  != this->minor               ) continue; /* not the same device             */ 
            if ( temp->major  != this->major               ) continue; /* not even same major device type */
            dprintf( "DBG[%05d]: staged list  %p %10ld:%6ld;%10ld... passed other filters!\n", __LINE__, temp, temp->sector, temp->length, end_sector );

            /* So starting sector here picks up where other left off... */
            if (io == NULL)
            {
                /* first match! */
                io = temp;
                dprintf( "DBG[%05d]: staged list  %p %10ld:%6ld;%10ld... <= 1st hit (this is mainio block)\n", __LINE__, temp, temp->sector, temp->length, end_sector );
            }
            else
            {
                /* @@@TBD - resolve conflicting io for same lba & size */
                /*          which is different than detection overlap  */
                /*          in that overlap can be diff lba+len but    */
                /*          still partially overlap this new one       */
                dprintf( "DBG[%05d]: staged list  %p %10ld:%6ld;%10ld... <= 1st hit (this is mainio block)\n", __LINE__,   io,   io->sector,   io->length, end_sector );
                dprintf( "DBG[%05d]: staged list  %p %10ld:%6ld;%10ld... <= Nth hit (this is mainio block)\n", __LINE__, temp, temp->sector, temp->length, end_sector );
	        dbg_verify_staged_dump = 1;
	        verify_staged_list(__LINE__);
	        printf( "DBG[%05d]: %s()\n", __LINE__, __func__ );
                dump_staged_list(__LINE__);
	        dump_mainio_list(__LINE__);
	        if ((best = best_match(this,io,temp)) != NULL) io = best;
            }
        }
    }
    if (io == NULL)
    {
        /* Nope, not on either list. Weird */
        /* new one: this needs to be backfilled, but for now add event to exceptions list and ignore */
        /* @@@TBD */
        printf( "%%F[%05d]-tbd, missing feature, cannot find A|Q event for this event on staged list -- need to create dummy/backfilled?.\n", __LINE__ );
	MISS_FEATURE_FAULT(this,(int),"ghost needed?",CTL_FAULT_DEFAULT);
    }

    dbg_add_event_to_io(this,io,__LINE__,NULL);

    /* Ok, now that we have an io to merge into, move this io to  the active list */
    /* since we found it on the staged list                                       */
    if (onmain == 0)
        move_staged_to_mainio(io);

    /* Ok, we have our mainio to merge into now, do the needful			  */
    /* Are there any subio already?               */
    /* if not, clone main to start subio list     */
    if (io->subio == NULL)
    {
        subio = clone_to_subio(io);
        add_subio_to_mainio(io,subio," <= add converted 1st mainio info to subio list" );
    }

    /* Save any critical information from subio  */
    /* info block, as we're about to remove it   */
    if ((staged->info != NULL) && (io->info != NULL))
    {
        if ((staged->info->QSeqNo != 0) &&
            (staged->info->QSeqNo > io->info->QSeqNo_Ghost)) io->info->QSeqNo_Ghost = staged->info->QSeqNo;  /* so bias q2d is accurate		*/
    }
    
    /* Now add the staged io to the subio list   */
    /* NOTE: add_subio() will remove any dangling info data struct, so if need anything there, be sure to get before this! */
    /*       subio do not have/need info data struct.									   */
    if (iomain == 0)
        sub_io_from_staged(staged);
    else
        sub_io_from_mainio(staged);
    add_subio_to_mainio(io,staged," <= add this event's io to subio list");		       

    /* Now extend this mainio to cover merge      */
    io->length += this->length;

    /* Now housekeeping, update last event        */
    /* @@@TBD review which fields other lstevt    */
    io->lstcpu =  this->cpu;
    io->lstact =  this->prmact;
    strcpy(io->lsttyp, this->evttyp);
    bcopy(this, &io->lstevt, sizeof(typ_event));

    this->request = io;
    _assert(io->info != NULL);
    if (state.isPlugged == 1) io->info->plug_state |= PLUGSTATE_M;

    io->EVENTS.merge.line = this->timeinfo.line;
    io->EVENTS.merge.time = this->timeinfo.line;
    io->event_mask |= EVTMSK_M; /* @@ */
    set_event_mask( io, EVTNDX_M );

    event_sig_add(io, this);	/* Add matched event signature to io context */

    dbg_lineno = __LINE__;
    annotate_event(this,3,io);  
    _return(0);
}

/**
 * ==========================================================================================
 * Function : fmerge_event -- process a front merge event
 * Args     : @this:       current event information
 * Returns  : 0
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Find the staging io this belongs to -or- create a new typ_io and place it on the staging
 * queue.  Transfer information from event to typ_io.
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Really should *not* find a matching io present unless there are 
 **/
int fmerge_event(typ_event *this)
{
typ_io *io, *temp, *best;
typ_io *staged, *subio;
int rw;
int lstndx;
int onmain= 0;
int nonio = 0;
int valid = 0;
unsigned long bgn_sector;
unsigned long end_sector;
unsigned long xxx_sector;	/* match on request with this as starting sector */
unsigned long tgt_sector;
static char eventname[16]="fmerge    ";

    TRACE_FUNCTION;
    io = NULL;
    if ((rw = R_OR_W(this))                    >= 0) valid++;
    if ((this->evtflags & EVTFLG_VALID_SECTOR) != 0) valid++;
    if ((this->evtflags & EVTFLG_VALID_SIZE  ) != 0) valid++;
    bgn_sector = this->sector;
    end_sector = this->sector + this->length - ((this->length>0)?1:0);
    xxx_sector = end_sector + 1;
    if (valid == 3)
    { 
	/* Ok, first find the io associated with this event on the staging queue  */
	/* There should have been a Q event prior to this F event -- need that Q  */
	/* data structure to pull from staging and then merge to mainio list      */
	io = search_staged1(this,eventname,__LINE__);
    }
    else
    {
        dprintf( "DBG[%05d]: io filtered off, will not search stage queue for io\n", __LINE__ );
        /* will never be able to match this to a staging io so just build new io */
        /* Need to create and backfill a mainio ... or just move to exceptions   */
        /* and forget about it.                                                  */
        nonio = 1;
    }

    /* Did we find an io on the staging queue? */
    if ((io = check_io_found(this,io,eventname,&onmain)) != NULL)
    {
        /* Now housekeeping, update last event        */
	/* Fold basic info of this event into context */
        /* @@@TBD review which fields other lstevt    */
	io->lstcpu =  this->cpu;
        io->lstact =  this->prmact;
        strcpy(io->lsttyp, this->evttyp);
        bcopy(this, &io->lstevt, sizeof(typ_event));

        _assert(io->info != NULL);
        if (state.isPlugged == 1) io->info->plug_state |= PLUGSTATE_M;

	io->EVENTS.merge.line = this->timeinfo.line;
	io->EVENTS.merge.time = this->timeinfo.line;
	io->event_mask |= EVTMSK_M; /* @@ */
	set_event_mask( io, EVTNDX_M );
    }
    staged = io;
    _assert( staged != NULL );

    /* Ok, second find the io associated with this event on the active queue  */
    /* That is, find the target for this merge                                */
    dprintf( "DBG[%05d]: mainio list[%5d] check for %10ld:%6ld match... <= looking for base/mainio to merge into that end sector\n", __LINE__, mainio_on_list, this->sector, this->length );
    for (lstndx=1, io=NULL,temp = mainio_list; temp != (typ_io *)NULL; temp = temp->next, lstndx++)
    {
        /* Look 1st for matching lba+len ends on event's starting lba */
        tgt_sector = temp->sector;
        d3printf( "DBG[%05d]: mainio list[%5d]  %p %10ld:%6ld;%10ldv%10ld...\n", __LINE__, lstndx, temp, temp->sector, temp->length, tgt_sector, xxx_sector );
	if ((tgt_sector) != xxx_sector                 ) continue;
        dprintf( "DBG[%05d]: mainio list[%5d]  %p %10ld:%6ld;%10ld... match!\n", __LINE__, lstndx, temp, temp->sector, temp->length, tgt_sector );
        if ( R_OR_W(temp)                         != rw) continue; /* not the same (broad) type of io */
        if ((temp->evtflags & EVTFLG_VALID_SECTOR) == 0) continue; /* doesn't have valid sector numb  */
        if ((temp->evtflags & EVTFLG_VALID_SIZE  ) == 0) continue; /* doesn't have valid size   numb  */
	if ( temp->minor  != this->minor               ) continue; /* not the same device             */ 
        if ( temp->major  != this->major               ) continue; /* not even same major device type */
        dprintf( "DBG[%05d]: mainio list[%5d]  %p %10ld:%6ld;%10ld... passed other filters!\n", __LINE__, lstndx, temp, temp->sector, temp->length, end_sector );

        /* So ending sector here stops where other left starts... */
        onmain++;
        if (io == NULL)
        {
            /* first match! */
            io = temp;
            dprintf( "DBG[%05d]: mainio list  %p %10ld:%6ld;%10ld... <= 1st hit\n", __LINE__, temp, temp->sector, temp->length, end_sector );
        }
        else
        {
            /* @@@TBD - resolve conflicting io for same lba & size */
            /*          which is different than detection overlap  */
            /*          in that overlap can be diff lba+len but    */
            /*          still partially overlap this new one       */
            dprintf( "DBG[%05d]: mainio list  %p %10ld:%6ld;%10ld... <= 1st hit\n",   __LINE__,   io,   io->sector,   io->length, end_sector );
            dprintf( "DBG[%05d]: mainio list  %p %10ld:%6ld;%10ld... <= Nth hit!?\n", __LINE__, temp, temp->sector, temp->length, end_sector );
	    printf( "DBG[%05d]: %s()\n", __LINE__, __func__ );
            dump_staged_list(__LINE__);
	    dump_mainio_list(__LINE__);
	    if ((best = best_match(this,io,temp)) != NULL) io = best;
        }
    }
    if (io == NULL)
    {
        /* Ok, not on active list, but might still be on staged list...				 */
	/* This might seem unusual, but could have Q1|Q2|F2|I1 sequence...                       */
        dprintf( "DBG[%05d]: check staged list for match %10ld:%6ld... <= looking for base/mainio to merge into that end sector\n", __LINE__, this->sector, this->length );
        for (io=NULL,temp = staged_list; temp != (typ_io *)NULL; temp = temp->next)
        {
            /* Look 1st for matching lba+len ends on event's starting lba */
            tgt_sector = temp->sector;
            dprintf( "DBG[%05d]: mainio list  %p %10ld:%6ld;%10ldv%10ld...\n", __LINE__, temp, temp->sector, temp->length, tgt_sector, xxx_sector );
	    if ((tgt_sector) != xxx_sector                 ) continue;
	    if ((end_sector) != this->sector               ) continue;
            dprintf( "DBG[%05d]: staged list  %p %10ld:%6ld;%10ld... match!\n", __LINE__, temp, temp->sector,  temp->length, tgt_sector );
            if ( R_OR_W(temp)                         != rw) continue; /* not the same (broad) type of io */
            if ((temp->evtflags & EVTFLG_VALID_SECTOR) == 0) continue; /* doesn't have valid sector numb  */
            if ((temp->evtflags & EVTFLG_VALID_SIZE  ) == 0) continue; /* doesn't have valid size   numb  */
	    if ( temp->minor  != this->minor               ) continue; /* not the same device             */ 
            if ( temp->major  != this->major               ) continue; /* not even same major device type */
            dprintf( "DBG[%05d]: staged list  %p %10ld:%6ld;%10ld... passed other filters!\n", __LINE__, temp, temp->sector, temp->length, end_sector );

            /* So starting sector here picks up where other left off... */
            if (io == NULL)
            {
                /* first match! */
                io = temp;
                dprintf( "DBG[%05d]: staged list  %p %10ld:%6ld;%10ld... <= 1st hit (this is mainio block)\n", __LINE__, temp, temp->sector, temp->length, end_sector );
            }
            else
            {
                /* @@@TBD - resolve conflicting io for same lba & size */
                /*          which is different than detection overlap  */
                /*          in that overlap can be diff lba+len but    */
                /*          still partially overlap this new one       */
                dprintf( "DBG[%05d]: staged list  %p %10ld:%6ld;%10ld... <= 1st hit (this is mainio block)\n", __LINE__,  io,    io->sector,   io->length, end_sector );
                dprintf( "DBG[%05d]: staged list  %p %10ld:%6ld;%10ld... <= Nth hit (this is mainio block)\n", __LINE__, temp, temp->sector, temp->length, end_sector );
	        dbg_verify_staged_dump = 1;
	        verify_staged_list(__LINE__);
	        printf( "DBG[%05d]: %s()\n", __LINE__, __func__ );
                dump_staged_list(__LINE__);
	        dump_mainio_list(__LINE__);
	        if ((best = best_match(this,io,temp)) != NULL) io = best;
            }
        }
    }
    if (io == NULL)
    {
        /* Nope, not on either list. Weird */
        /* new one: this needs to be backfilled, but for now add event to exceptions list and ignore */
        /* @@@TBD */
        printf( "%%F[%05d]-tbd, missing feature, cannot process event.\n", __LINE__ );
	MISS_FEATURE_FAULT(this,(int),"ghost needed?",CTL_FAULT_DEFAULT);
    }

    dbg_add_event_to_io(this,io,__LINE__,NULL);

    /* Ok, now that we have an io to merge into, move this io to  the active list */
    /* since we found it on the staged list                                       */
    if (onmain == 0)
        move_staged_to_mainio(io);

    /* Ok, we have our mainio to merge into now, do the needful			  */
    /* Are there any subio already?               */
    /* if not, clone main to start subio list     */
    if (io->subio == NULL)
    {
	/* this is first merge, clone out the mainio context to start subio list  */
        subio = clone_to_subio(io);
        add_subio_to_mainio(io,subio," <= add converted 1st mainio info to subio list" );
    }

    /* Save any critical information from subio  */
    /* info block, as we're about to remove it   */
    if ((staged->info != NULL) && (io->info != NULL))
    {
        if ((staged->info->QSeqNo != 0) &&
            (staged->info->QSeqNo > io->info->QSeqNo_Ghost)) io->info->QSeqNo_Ghost = staged->info->QSeqNo;  /* so bias q2d is accurate		*/
    }

    /* Now add the staged io to the subio list   */
    /* NOTE: add_subio() will remove any dangling info data struct, so if need anything there, be sure to get before this! */
    /*       subio do not have/need info data struct.									   */
    sub_io_from_staged(staged);
    add_subio_to_mainio(io,staged," <= add this event's io to subio list");		       

    /* Now extend this mainio to cover merge      */
    io->sector  = this->sector;				/* fmerge changes starting sector also, backs it up   */
    io->length += this->length;				/* Extended the length of request to cover this merge */

    /* Now housekeeping, update last event        */
    /* @@@TBD review which fields other lstevt    */
    io->lstcpu =  this->cpu;
    io->lstact =  this->prmact;
    strcpy(io->lsttyp, this->evttyp);
    bcopy(this, &io->lstevt, sizeof(typ_event));

    this->request = io;
    _assert(io->info != NULL);
    if (state.isPlugged == 1) io->info->plug_state |= PLUGSTATE_M;

    io->EVENTS.merge.line = this->timeinfo.line;
    io->EVENTS.merge.time = this->timeinfo.line;
    io->event_mask |= EVTMSK_M; /* @@ */
    set_event_mask( io, EVTNDX_M );

    event_sig_add(io, this);	/* Add matched event signature to io context */

    dbg_lineno = __LINE__;
    annotate_event(this,3,io);  
    _return(0);
}

/**
 * ==========================================================================================
 * Function : sleep_event -- process a reMap event
 * Args     : @this:       current event information
 * Returns  : 0
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Find the staging io this belongs to -or- create a new typ_io and place it on the staging
 * queue.  Transfer information from event to typ_io.
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Really should *not* find a matching io present unless there are 
 **/
int sleep_event(typ_event *this)
{
typ_io *io, *temp;
int rw;
int lstndx;
int onmain= 0;
int nonio = 0;
int valid = 0;
typ_actions *actions, temp_actions;
int    line;
double time;
static char eventname[16]="sleep     ";

    TRACE_FUNCTION;
    io = NULL;
    if ((rw = R_OR_W(this))                    >= 0) valid++;	
    if ((this->evtflags & EVTFLG_VALID_SECTOR) != 0) valid++;
    if ((this->evtflags & EVTFLG_VALID_SIZE  ) != 0) valid++;
    if (valid == 3) /* we only care about data movement commands; r/w + valid lba+len */
    { 
        /* Search shorter staged list for this event -- it may not be here */
        /* as it may have already been moved to active list via S event... */
        /* only io that needs a request should sleep...                    */
	io = search_staged1(this,eventname,__LINE__);
    }
    else
    {           
        dprintf( "DBG[%05d]: io filtered off, will not search stage queue for io\n", __LINE__ );
        /* will never be able to match this to a staging io so just build new io */
        /* Need to create and backfill a mainio ... or just move to exceptions   */
        /* and forget about it.                                                  */
        nonio = 1;
    }

    /* Did we find an io on the staging queue? */
    /* No? Wasn't on staged list, ok check mainio/active list for same (might have got here via S) */
    if ((io == NULL) && (nonio == 0))
        io = search_mainio1(this,io,eventname,&onmain);
    /* A Sleep event can *only* be applied to an io on the staged queue */
    /* Any io already on the mainio/active list got there via G|I which */
    /* is after the time any Sleep event could be applied to them.  So  */
    /* we don't have to look for duplicate typ:sector:length matches on */
    /* mainio/active list too.                                          */


    if (io != NULL)
    {
        dbg_add_event_to_io(this,io,__LINE__,NULL);

        dprintf( "DBG[%05d]: looking for @%12.9f:%8lu+%6lu, found %12.9f:%8lu+%6lu on %s list\n", __LINE__, 
	    this->timeinfo.time, this->sector, this->length, 
              io->timeinfo.time,   io->sector,   io->length,
	    onmain==0?"staged":"mainio" );

        /* Make sure io is moved to the mainio/active list */
        if (onmain == 0)
        {
            _assert( (io->ioflags & IS_STAGED) != 0 );
            move_staged_to_mainio(io);				/* <== inProgress stats updated in there */
        }
        else
        {
	    /* already on mainio list...           */
            _assert( (io->ioflags & IS_STAGED) == 0 );
        }

        /* Now housekeeping, update last event        */
        /* @@@TBD review which fields other lstevt    */
        io->lstcpu =  this->cpu;
        io->lstact =  this->prmact;
        strcpy(io->lsttyp, this->evttyp);
        bcopy(this, &io->lstevt, sizeof(typ_event));

        this->request = io;
        _assert(io->info != NULL);
        if (state.isPlugged == 1) io->info->plug_state |= PLUGSTATE_I;

        /* capture I event info in events                           */
        if (io->info != NULL) actions = &io->info->events;
        else                  actions = &temp_actions;
        line = this->timeinfo.line;
        time = this->timeinfo.time;

	/* *THIS* action stuffs						     */
        /* ----------------------------------------------------------------- */
        if (actions->sleep.line != 0)
        {
             /* this is first insert event for this io */
             actions->sleep_first.line = line;
             actions->sleep_first.time = time;

             /* only grab a ticket @first insert time  */
             /* Assigning event Q/I/D/C timestamp processing.                 */
             /* ISeqNo will be used to calc iosched reorder @dispatch time    */
             state.SSeqNo++;
             io->info->SSeqNo = state.SSeqNo;

	     /* inProgess counts are taken care of in move-to-mainio() */
        }
        io->event_mask              |= EVTMSK_S; /* @@ */
	set_event_mask( io,    EVTNDX_S );
        actions->sleep.line  = line;
        actions->sleep.time  = time;
        io->info->cnt_sleeps++;
        io->info->SSeqNo_Ghost     = state.SSeqNo;    /* this just reflects S ticket in state at last S event for this io, not assigned a ticket, it "ghosts" ticket # */
        tprintf( "tDBG[%05d]: event %c:%16ld.%8ld assign sleep time %13.9f\n", __LINE__, _prmtyp(this->prmtyp), this->sector, this->length, this->timeinfo.time );


        /* Merge event flags, add procname if not previously available,     */
        /* ditto for extras.                                                */
        io->evtflags |= this->evtflags;
	if ((this->procname[0] != 0) && (io->procname[0] == 0))
        {
	    /* should be there unless this is backfill */
            strcpy(io->procname, this->procname);
	}
	if ((this->extras[0] != 0) && (io->extras[0] == 0))
        {
            strcpy(io->extras  , this->extras  );
	}


        if (io->info->events.sleep.time < io->info->events.first.time )
        {
            dprintf( "%%E[%05d]: sleep io %10ld %6ld F:%12.9f > I:%12.9f (%12.9f)\n", __LINE__, this->sector, this->length,
                io->info->events.first.time, 
	        io->info->events.sleep.time,
                io->info->events.sleep.time - io->info->events.first.time );
        }
	else
	{
            dprintf( "%%I[%05d]: sleep io %10ld %6ld F:%12.9f < I:%12.9f (%12.9f)\n", __LINE__, this->sector, this->length,
                io->info->events.first.time, 
	        io->info->events.sleep.time,
                io->info->events.first.time - io->info->events.sleep.time );
	}

        samp.cnt_sleeps++;
        summ.cnt_sleeps++;
        switch (this->prmtyp)
        {
            case IOTYP_UNK      :
            case IOTYP_OTHER    :
            case IOTYP_NONE     : 
	    case IOTYP_SCHED    :
            case IOTYP_READ     : samp.cnt_sleep_reads++;  summ.cnt_sleep_reads++;  break;
            case IOTYP_WRITE    : 
            case IOTYP_META     : 
            case IOTYP_BARRIER  : samp.cnt_sleep_writes++;   summ.cnt_sleep_writes++;   break;
            case IOTYP_DISCARD  : samp.cnt_sleep_discards++; summ.cnt_sleep_discards++; break;
            default             : break;
        }

        test_sample_time_boundary(io);
        /* ----------------------------------------------------------------- */
    }
    else if (nonio == 0)
    {
        /* Nope, not on either list. Weird */
        /* new one: this needs to be backfilled, but for now add event to exceptions list and ignore */
        /* @@@TBD - for now treat this as a "data processing fault" rather than programming fault    */
        printf( "%%F[%05d]-tbd, missing feature in program.\n", __LINE__ );
	MISS_FEATURE_FAULT(this,(int),"ghost needed?",CTL_FAULT_DEFAULT);
    }

    event_sig_add(io, this);	/* Add matched event signature to io context */

    /* last thing before returning, output annotated event           */
    dbg_lineno = __LINE__;
    annotate_event(this,3,io);
    _return(0);
}


/**
 * ==========================================================================================
 * Function : getreq_event -- process a reMap event
 * Args     : @this:       current event information
 * Returns  : 0
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Find the staging io this belongs to -or- create a new typ_io and place it on the staging
 * queue.  Transfer information from event to typ_io.
 *
 * Notes
 * Because of the chance for typ:sector:length duplicates, we need to always search both
 * the staged and mainio/active list for any/all matches.  There is a possibility that
 * one or matches may reside in both queues at the time when this function is called -- 
 * and that the "best match" resides on the mainio/active list.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Events that need to search both queues are S|G|I (and maybe M|F -- but duplicates,
 * when they do exists, seem to be only non-merged variant).  The D,R,C type events 
 * request the request to be located on the mainio/active list.  Whereas the A|Q events
 * only target io on the staged queue.  That leaves S|G|I which, when encountered, move
 * the io from staged to mainio.  And because of that, searching for duplicates must
 * check both queues.  A prior duplicate could be on either queue, and if more than one,
 * then there can be multiple duplicates on both lists that we need to find/match/process.
 *
 * If there are no sleep events, then a G event can only be applied to io within the
 * staged list.  The only time we'd find an event on the active list that was needed
 * a G would be the case where a Sleep moved it there.  So if sleeps have happened,
 * a sleep just might have moved a duplicated to the mainio/active list so look there.
 *
 *  *
 * Special Case(s)
 *   + KWIOBARRIER: 253,89  39       47     0.076047620 19690  G FWS [mdX_raid10]
 *     . Search staged queue for 1st match w/KWIOBARRIER set, no Q event
 *     . If a match isn't found, create one... but log a complaint about doing so.
 *     . Do **not** search mainio queue for this io.
 *
 **/
int getreq_event(typ_event *this)
{
typ_io *io, *temp;
typ_io *best_staged, *best_mainio;
int rw;
int onmain= 0;
int nonio = 0;
int valid = 0;
typ_actions *actions, temp_actions;
int    line;
double time;
char   reason[256];
static char eventname[16]="getrequest";

    TRACE_FUNCTION;
    io = NULL;
    if ((rw = R_OR_W(this))                    >= 0) valid++;	
    if ((this->evtflags & EVTFLG_VALID_SECTOR) != 0) valid++;
    if ((this->evtflags & EVTFLG_VALID_SIZE  ) != 0) valid++;
    if (valid == 3) /* we only care about data movement commands; r/w + valid lba+len */
    { 
        /* Search shorter staged list for this event -- it may not be here */
        /* as it may have already been moved to active list via S event... */
        /* only io that needs a request should sleep...                    */
	io = search_staged1(this,eventname,__LINE__);
	d1printf( "DBG[%05d]: search_staged1('G',%d,%ld,%ld) %016X found '%p'\n", __LINE__, valid, this->sector, this->length, (io!=NULL)?io->evtflags:0L, io );
    }
    if ((this->evtflags & EVTFLG_KWIOBARRIER) != 0)
    {
	io = search_staged_barrier1(this,eventname,__LINE__);	
    }
    if ((io != NULL) && (io->info->GSeqNo != 0))
    {
	/* This is will eventually be replaced or assert() failed.  Lets   */
        /* retry and see if we can find another, better one, on the staged */
	/* queue that is same match but w/GSegNo == 0                      */
	io = search_staged_duplicate1(this,io,eventname,__LINE__);
	/* @@@@@@@@@@TBD this should already be blended into the search_staged1() function, no?! */
    }
    if ((valid != 3) && ((this->evtflags & EVTFLG_KWIOBARRIER) != 0))
    {           
        if ((io == NULL) && (this->imbtyp == IMBTYP_xx))
        {
            /* IMB_xx   ::
	     *    FWS+KWIO :: 259,0    0        3     2.152246022 138872 G FWFSM [kworker/0:0]
             *    FWS+KWIO :: 259,0   11       21     5.027077378  1889  G FWFS  [jbd2/dm-4-8]
             *    FWS+KWIO :: 259,0    6        3     2.128394855 13905  G FWS   [kworker/u24:6]
             */

            /* ...might be other formats, but for now only allow this one.                  */
            if ((this->iomask & (IOMASK_WRITE | IOMASK_SYNC | IOMASK_FLUSH)) == (IOMASK_WRITE | IOMASK_SYNC | IOMASK_FLUSH))
            {
                if ((io = imb_active_find(this)) != NULL)
                {
                    q0printf( "DBG[%05d]: looking for @%12.9f:%8lu+%6lu, found %12.9f:%8lu+%6lu on %s list\n", __LINE__,
                            this->timeinfo.time, this->sector, this->length,
                              io->timeinfo.time,   io->sector,   io->length,
                            "imb_active");
                    dprintf( "DBG[%05d]: looking for @%12.9f:%8lu+%6lu, found %12.9f:%8lu+%6lu on %s list\n", __LINE__,
                            this->timeinfo.time, this->sector, this->length,
                              io->timeinfo.time,   io->sector,   io->length,
                            "imb_active");

		    /* Expectation is this is still on the staged queue... it will be moved down below */
                    printf( "DBG[%05d]: %s(staged = %d)\n", __LINE__, __func__, io->ioflags & IS_STAGED );
                    _assert( (io->ioflags & IS_STAGED) != 0 );
                }
            }
        }
        if (io == NULL)
        {
            dprintf( "DBG[%05d]: new io to be created, KWIOBARRIER found no match in staged queue\n", __LINE__ );
        }
    }

    /* Did we find an io on the staging queue? */
    /* No? Wasn't on staged list, ok check mainio/active list for same (might have got here via S) */
    if ((io == NULL) && (nonio == 0) && ((this->evtflags & EVTFLG_KWIOBARRIER) == 0))
        io = search_mainio1(this,io,eventname,&onmain);
    else if ((io != NULL) && (state.event_count_sleep != 0))
    {
	/* special case, we need to look for best io on mainio list and */
	/* then compare it to the best one found on the staged list     */
	/* due to a prior sleep, a dupe io needing a G may be sitting on*/
	/* the active list so go look...                                */
	best_staged = io;
	best_mainio = search_mainio1(this,io,eventname,&onmain);
        if (best_mainio == best_staged)
        {
            /* the above didn't find a (better) match, returned same ptr*/
            /* avoid sending in two pointers to best_match() same/same  */
            io = best_staged;
        }
        else
        {
            if ((io = best_match(this,best_staged,best_mainio)) == NULL) io = best_staged;
            if (io == best_mainio) onmain=1;
        }
    }
    

    /* If no match and special is set, give a second special look */
    if ((io == NULL) && ((this->specials & SPCFLG_00) != 0))
	io = search_staged_special1(this,eventname,__LINE__);

    if (io != NULL)
    {
        dbg_add_event_to_io(this,io,__LINE__,NULL);

        dprintf( "DBG[%05d]: looking for @%12.9f:%8lu+%6lu, found %12.9f:%8lu+%6lu on %s list\n", __LINE__, 
	    this->timeinfo.time, this->sector, this->length, 
              io->timeinfo.time,   io->sector,   io->length,
	    onmain==0?"staged":"mainio" );

        /* Make sure io is moved to the mainio/active list */
        if (onmain == 0)
        {
            _assert( (io->ioflags & IS_STAGED) != 0 );
            move_staged_to_mainio(io);				/* <== inProgress stats updated in there */
        }
        else
        {
	    /* already on mainio list...           */
            _assert( (io->ioflags & IS_STAGED) == 0 );
        }

        /* Now housekeeping, update last event        */
        /* @@@TBD review which fields other lstevt    */
        io->lstcpu =  this->cpu;
        io->lstact =  this->prmact;
        strcpy(io->lsttyp, this->evttyp);
        bcopy(this, &io->lstevt, sizeof(typ_event));

        this->request = io;
        _assert(io->info != NULL);
        if (state.isPlugged == 1) io->info->plug_state |= PLUGSTATE_I;

        /* capture I event info in events                           */
        if (io->info != NULL) actions = &io->info->events;
        else                  actions = &temp_actions;
        line = this->timeinfo.line;
        time = this->timeinfo.time;


	/* *THIS* action stuffs						     */
        /* ----------------------------------------------------------------- */
        io->event_mask      |= EVTMSK_G; /* @@ */
	set_event_mask( io,    EVTNDX_G );
        actions->sleep.line  = line;
        actions->sleep.time  = time;
	if (io->info->GSeqNo != 0)
        {
	    /* This is rare, but can happen because of multiple io for the same sector:length */
	    printf( "%%F[%05d]- io %p GSeqNo already set for this io, double 'G' events? %ld -> %ld\n", __LINE__, io, io->info->GSeqNo, state.GSeqNo+1 );
            dump_staged_list(__LINE__);
	    dump_mainio_list(__LINE__);
	    fflush(stdout);
	    sleep(1);
            _assert(io->info->GSeqNo == 0);		/* should only ever be 1     */
	}
        state.GSeqNo++;
        io->info->GSeqNo = state.GSeqNo;


        /* Merge event flags, add procname if not previously available,     */
        /* ditto for extras.                                                */
        io->evtflags |= this->evtflags;
	if ((this->procname[0] != 0) && (io->procname[0] == 0))
        {
	    /* should be there unless this is backfill */
            strcpy(io->procname, this->procname);
	}
	if ((this->extras[0] != 0) && (io->extras[0] == 0))
        {
            strcpy(io->extras  , this->extras  );
	}

	/* Stats updates						     */
        samp.cnt_getreqs++;
        summ.cnt_getreqs++;
        test_sample_time_boundary(io);
        /* ----------------------------------------------------------------- */
    }
    else if ((this->evtflags & EVTFLG_KWIOBARRIER) != 0)
    {
        /* No io match found, could create a ghost but instead just discard */
        if (io == NULL)
        {
            dprintf( "DBG[%05d]: discarded, KWIOBARRIER found no match in staged queue\n", __LINE__ );
            sprintf( this->reason, "[%05d]: KWIOBARRIER but no mainio staged found\n", __LINE__ );
            this->evtflags |= EVTFLG_EXCEPTION | EVTFLG_DISCARDED;
            exceptionevent(this,__LINE__,"io filtered off, barrier event: missing matching io");
        }
    }
    else if (nonio == 0) 
    {
	/* Ok, not on any of the lists... and we didn't create a ghost either*/
	/* So.... we're just discarding this event for some reason. Log&ret  */
	sprintf( reason, "notartet match, discarding event '%s'\n", __LINE__, state.inpline );
	NOTARGET_FAULT(this,(int),reason,CTL_FAULT_DEFAULT);
    }


    event_sig_add(io, this);	/* Add matched event signature to io context */

    /* last thing before returning, output annotated event           */
    dbg_lineno = __LINE__;
    annotate_event(this,3,io);
    _return(0);
}

/**
 * ==========================================================================================
 * Function : insert_event -- process a reMap event
 * Args     : @this:       current event information
 * Returns  : 0
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Find the staging io this belongs to -or- create a new typ_io and place it on the staging
 * queue.  Transfer information from event to typ_io.
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Really should *not* find a matching io present unless there are 
 **/
int insert_event(typ_event *this)
{
typ_io *io, *temp;
typ_io *best_staged, *best_mainio;
int rw;
int onmain= 0;
int nonio = 0;
int valid = 0;
typ_actions *actions, temp_actions;
int    line;
double time;
static char eventname[16]="insert    ";

    TRACE_FUNCTION;
    io = NULL;
    if ((rw = R_OR_W(this))                    >= 0) valid++;
    if ((this->evtflags & EVTFLG_VALID_SECTOR) != 0) valid++;
    if ((this->evtflags & EVTFLG_VALID_SIZE  ) != 0) valid++;
    if (valid == 3)
    { 
        /* Search shorter staged list for this event -- it may not be here */
        /* as it may have already been moved to active list via S/G/M/F    */
	io = search_staged1(this,eventname,__LINE__);
    }
    else
    {           
        dprintf( "DBG[%05d]: io filtered off, will not search stage queue for io (valid=%d)\n", __LINE__, valid );
        /* will never be able to match this to a staging io so just build new io */
        /* Need to create and backfill a mainio ... or just move to exceptions   */
        /* and forget about it.                                                  */
        nonio = 1;
    }

    /* Did we find an io on the staging queue? */
    if ((io == NULL) && (nonio == 0))
        io = search_mainio1(this,io,eventname,&onmain);
    else if (io != NULL)
    {
	/* "split brain" issue where there are matches on both queues   */
        /* special case, we need to look for best io on mainio list and */
        /* then compare it to the best one found on the staged list     */
	/* this will only apply when there are multiple active io on    */
	/* the two lists that match typ:sector:length which is not the  */
	/* normal case but does occur in data sets and when it does it  */	
	/* often has a high number of incidences.                       */
        best_staged = io;
        best_mainio = search_mainio1(this,io,eventname,&onmain);
	if (best_mainio == best_staged) 
	{
	    /* the above didn't find a (better) match, returned same ptr*/
	    /* avoid sending in two pointers to best_match() same/same  */
	    io = best_staged;
	}
	else
	{
            if ((io = best_match(this,best_staged,best_mainio)) == NULL) io = best_staged;
            if (io == best_mainio) onmain=1;
	    else                   onmain=0;
	}
	/* if there is a match, then we have duplicate typ:sector:length*/
	/* but if we didn't -- which would be normal -- and got a null  */
	/* pointer returned, then reset selected io back to best_staged */
    }


    /* If no match and special is set, give a second special look */
    if ((io == NULL) && (nonio == 1) && ((this->specials & SPCFLG_00) != 0))
	io = search_mainio_special1(this,io,eventname,&onmain);

    if (io != NULL)
    {
        dbg_add_event_to_io(this,io,__LINE__,NULL);

        dprintf( "DBG[%05d]: looking for @%12.9f:%8lu+%6lu, found %12.9f:%8lu+%6lu on %s list\n", __LINE__, 
	    this->timeinfo.time, this->sector, this->length, 
              io->timeinfo.time,   io->sector,   io->length,
	    onmain==0?"staged":"mainio" );

        /* Make sure io is moved to the mainio/active list */
        if (onmain == 0)
        {
            _assert( (io->ioflags & IS_STAGED) != 0 );
            move_staged_to_mainio(io);				/* <== inProgress stats updated in there */
        }
        else
        {
	    /* already on mainio list...           */
            _assert( (io->ioflags & IS_STAGED) == 0 );
        }

        /* Now housekeeping, update last event        */
        /* @@@TBD review which fields other lstevt    */
        io->lstcpu =  this->cpu;
        io->lstact =  this->prmact;
        strcpy(io->lsttyp, this->evttyp);
        bcopy(this, &io->lstevt, sizeof(typ_event));

	this->request = io;
        _assert(io->info != NULL);
        if (state.isPlugged == 1) io->info->plug_state |= PLUGSTATE_I;

        /* capture I event info in events                           */
        if (io->info != NULL) actions = &io->info->events;
        else                  actions = &temp_actions;
        line = this->timeinfo.line;
        time = this->timeinfo.time;

        if (actions->insert.line == 0)
        {
             /* this is first insert event for this io */
             actions->insert_first.line = line;
             actions->insert_first.time = time;

             /* only grab a ticket @first insert time  */
             /* Assigning event Q/I/D/C timestamp processing.                 */
             /* ISeqNo will be used to calc iosched reorder @dispatch time    */
             state.ISeqNo++;
             io->info->ISeqNo = state.ISeqNo;

	     /* inProgess counts are taken care of in move-to-mainio() */
        }
        io->event_mask              |= EVTMSK_I; /* @@ */
	set_event_mask( io,     EVTNDX_I );
        actions->insert.line  = line;
        actions->insert.time  = time;
        io->info->cnt_inserts++;
        io->info->ISeqNo_Ghost     = state.ISeqNo;    /* this just reflects I ticket in state at last I event for this io, not assigned a ticket, it "ghosts" ticket # */
        tprintf( "tDBG[%05d]: event %c:%16ld.%8ld assign insert time %13.9f\n", __LINE__, _prmtyp(this->prmtyp), this->sector, this->length, this->timeinfo.time );


        /* Merge event flags, add procname if not previously available,     */
        /* ditto for extras.                                                */
        io->evtflags |= this->evtflags;
	if ((this->procname[0] != 0) && (io->procname[0] == 0))
        {
	    /* should be there unless this is backfill */
            strcpy(io->procname, this->procname);
	}
	if ((this->extras[0] != 0) && (io->extras[0] == 0))
        {
            strcpy(io->extras  , this->extras  );
	}

        if (io->info->events.insert.time >= io->info->events.first.time )
        {
            dprintf( "%%I[%05d]: insert io %10ld %6ld I:%12.9f > F:%12.9f (+%12.9f)\n", __LINE__, this->sector, this->length,
                io->info->events.insert.time, 
	        io->info->events.first.time,
                io->info->events.insert.time - io->info->events.first.time );
        }
	else
	{
            dprintf( "%%E[%05d]: insert io %10ld %6ld I:%12.9f < F:%12.9f (%12.9f) out of sequence events!\n", __LINE__, this->sector, this->length,
                io->info->events.insert.time, 
	        io->info->events.first.time,
                io->info->events.insert.time - io->info->events.first.time );
	}

        samp.cnt_inserts++;
        summ.cnt_inserts++;
        test_sample_time_boundary(io);
    }
    else if (nonio == 0)
    {
        /* Nope, not on either list. Weird */
        /* new one: this needs to be backfilled, but for now add event to exceptions list and ignore */
        /* @@@TBD */
        printf( "%%F[%05d]-tbd, missing feature.\n", __LINE__ );
	MISS_FEATURE_FAULT(this,(int),"ghost needed?",CTL_FAULT_DEFAULT);
    }

    event_sig_add(io, this);	/* Add matched event signature to io context */

    /* last thing before returning, output annotated event           */
    dbg_lineno = __LINE__;
    annotate_event(this,3,io);
    _return(0);
}


/**
 * ==========================================================================================
 * Function : dispatch_event -- process a Dispatch event
 * Args     : @this:       current event information
 * Returns  : 0
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Find the staging io this belongs to -or- create a new typ_io and place it on the staging
 * queue.  Transfer information from event to typ_io.
 *
 * Notes
 * Special case for discards:
 *    + there is a chance the sequence is A,Q,G  {A,Q}... D,C where the 1st sector 
 *      matches the dispatch sector, but the length at dispatch includes implied merging
 *      of the series of {A,Q}.. chunks of additional length. 
 *    + so for this special discard case only that has a bug in the event stream and is missing
 *      'M' events, if we do not get a direct match but got a partial match to iotype,sector and
 *      its a discard, search the pre-stage list only for additional chunks that pad out the 
 *      original length to the dispatch length.  If the result is a list of found chunks that,
 *      if merged, will update the mainio A,C,G to the size of D event, then synthesize a merge
 *      event string and call merge_event().  Kind of painful as we could replicate the merging
 *      code into this special case, but lets not.  Let's see how painful it is to build the
 *      merge event with fake pid, et.al. information, parse it, then call merge_event() to get
 *      it to glue the set of {A,Q} contexts sitting in prestage into the 1st A,C,G context that
 *      is sitting in the mainio queue.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int dispatch_event (typ_event *this)
{
typ_io *io, *temp;
int rw;
int onmain= 0;
int nonio = 0;
int valid = 0;
typ_actions *actions, temp_actions;
int    line;
double time;
static char eventname[16]="dispatch  ";

    TRACE_FUNCTION;
    io = NULL;
    if ((rw = R_OR_W(this))                    >= 0) valid++;
    if ((this->evtflags & EVTFLG_VALID_SECTOR) != 0) valid++;
    if ((this->evtflags & EVTFLG_VALID_SIZE  ) != 0) valid++;
    if (valid == 3)
    { 
        /* Search mainio/active list for this event -- should be here      */
        io = search_mainio1(this,io,eventname,&onmain);
    }
    else if ((this->evtflags & EVTFLG_KWIOBARRIER) != 0)
    {
	io = search_mainio_barrier1(this,io,eventname,&onmain);
	if ((io == NULL) && (this->imbtyp == IMBTYP_xx))
        {
	    /* IMBTYP_xx : 259,0   11       22     5.027084885   612  D  FN [kworker/11:1H] */
	    /* ...might be other formats, but for now only allow this one.                  */
	    if (this->prmtyp == IOTYP_NONE)
	    {
	        if ((io = imb_active_find(this)) != NULL)
                {
                    q0printf( "DBG[%05d]: looking for @%12.9f:%8lu+%6lu, found %12.9f:%8lu+%6lu on %s list\n", __LINE__,
                            this->timeinfo.time, this->sector, this->length,
                              io->timeinfo.time,   io->sector,   io->length,
                            "imb_active");
                    dprintf( "DBG[%05d]: looking for @%12.9f:%8lu+%6lu, found %12.9f:%8lu+%6lu on %s list\n", __LINE__,
                            this->timeinfo.time, this->sector, this->length,
                              io->timeinfo.time,   io->sector,   io->length,
                            "imb_active");
    
                    /* Its possible this is still stuck on the staged queue, if so move */
                    /* it to the mainio queue where 'D'ispatch logic expects it to be   */
                    printf( "DBG[%05d]: %s(staged = %d)\n", __LINE__, __func__, io->ioflags & IS_STAGED );
                    if ((io->ioflags & IS_STAGED) != 0)
                    {
                        printf( "DBG[%05d]: call move_staged_to_mainio()...\n", __LINE__ );
                        move_staged_to_mainio(io);                          /* <== inProgress stats updated in there */
                                                                            /*     should we also move to postio?    */
                    }
                    printf( "DBG[%05d]: %s(staged = %d)\n", __LINE__, __func__, io->ioflags & IS_STAGED );
                    _assert( (io->ioflags & IS_STAGED) == 0 );
                }
            }
	}
        if (io == NULL)
        {   
            dprintf( "DBG[%05d]: new io to be created, KWIOBARRIER found no match in staged queue\n", __LINE__ );
        }
    }
    else
    {           
        dprintf( "DBG[%05d]: io filtered off, will not search stage queue for io\n", __LINE__ );
        /* will never be able to match this to a staging io so just build new io */
        /* Need to create and backfill a mainio ... or just move to exceptions   */
        /* and forget about it.                                                  */
        nonio = 1;
    }


    if (io != NULL) 
    {
        dbg_add_event_to_io(this,io,__LINE__,NULL);

        dprintf( "DBG[%05d]: looking for @%12.9f:%8lu+%6lu, found %12.9f:%8lu+%6lu on %s list\n", __LINE__, 
	    this->timeinfo.time, this->sector, this->length, 
              io->timeinfo.time,   io->sector,   io->length,
	    onmain==0?"staged":"mainio" );

	/* state.InProgress/Inflight updates, if any  */

        /* Now housekeeping, update last event        */
        /* @@@TBD review which fields other lstevt    */
        io->lstcpu =  this->cpu;
        io->lstact =  this->prmact;
        strcpy(io->lsttyp, this->evttyp);
        bcopy(this, &io->lstevt, sizeof(typ_event));

	this->request = io;
        _assert(io->info != NULL);
        if (state.isPlugged == 1) io->info->plug_state |= PLUGSTATE_D;

        /* capture D event info in events                           */
        if (io->info != NULL) actions = &io->info->events;
        else                  actions = &temp_actions;
        line = this->timeinfo.line;
        time = this->timeinfo.time;

        /* @@@TBD: NOTE: previous model tweak assignment of dispatch based upon option flag_negrequeue       */
        /*               however, the new model is going to always assign (first) dispatch time as well as   */
        /*               last_dispatch time without regard to option.  The option will only come into play at*/
        /*               dump io @completion time.                                                           */
        if (actions->dispatch.line == 0) 
        {
	     /* this is first dispatch event for this io */
	     actions->dispatch_first.line = line;
	     actions->dispatch_first.time = time;
	
	     /* only grab a ticket @first dispatch time  */
             /* Assigning event Q/I/D/C timestamp processing.                 */
             /* DSeqNo will be used to calc storage reorder @completion time  */
             state.DSeqNo++;
             io->info->DSeqNo = state.DSeqNo;
	}
        io->event_mask              |= EVTMSK_D; /* @@ */
	set_event_mask( io,            EVTNDX_D );
        actions->dispatch.line       = line; 
        actions->dispatch.time       = time;
        io->info->cnt_dispatches++;
        /*printf( "DBG[%05d]: %p.cnt_dispatches %d -> %d\n", __LINE__, io, io->info->cnt_dispatches-1, io->info->cnt_dispatches ); */
        io->info->DSeqNo_Ghost       = state.DSeqNo;	/* this just reflects D ticket in state at last D event for this io, not assigned ticket, it "ghosts" ticket # */
        	
        tprintf( "tDBG[%05d]: event %c:%16ld.%8ld assign dispatch time %13.9f\n", __LINE__, _prmtyp(this->prmtyp), this->sector, this->length, this->timeinfo.time );


        /* Merge event flags, add procname if not previously available,     */
        /* ditto for extras.                                                */
        io->evtflags |= this->evtflags;
	if ((this->procname[0] != 0) && (io->procname[0] == 0))
        {
	    /* should be there unless this is backfill */
            strcpy(io->procname, this->procname);
	}
	if ((this->extras[0] != 0) && (io->extras[0] == 0))
        {
            strcpy(io->extras  , this->extras  );
	}

        /* Assigning event Q/I/D/C timestamp processing.                 */
        /* ISeqNo will be used to calc iosched reorder @dispatch time    */
        /* no:  _assert(io->info->ISeqNo == 0); as multiple I w/requeue  */
	/* note: DseqNo++ already done above -- its only done for 1st dispatch!? */
        if (io->info->events.dispatch.time >= io->info->events.first.time )
        {
            dprintf( "%%I[%05d]: dispatch io %10ld %6ld D:%12.9f > F:%12.9f (+%12.9f)\n", __LINE__, this->sector, this->length,
                io->info->events.dispatch.time, 
	        io->info->events.first.time,
                io->info->events.dispatch.time - io->info->events.first.time );
        }
	else
	{
            dprintf( "%%E[%05d]: dispatch io %10ld %6ld D:%12.9f < F:%12.9f (%12.9f) out of sequence events!\n", __LINE__, this->sector, this->length,
                io->info->events.dispatch.time, 
	        io->info->events.first.time,
                io->info->events.dispatch.time - io->info->events.first.time );
	}

        if ((io->evtflags & EVTFLG_GHOST) == 0)
	{
            /* in ascending order:
             * read       = IOTYP_READ
             * write      = IOTYP_WRITE, IOTYP_META, IOTYP_BARRIER
             * discard    = IOTYP_DISCARD, treat as writes for inflight counter purposes
             */
            state.inFlight++;
            if (io->prmtyp == IOTYP_READ ) state.inFlight_Read++;
            if (io->prmtyp >= IOTYP_WRITE) state.inFlight_Write++;	/* Covers write, meta, barrier... */
	    cnt_printf( "DBG[%05d]: %24s() iocnt (%5d) inFlight++   %5d: %5d,%5d %s\n", __LINE__, __func__, state.inProgress, state.inFlight, state.inFlight_Read, state.inFlight_Write,
			(((state.inFlight_Read < 0.0) || (state.inFlight_Write < 0.0))?" : counter is negative":"") );
            cnt_fprintf( outf, "DBG[%05d]: %c:%08ld.%06ld iocnt (%5d) inFlight++   %5d: %5d,%5d\n", __LINE__, 
		_prmtyp(this->prmtyp), this->sector, this->length, state.inProgress, state.inFlight, state.inFlight_Read, state.inFlight_Write );
	}
	if (state.inFlight > state.inProgress)
        {
	    _EXIT( printf( "%%F[%05d]: %s() internal logic fault: state.inFlight %d > state.inProgress!?\n", __LINE__, __func__, state.inFlight, state.inProgress ) );
	}

	samp.cnt_dispatches++;
        summ.cnt_dispatches++;
        test_sample_time_boundary(io);
    }
    else if ((this->evtflags & EVTFLG_KWIOBARRIER) != 0)
    {
        /* No io match found, could create a ghost but instead just discard */
	if (io == NULL)
        {
            dprintf( "DBG[%05d]: discarded, KWIOBARRIER found no match in mainio queue\n", __LINE__ );
            sprintf( this->reason, "[%05d]: KWIOBARRIER but no mainio match found\n", __LINE__ );
            this->evtflags |= EVTFLG_EXCEPTION | EVTFLG_DISCARDED;
            exceptionevent(this,__LINE__,"io filtered off, barrier event: missing matching io");
        }
    }
    else if (nonio == 0)
    {
        /* Nope, not on either list. Weird */
        /* new one: this needs to be backfilled, but for now add event to exceptions list and ignore */
        /* @@@TBD */
        printf( "%%F[%05d]-tbd, missing feature.\n", __LINE__ );
	MISS_FEATURE_FAULT(this,(int),"ghost needed?",CTL_FAULT_DEFAULT);
    }

    event_sig_add(io, this);	/* Add matched event signature to io context */

    /* last thing before returning, output annotated event           */
    dbg_lineno = __LINE__;
    annotate_event(this,3,io);
    _return(0);
}		

/**
 * ==========================================================================================
 * Function : _create_ghost_dispatch -- process a Dispatch event
 * Args     : @this:       current event information
 * Returns  : 0
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int _create_ghost_dispatch(typ_event *this, typ_io *io)
{
typ_actions *actions, temp_actions;
int    line;
double time;

        TRACE_FUNCTION;
        /* capture D event info in events                           */
        if (io->info != NULL) actions = &io->info->events;
        else                  actions = &temp_actions;
        line = this->timeinfo.line;
        time = this->timeinfo.time;

        /* @@@TBD: NOTE: previous model tweak assignment of dispatch based upon option flag_negrequeue       */
        /*               however, the new model is going to always assign (first) dispatch time as well as   */
        /*               last_dispatch time without regard to option.  The option will only come into play at*/
        /*               dump io @completion time.                                                           */
        if (actions->dispatch.line == 0)
        {
             /* this is first dispatch event for this io */
             actions->dispatch_first.line = line;
             actions->dispatch_first.time = time;

             /* only grab a ticket @first dispatch time  */
             /* Assigning event Q/I/D/C timestamp processing.                 */
             /* DSeqNo will be used to calc storage reorder @completion time  */
             state.DSeqNo++;
             io->info->DSeqNo = state.DSeqNo;
        }
        io->event_mask              |= EVTMSK_D; /* @@ */
	set_event_mask( io,            EVTNDX_D );
        actions->dispatch.line       = line;
        actions->dispatch.time       = time;

        printf( "%%E[%05d]:+dispatch io %10ld %6ld D:%12.9f > F:%12.9f (+%12.9f) [R.GHOST D:%2d R:%2d]\n", __LINE__, this->sector, this->length,
                io->info->events.dispatch.time,
                io->info->events.first.time,
                io->info->events.dispatch.time - io->info->events.first.time,
		io->info->cnt_dispatches, 
		io->info->cnt_requeues );

        io->info->cnt_dispatches++;
        /*printf( "DBG[%05d]: %p.cnt_dispatches %d -> %d\n", __LINE__, io, io->info->cnt_dispatches-1, io->info->cnt_dispatches ); */
        io->info->cnt_dispatches_ghosts++;
        io->info->DSeqNo_Ghost       = state.DSeqNo;    /* this just reflects D ticket in state at last D event for this io, not assigned ticket, it "ghosts" ticket # */

        if (io->info->events.dispatch.time >= io->info->events.first.time )
        {
            dprintf( "%%I[%05d]: dispatch io %10ld %6ld D:%12.9f > F:%12.9f (+%12.9f) [R.GHOST]\n", __LINE__, this->sector, this->length,
                io->info->events.dispatch.time,
                io->info->events.first.time,
                io->info->events.dispatch.time - io->info->events.first.time );
        }
        else
        {
            dprintf( "%%E[%05d]: dispatch io %10ld %6ld D:%12.9f < F:%12.9f (%12.9f) [R.GHOST]  out of sequence events!\n", __LINE__, this->sector, this->length,
                io->info->events.dispatch.time,
                io->info->events.first.time,
                io->info->events.dispatch.time - io->info->events.first.time );
        }

    _return(0);
}

/**
 * ==========================================================================================
 * Function : requeue_event -- process a requeue event
 * Args     : @this:       current event information
 * Returns  : 0
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Driver rejected back a previous 'D'ispatched io for some reason.  
 * Therefore, search the mainio queue for a match to this sector:length, etc.
 * Transfer information from event to typ_io.
 *
 * Notes
 * 11.08.23 Add checks that a dangling D is present, if not create a "ghost" D event to 
 * proceed this Requeue.  This also helps with D2D calculations.  Create a warning also.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int requeue_event(typ_event *this)
{
typ_io *io, *temp;
int rw;
int onmain= 0;
int nonio = 0;
int valid = 0;
typ_actions *actions, temp_actions;
int    line;
double time;
static char eventname[16]="requeue   ";

    TRACE_FUNCTION;
    io = NULL;
    if ((rw = R_OR_W(this))                    >= 0) valid++;
    if ((this->evtflags & EVTFLG_VALID_SECTOR) != 0) valid++;
    if ((this->evtflags & EVTFLG_VALID_SIZE  ) != 0) valid++;
    if (valid == 3) /* we only care about data movement commands; r/w + valid lba+len */
    {
        /* Search mainio/active list for this event -- should be here      */
        io = search_mainio1(this,io,eventname,&onmain);
    }
    else
    {
        dprintf( "DBG[%05d]: io filtered off, will not search stage queue for io\n", __LINE__ );
        /* will never be able to match this to a staging io so just build new io */
        /* Need to create and backfill a mainio ... or just move to exceptions   */
        /* and forget about it.                                                  */
        nonio = 1;
    }

    if (io != NULL)
    {
	/* Before adding the R event to io context...                      */
	/* If current D-R count is not zero, then a ghost D event is needed*/
        /* With some dm-mpath and other dm layers you can get QIRRRDC train*/
        if ((io->info != NULL) && (io->info->cnt_dispatches == io->info->cnt_requeues))
	{
	    /* We should not have any Requeues if there are zero prior Ds   */
	    /* We should not have a   Requeue  if R == D 		   */
	    /*     case 1) dispatches = zero and no prior requeues          */
	    /*     case 2) D->R or D,R,D,R then expecting D nor R!          */
	    printf( "DBG[%05d]: %s()  create_ghost_dispatch(%p)\n", __LINE__, __func__, io );
	    _create_ghost_dispatch(this,io);
	}


        dbg_add_event_to_io(this,io,__LINE__,NULL);

        dprintf( "DBG[%05d]: looking for @%12.9f:%8lu+%6lu, found %12.9f:%8lu+%6lu on %s list\n", __LINE__,
            this->timeinfo.time, this->sector, this->length,
              io->timeinfo.time,   io->sector,   io->length,
            onmain==0?"staged":"mainio" );

        /* state.InProgress/Inflight updates, if any  */

        /* Now housekeeping, update last event        */
        /* @@@TBD review which fields other lstevt    */
        io->lstcpu =  this->cpu;
        io->lstact =  this->prmact;
        strcpy(io->lsttyp, this->evttyp);
        bcopy(this, &io->lstevt, sizeof(typ_event));

        this->request = io;
        _assert(io->info != NULL);
        if (state.isPlugged == 1) io->info->plug_state |= PLUGSTATE_D;

        /* capture R event info in events                           */
        if (io->info != NULL) actions = &io->info->events;
        else                  actions = &temp_actions;
        line = this->timeinfo.line;
        time = this->timeinfo.time;

        /* @@@TBD: NOTE: previous model tweak assignment of requeue based upon option flag_negrequeue        */
        /*               however, the new model is going to always assign (first) dispatch time as well as   */
        /*               last_dispatch time without regard to option.  The option will only come into play at*/
        /*               dump io @completion time.                                                           */
        if (actions->requeue.line == 0)
        {
             /* this is first requeue event for this io */
             actions->requeue_first.line = line;
             actions->requeue_first.time = time;

             /* only grab a ticket @first requeue time  */
             /* Assigning event Q/I/D/R/C timestamp processing.               */
             state.RSeqNo++;
             io->info->RSeqNo = state.RSeqNo;

        }
        io->event_mask              |= EVTMSK_R; /* @@ */
	set_event_mask( io,            EVTNDX_R );
        actions->requeue.line        = line;
        actions->requeue.time        = time;
        io->info->cnt_requeues++;
        /* io->info->DSeqNo_Ghost       = state.DSeqNo;*/    /* this just reflects D ticket in state at last D event for this io, not assigned ticket, it "ghosts" ticket # */

        tprintf( "tDBG[%05d]: event %c:%16ld.%8ld assign requeue time %13.9f\n", __LINE__, _prmtyp(this->prmtyp), this->sector, this->length, this->timeinfo.time );


        /* Merge event flags, add procname if not previously available,     */
        /* ditto for extras.                                                */
        io->evtflags |= this->evtflags;
        if ((this->procname[0] != 0) && (io->procname[0] == 0))
        {
            /* should be there unless this is backfill */
            strcpy(io->procname, this->procname);
        }
        if ((this->extras[0] != 0) && (io->extras[0] == 0))
        {   
            strcpy(io->extras  , this->extras  );
        }

        /* Assigning event Q/I/D/C timestamp processing.                 */
        /* ISeqNo will be used to calc iosched reorder @dispatch time    */
        /* no:  _assert(io->info->ISeqNo == 0); as multiple I w/requeue  */
	/* note: RSeqNo only assigned for 1st requeue, so not here       */
        if (io->info->events.requeue.time >= io->info->events.dispatch.time )
        {
            dprintf( "%%I[%05d]: requeue io %10ld %6ld R:%12.9f > D:%12.9f (+%12.9f)\n", __LINE__, this->sector, this->length,
                io->info->events.requeue.time,
                io->info->events.dispatch.time, 
                io->info->events.requeue.time - io->info->events.dispatch.time );
        }
        else
        {
            dprintf( "%%E[%05d]: requeue io %10ld %6ld R:%12.9f < D:%12.9f (-%12.9f) out of sequence events!\n", __LINE__, this->sector, this->length,
                io->info->events.requeue.time,
                io->info->events.dispatch.time, 
                io->info->events.requeue.time - io->info->events.dispatch.time );
        }

        if (((io->evtflags & EVTFLG_GHOST) == 0) && ((io->event_mask & EVTMSK_D) != 0))
        {
            /* in ascending order:
             * read       = IOTYP_READ
             * write      = IOTYP_WRITE, IOTYP_META, IOTYP_BARRIER
             * discard    = IOTYP_DISCARD, count as writes for inflight purposes
             */
            state.inFlight--;
            if (io->prmtyp == IOTYP_READ ) --state.inFlight_Read;
            if (io->prmtyp >= IOTYP_WRITE) --state.inFlight_Write;     /* Covers write, meta, barrier... */
	    cnt_printf( "DBG[%05d]: %24s() iocnt (%5d) inFlight--   %5d: %5d,%5d %s\n", __LINE__, __func__, state.inProgress, state.inFlight, state.inFlight_Read, state.inFlight_Write,
			(((state.inFlight_Read < 0.0) || (state.inFlight_Write < 0.0))?" : counter is negative":"") );
            cnt_fprintf( outf, "DBG[%05d]: %c:%08ld.%06ld iocnt (%5d) inFlight--   %5d: %5d,%5d\n", __LINE__, 
		_prmtyp(this->prmtyp), this->sector, this->length, state.inProgress, state.inFlight, state.inFlight_Read, state.inFlight_Write );
	}
	if (state.inFlight > state.inProgress)
	{
	    _EXIT( printf( "DBG[%05d]: %s()\n", __LINE__, __func__ ) );
	}

        samp.cnt_requeues++;
        summ.cnt_requeues++;
        switch (this->prmtyp)
        {
            case IOTYP_UNK      :
            case IOTYP_OTHER    :
            case IOTYP_NONE     : 
	    case IOTYP_SCHED    :
            case IOTYP_READ     : samp.cnt_requeues_reads++;  summ.cnt_requeues_reads++;  break;
            case IOTYP_WRITE    : 
            case IOTYP_META     : 
            case IOTYP_BARRIER  : samp.cnt_requeues_writes++;   summ.cnt_requeues_writes++;   break;
            case IOTYP_DISCARD  : samp.cnt_requeues_discards++; summ.cnt_requeues_discards++; break;
            default             : printf( "%%W-requeue type '%d', not read or write?\n", this->prmtyp ); break;
        }

        test_sample_time_boundary(io);
    }
    else if (nonio == 0)
    {
        /* Nope, not on either list. Weird */
        /* new one: this needs to be backfilled, but for now add event to exceptions list and ignore */
        /* @@@TBD - for now treat this as a "notarget fault" rather than programming or nofeature    */

	/* notarget fault, not really a missing feature (like bounce_event() is)		     */
	/* this is notarget/discard. not finding the target *may* be a missing feature, but we can't */
	/* ell without examples for cause							     */
	NOTARGET_FAULT(this,(int),"notarget matched, may be missing feature",CTL_FAULT_DEFAULT );
	printf( "DBG[%05d]: continuing after discard of '%c' event.\n", __LINE__, this->prmact );
    }

    event_sig_add(io, this);	/* Add matched event signature to io context */

    /* last thing before returning, output annotated event           */
    dbg_lineno = __LINE__;
    annotate_event(this,3,io);
    _return(0);
}


/**
 * ==========================================================================================
 * Function : flush_postio -- output any timed out/completed io on the postio queue
 * Args     : @this:          pointer to current event
 * 		              if null, then this is call at EOF time and flush *ALL* of postio
 * Returns  : 0
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Check the io on the postio list to see if they meet criteria for a call to output_completed_io().
 * Normally, this == event, io only output if it was placed on the queue because there were other io 
 * already on the postio queue (not empty) -- so had to be placed on the postio queue to maintain
 * output order or there was a C event on an io but that io had the potential to have additional
 * C events target it.  It turns out that this seems to be all io, unfortunately.
 *
 * If this==NULL, then this is EOF time.  Any io on postio list had at least one C event against it,
 * so because this is EOF time and no additional C events can arrive after EOF, flush all pending
 * completed io on the postio queue as if the tmo for all has expired.
 *
 * Notes
 * Called only from two places: output_completed_io() and at EOF time in main() just before
 * summ_dump() called as part of wind-down at EOF time.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int flush_postio( typ_event *this )
{
typ_io *io;

    TRACE_FUNCTION;
    for (io=postio_list; io != NULL; io = io->next)
    {
	if (((io->subio == NULL) && (io->ctracker == NULL)) || (this == NULL))
	{
	    /* this != null                                           */
	    /* This was parked here because postio queue wasn't empty */
	    /* So this request had to wait for the previous requests  */
	    /* with at least one C event to tmo and get output first  */
	    /* this == null                                           */
	    /* don't care the reason, this is @EOF, flush out any/all */
            /* io on postio queue regardless of other status (like    */
	    /* waiting for possible additional C events -- don't care */
	    /* if this is EOF time).                                  */
            test_sample_time_boundary(io);

	    q0printf( "DBG[%05d]: call completed io, no ctracker sector:length %ld:%ld \n", __LINE__, io->sector, io->length );
            output_completed_io(io,"",POSTIO_QUEUE);
	    move_postio_to_done(io);
	    continue;
	}
        if (this != NULL)
	{
	    if ((io->ctracker != NULL) &&
	       ((io->ctracker->tmo_time <= this->timeinfo.time)   ||
	        (io->ctracker->tmo_line <= this->timeinfo.line))  ||
	        (io->info->cnt_completed_subio >= (io->info->cnt_merges+1)))
            {
	        /* io timed out waiting on post_queue */
                /* .or. all subio marked as completed */
	        if ((io->ioflags & (IS_WHOLE_COMPLETE | IS_BIO_COMPLETE)) == 0)
                {
		    dprintf( "DBG[%05d]: %05d %11.6f %ld:%ld (subio=%d) %016lX\n", __LINE__, io->ctracker->tmo_line, io->ctracker->tmo_time, 
			    io->sector, io->length, io->info->cnt_merges, io->ioflags);
	            dprintf( "DBG[%05d]: %05d %11.6f\n", __LINE__, this->timeinfo.line, this->timeinfo.time );
		    /* this might be data fault.... unclear; this isn't about the passed in event so use fault1(io) versoin */
		    PROG_FEATURE_FAULT1(io, (int),"post queue io timed out but not marked complete, internal logic error.", CTL_FAULT_DEFAULT);
	        }
	        dprintf( "DBG[%05d]: call completed io, tmo ctracker sector:length %ld:%ld \n", __LINE__, io->sector, io->length );
                output_completed_io(io,"",POSTIO_QUEUE);
	        move_postio_to_done(io);
	        continue;
	    }
            break;
	}
	/* else this is flg=1 case and this is null */
    }
    _return(0);
}
        

/**
 * ==========================================================================================
 * Function : complete_event -- process a 'C'omplete io event
 * Args     : @this:       current event information
 * Returns  : 0
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Find the io this event belongs to, but there are multiple cases:
 * 1   ]  "nominal" case 1 D : 1 C event, 1st C covers whole request
 * 1.A ]                 1 D : n C events,1st C covers whole request
 *                    subsequent C events cover 2nd-Nth BIO under request
 * 2   ]                 1 D:  n C where n = number of BIO merged into request
 *
 * So multiple searches.
 * A) check top of post queue, if any are waiting to "timeout" and timeout reached, flush
 *    completion data to file.  If the "timedout" io is of the non 1:1 (D:C) variety, then
 *    output summary of same to odd behavior log file.  Rinse, repeat until you find no
 *    timedout entries.
 * B) search activeio list for a full coverage match, if yes, then add ctracker structure,
 *    capture data, move to postio_list where they will live for short period of time.  Set the
 *    tmo values in both time and line count. If this does not have any merged io, then the
 *    tmo values are "now".  But to preserve output order, this io must be added to the postio_list
 *    if the postio_list is non-zero length (otherwise output immediately and free).  If has
 *    merged io count, then set timeout value to +0.5 second or #20 events.  At this time that
 *    is an 'OR' condition but that may need to change to .and. if needed.  Then done, next event!
 *    Mark ioflags as IS_WHOLE_COMPLETE. So mark individual BIO with that flag also.  Create/link
 *    in ctracker structure.  Allocation (numb bio x 2 ) + 2 just in case.  Set tmo time and line
 *    values, capture C event info in ctracker.
 * C) now search postio_list for partial match only.  This for case were a full coverage (C-whole+BIO)
 *    has previously moved the io to postio_list or the first BIO-1toN happened to push the io to 
 *    postio_list.  If a match is found with the io wholly within the request. Use that request.
 *    If the start/length does not *exactly* match an individual BIO, complete and fatal out
 *    until logic is added to handle this specific case.  Update ctracker info including tmo values
 *    based on new line and time. 
 * D) still no match, go back to active list and look for this C event being wholly inside a request
 *    and a bio.  Complain if wholly within an io of the same type, but not against a single BIO
 *    therein. Fatal out if not wholly in and matching exactly 1 BIO therein, otherwise move request
 *    to postio_list, mark the BIO as complete, bump the bio completed count until it is exactly matched.
 *    At that point allow the request to tmo normally, just in case the BIO C events are followed by
 *    a C whole request event (hasn't happened yet, but might).
 * E) "Special" 4.18.* FWS io barrier case
 * F) "Special" 2.6.32 dm- device case (only has Q|C events, so io sill on staging queue)
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Really should *not* find a matching io present unless there are other circumstances... like
 * in 2.6.32 for dm (253) devices you only have Q|C events; there are no events to move the io
 * from staging to active like normal.  So, if this is a dm device in the 'this' event and we
 * don't find and io, then try one more time in the staging queue and go from staging to post
 * queue directly.
 **/
int complete_event(typ_event *this)
{
typ_io *io,  *temp;
typ_io *bio, *subio;
int rw;
int onmain= 0;
int onpost= 0;
int nonio = 0;
int valid = 0;
int new_valid=0;
typ_actions *actions, temp_actions;
int    line;
double time;
int    bytes;
int    ndx, subcnt;
int    corner_case;
long   end_sector;
long   covered, mask;
int    io_in_request=0;
char   found_type=0;
char   reason[256];
static char eventname[16]="completion";

    TRACE_FUNCTION;

    /* Check top of postio_list for any tmo events and output those */
    dprintf( "DBG[%05d]: part 'A' - tmo check of %d\n", __LINE__, postio_on_list );
    flush_postio(this);

    if (this->cpu < MAXCPUS)
    {
	/* This reflects interrupts service for completing io */
        samp.cpu_end[this->cpu]++;
	summ.cpu_end[this->cpu]++;
    }

        
    io = NULL;
    bio= NULL;
    subcnt=0;
    covered=0;
    if ((rw = R_OR_W(this))                    >= 0) valid++;
    if ((this->evtflags & EVTFLG_VALID_SECTOR) != 0) valid++;
    if ((this->evtflags & EVTFLG_VALID_SIZE  ) != 0) valid++;
    if ((this->evtflags & EVTFLG_KWIOBARRIER  ) != 0)
    {
        /* Special case(s)
         * 253,89  39       58     0.076365906  1642  C  FN 0 [0]	< find on mainio, move to postio [1]
	 * 253,89  39       59     0.076366168  1642  C  WS 0 [0]	< find on postio first, set whole io complete
	 *
	 * or if no writes to barrier/flush, just:
	 *
	 * 253,89  39       59     0.076366168  1642  C  WS 0 [0]	< find on mainio 2nd, set whole io complete move to postio
	 *
	 * [1] in theory, could skip/discard this event or mark the found io with first C event but no move it to postio
	 *     knowing there is a 2nd complete -- then the C Barrier is just "search mainio" always.
	 */
    }


    if (valid != 3)
    {           
        dprintf( "DBG[%05d]: io filtered off, will not search mainio queue for io (valid=%d)\n", __LINE__, valid );
        /* will never be able to match this to a staging io so just build new io */
        /* Need to create and backfill a mainio ... or just move to exceptions   */
        /* and forget about it.                                                  */
        nonio = 1;
    }
    if (valid == 2)
    {
	/* promote this event if its special */
        if ((rw = R_OR_W(this))                    >= 0) new_valid++;
        if ((this->evtflags & EVTFLG_VALID_SECTOR) != 0) new_valid++;
        if ((this->evtflags & EVTFLG_SPECIAL_FWS ) != 0) new_valid++;
	if (new_valid == 3)
	{
	    valid = 3;
	    nonio = 0;
	}
    }
    while (valid == 3)
    {
	/* B) search mainio_list for full coverage io only                      */
	/* E) "      "           "        "        io only                      */
	/* C) search postio_list for   (sub)BIO match only 			*/
        /* D) search mainio_list for   (sub)BIO match only                      */
	/* I) search imb_cache   for match/fuzzy match                          */

	if ((new_valid == 3) && ((this->evtflags & EVTFLG_SPECIAL_FWS) != 0))
	{
	    /* B.0 search postio list for any io that has this->sector listed and is same primary type and already has ctracker */
	    /* "Special" WFS (IMB) case.                                                                                        */
            io_in_request = 0;
            dprintf( "DBG[%05d]: part 'B.0' - postio sector match only\n", __LINE__);
            dprintf( "DBG[%05d]: check postio list for match %10ld:%6ld...{sector only special case}\n", __LINE__, this->sector, this->length );
            for (temp = postio_list; temp != (typ_io *)NULL; temp = temp->next)
            {
                dprintf( "DBG[%05d]: postio list  %p %10ld:%6ld...(sub-BIO=%d)\n", __LINE__, temp, temp->sector, temp->length, temp->info->cnt_merges);
		if (temp->subio  != NULL        ) continue;
	        if (temp->sector != this->sector) continue;
                if ( R_OR_W(temp)                         != rw) continue; /* not the same (broad) type of io */
                if ((temp->evtflags & EVTFLG_VALID_SECTOR) == 0) continue; /* doesn't have valid sector numb  */
                if ((temp->evtflags & EVTFLG_VALID_SIZE  ) == 0) continue; /* doesn't have valid size   numb  *//* fyi: this is request check, not event check */
                if ( temp->minor  != this->minor               ) continue; /* not the same device             */
                if ( temp->major  != this->major               ) continue; /* not even same major device type */
		if ((strncmp(temp->evttyp, "FWFS", 4)       != 0) &&
		    (strncmp(temp->evttyp,  "WFS", 3)       != 0)) continue; /* Not the same WFS special type */
		if ((temp->ioflags & IS_WHOLE_COMPLETE)     == 0) continue;  /* needs to be marked complete by previous C event */

                dprintf( "DBG[%05d]: postio list  %p %10ld:%6ld... passed other filters!\n", __LINE__, temp, temp->sector, temp->length );
		if ((temp->evtflags & EVTFLG_SPECIAL_FWS) == 0)
		{
		    printf( "DBG[%05d]: set flag SPECIAL_FWS???\n");
		    temp->evtflags |= EVTFLG_SPECIAL_FWS; /* FWS @@@@ this really should be done in parse_event? no? */
		}
                io = temp;
                onpost = 1;
	    }
	}
        if (io != NULL) { found_type = 'E'; break; }
	    

	/* B) search mainio_list for full coverage io only                      */
        /* Search mainio/active list for this event -- should be here           */
        dprintf( "DBG[%05d]: part 'B' - mainio full request match check\n", __LINE__);
        dprintf( "DBG[%05d]: check mainio list for match %10ld:%6ld...{full request coverage}\n", __LINE__, this->sector, this->length );
        for (temp = mainio_list; temp != (typ_io *)NULL; temp = temp->next)
        {
	    /* NOTE: search won't run check_io_found() like normal as its not  */
	    /*       certain yet whether this is an orphan or not...           */
            io = search_mainio1(this,io,eventname,&onmain);
        }
        if (io != NULL) { found_type = 'B'; break; }

	/* C) search postio_list   for (sub)BIO match only 			*/
        io_in_request = 0;
        dprintf( "DBG[%05d]: part 'C' - postio sub-bio match only\n", __LINE__);
        dprintf( "DBG[%05d]: check postio list for match %10ld:%6ld...{sub-BIO only coveraged}\n", __LINE__, this->sector, this->length );
        end_sector = (this->sector + this->length) - ((this->length > 0 )?1:0);
        for (temp = postio_list; temp != (typ_io *)NULL; temp = temp->next)
        {
            dprintf( "DBG[%05d]: postio list  %p %10ld:%6ld...(sub-BIO=%d)\n", __LINE__, temp, temp->sector, temp->length, temp->info->cnt_merges);
            if ((this->sector >= temp->sector) && (end_sector <= ((temp->sector + temp->length)-1)))
            {
                io_in_request   = 1;
                if ((temp->subio == NULL) && (io_in_request == 1))
                {
                    /* This match means a BIO or whole C event matched this IO already, somehow */
                    /* and now we have a complete/whole request C match too.                    */
		    dprintf( "DBG[%05d] %ld <= %ld:%ld >= %ld\n", __LINE__, temp->sector, this->sector, 
			end_sector, (temp->sector + temp->length)-1 );
                    PROG_FEATURE_FAULT(this,(int),"internal logic fault; postio has no subio but matches this C in part 'C' check?", CTL_FAULT_DEFAULT );
                }
                dprintf( "DBG[%05d]: postio list  %p %10ld:%6ld...possible match...)\n", __LINE__, temp, temp->sector, temp->length);
                if ( R_OR_W(temp)                         != rw) continue; /* not the same (broad) type of io */
                if ((temp->evtflags & EVTFLG_VALID_SECTOR) == 0) continue; /* doesn't have valid sector numb  */
                if ((temp->evtflags & EVTFLG_VALID_SIZE  ) == 0) continue; /* doesn't have valid size   numb  */
                if ( temp->minor  != this->minor               ) continue; /* not the same device             */
                if ( temp->major  != this->major               ) continue; /* not even same major device type */
                dprintf( "DBG[%05d]: postio list  %p %10ld:%6ld... passed other filters!\n", __LINE__, temp, temp->sector, temp->length );

	        /* Search for any/all BIO that are covered by the C events sector:length value -- there may be more than 1! */
                /* For each subBIO matched, set IS_BIO_COMPLETE | IS_BIO_COVERED, the second covered is temp flag and allows*/
                /* backing out of BIO_COMPLETE if things don't add up correctly.  Increment subcnt for each bio matched and */
		/* increase covered by the length in the bio.  If at the end we don't have covered == this->length then back*/
		/* out the whole thing and fatal out because we clearly didn't understand something correctly.  Otherwise   */
	        /* increment io->info completion count, et.al. and the normal stuff since we did match the current C event  */
                /* fully/wholly against this request's set of BIOs.                                                         */			
                for (covered=0, subcnt=0, subio = temp->subio; subio != NULL; subio = subio->subio)
                {
                    dprintf( "DBG[%05d]:  subio list  %p %10ld:%6ld...\n", __LINE__, subio, subio->sector, subio->length );
		    /* is this subio fully within event's lba:length? */
		    if (  subio->sector                    <  this->sector ) continue;
		    if ( (subio->sector + subio->length)-1 >    end_sector ) continue;
		    subcnt++;
		    covered += subio->length;
                    dprintf( "DBG[%05d]:  subio list  %p %10ld:%6ld... %d matched, %ld sectors covered!\n", __LINE__, subio, subio->sector, subio->length, subcnt, covered );
                    io = temp;
                    onpost = 1;
		    temp->ioflags |= IS_EXCEPTION; /* so this is output into exceptions file, as we're getting granular C events != whole request */
		    if (((subio->ioflags & IS_BIO_COMPLETE) != 0) || ((subio->ioflags & IS_WHOLE_COMPLETE) != 0))
		    {
			temp->ioflags |= IS_DUPE_COMPS;
			if (conf_allow_duplicate_completes == 0)
			{
			    PROG_FEATURE_FAULT(this,(int),"internal logic fault, subio already marked completed?!", CTL_FAULT_DEFAULT );
			}
		        else
			    dprintf( "DBG[%05d]: duplicate completion on BIO detected, config settings allow continuing...\n", __LINE__ );
		    }
		    dprintf( "DBG[%05d] %ld:%ld set ( IS_BIO_COMPLETE | IS_BIO_COVERED) on subio %ld:%ld\n", __LINE__, temp->sector, temp->length, subio->sector, subio->length );
		    subio->ioflags |= ( IS_BIO_COMPLETE | IS_BIO_COVERED);
		    bio = NULL;

		    /* If fully covered, break out -- otherwise keep searching for more */
		    if (covered == this->length) break;
                }
		/* Remove matched 'io' BIO_COVERED flag, and rever BIO_COMPLETE if needed */
		if (subcnt != 0)
	        {
		    subio = io->subio; /* grab here so can null out 'io' if didn't fully cover event */
		    if (covered != this->length) 
		    { 
			dprintf( "DBG[%05d]:  subio list partial covered? %d bio match for %ld of %ld sectors, revert!\n", __LINE__, subcnt, covered, this->length );
			mask = ~(IS_BIO_COMPLETE | IS_BIO_COVERED ); 
			io = NULL;
                        io_in_request = 0; 
		    }
	            else
	            {
			dprintf( "DBG[%05d]:  subio list fully covered; %d bio match for %ld of %ld sectors, match!\n", __LINE__, subcnt, covered, this->length );
			dprintf( "DBG[%05d]: %ld:%ld set IS_BIO_COMPLETE, both postio and %d subio\n", __LINE__, io->sector, io->length, subcnt );
		        mask = ~(IS_BIO_COVERED);
			io->info->cnt_completed_subio += subcnt;
			io->ioflags |= IS_BIO_COMPLETE;
		    }

                    for (     ; subio != NULL; subio = subio->subio)
			subio->ioflags &= mask;
		}
	    }
            else
            {
                io_in_request = 0;
                continue;
            }
  	}
        if (io != NULL) { found_type = 'C'; break; }

        /* D) search mainio_list for (sub)BIO match only                        */
	io_in_request = 0;
        dprintf( "DBG[%05d]: part 'D'\n", __LINE__ );
        dprintf( "DBG[%05d]: check mainio list for match %10ld:%6ld...{sub-BIO only coveraged}\n", __LINE__, this->sector, this->length );
        end_sector = (this->sector + this->length) - ((this->length > 0 )?1:0);
        for (temp = mainio_list; temp != (typ_io *)NULL; temp = temp->next)
        {
            dprintf( "DBG[%05d]: mainio list  %p %10ld:%6ld...(sub-BIO=%d)\n", __LINE__, temp, temp->sector, temp->length, temp->info->cnt_merges);
            if ((this->sector >= temp->sector) && (end_sector <= ((temp->sector + temp->length)-1)))
	    {
		io_in_request = 1;
	        if ((temp->subio == NULL) && (io_in_request == 1))
                {
		    /* This match means a BIO or whole C event matched this IO already, somehow */
	            /* and now we have a complete/whole request C match too.                    */
		    dprintf( "DBG[%05d] %ld <= %ld:%ld >= %ld\n", __LINE__, temp->sector, this->sector, 
			end_sector, (temp->sector + temp->length)-1 );
                    PROG_FEATURE_FAULT(this,(int),"internal logic fault;", CTL_FAULT_DEFAULT );
	        }
                if ( R_OR_W(temp)                         != rw) continue; /* not the same (broad) type of io */
                if ((temp->evtflags & EVTFLG_VALID_SECTOR) == 0) continue; /* doesn't have valid sector numb  */
                if ((temp->evtflags & EVTFLG_VALID_SIZE  ) == 0) continue; /* doesn't have valid size   numb  */
                if ( temp->minor  != this->minor               ) continue; /* not the same device             */
                if ( temp->major  != this->major               ) continue; /* not even same major device type */
                dprintf( "DBG[%05d]: postio list  %p %10ld:%6ld... passed other filters!\n", __LINE__, temp, temp->sector, temp->length );

	        for (subio = temp->subio; subio != NULL; subio = subio->subio)
                {
                    dprintf( "DBG[%05d]:  subio list  %p %10ld:%6ld...\n", __LINE__, subio, subio->sector, subio->length );
                    if ( temp->sector != this->sector              ) continue;
                    if ( temp->length != this->length              ) continue;
                    dprintf( "DBG[%05d]:  subio list  %p %10ld:%6ld... match!\n", __LINE__, temp, temp->sector, temp->length );
		     io = temp;
		    bio = subio;
		    onpost = 1;
		    if ((bio->ioflags & IS_BIO_COMPLETE) != 0)
		    {
                        PROG_FEATURE_FAULT(this,(int),"internal logic fault; subio already marked completed?!", CTL_FAULT_DEFAULT );
		    }
		    break;
		}
	    }
	    else
	    {
	        io_in_request = 0;
		continue;
	    }
	}
        if (io != NULL) { found_type = 'D'; break; }

	/* SPECIAL CASE 'F': 2.6.32++ & dm- devices								  */
	/* ---------------------------------------------------------------------------------------------- */
	/* And yet another special case ... 2.6.32++'s (3.10.0 too) dm- devices have Q|C only		  */
        /* Add special case for dm- devices... in some cases like in 2.6.32++ dm devices only have two    */
        /* events of Q and C.  So if we didn't find the event on the "active" queue and this is a dm      */
	/* device, then see if we can find a match on the staging queue...                                */
        if (this->major == 253)
        {
            dprintf( "DBG[%05d]: dm device detected.  special check staging queue...'%s'\n", __LINE__, state.inpline );

	    /* What we're going to do is if we find this on the staged queue   */
	    /* then move it to the active queue as "completion" actions expect */
	    /* the io to be there, then continue with io pointing to the found */
	    /* io and let complete do its thing.                               */

            /* Search shorter staged list for this event -- it may not be here */
            /* as it may have already been moved to active list via S/G/M/F    */
	    if ((io = search_staged1(this,eventname,__LINE__)) != NULL)
            {
                q0printf( "DBG[%05d]: looking for @%12.9f:%8lu+%6lu, found %12.9f:%8lu+%6lu on %s staged list (dm- device special)\n", __LINE__,
                    this->timeinfo.time, this->sector, this->length,
                      io->timeinfo.time,   io->sector,   io->length,
		    "staged");
                dprintf( "DBG[%05d]: looking for @%12.9f:%8lu+%6lu, found %12.9f:%8lu+%6lu on %s staged list (dm- device)\n", __LINE__,
                    this->timeinfo.time, this->sector, this->length,
                      io->timeinfo.time,   io->sector,   io->length,
		    "staged");
        
                _assert( (io->ioflags & IS_STAGED) != 0 );
                move_staged_to_mainio(io);                          /* <== inProgress stats updated in there */
				 				    /*     should we also move to postio?    */
	    }
        }
        if (io != NULL) { found_type = 'F'; /* Dangling 'C' event orphan, discard. */ break; }


	/* No matches... yet, is this an IMB completion event			*/
	if (this->imbtyp != 0)
        {
            if ((io = imb_active_find(this)) != NULL)
            {
                q0printf( "DBG[%05d]: looking for @%12.9f:%8lu+%6lu, found %12.9f:%8lu+%6lu on %s list\n", __LINE__,
                        this->timeinfo.time, this->sector, this->length,
                          io->timeinfo.time,   io->sector,   io->length,
                        "imb_active");
                dprintf( "DBG[%05d]: looking for @%12.9f:%8lu+%6lu, found %12.9f:%8lu+%6lu on %s list\n", __LINE__,
                        this->timeinfo.time, this->sector, this->length,
                          io->timeinfo.time,   io->sector,   io->length,
                        "imb_active");

                /* Its possible this is still stuck on the staged queue, if so move */
                /* it to the mainio queue where 'C'ompletion logic expects it to be */
                printf( "DBG[%05d]: %s(staged = %d)\n", __LINE__, __func__, io->ioflags & IS_STAGED );
                if ((io->ioflags & IS_STAGED) != 0)
                {
                    printf( "DBG[%05d]: call move_staged_to_mainio()...\n", __LINE__ );
                    move_staged_to_mainio(io);                          /* <== inProgress stats updated in there */
                                                                        /*     should we also move to postio?    */
                }
                printf( "DBG[%05d]: %s(staged = %d)\n", __LINE__, __func__, io->ioflags & IS_STAGED );
                _assert( (io->ioflags & IS_STAGED) == 0 );
                if ((io->ioflags & IS_POSTIO) == 0) onmain=1;
                else                                onpost=1;
                found_type = 'B';                                       /* likely unset up to this point         */
            }
        }
        if (io != NULL) { found_type = 'I'; /* IMB event matching */ break; }


	/* no matches found! ugh. create a ghost?				*/
	dprintf( "DBG[%05d]: %s(io %p)\n", __LINE__, __func__, io );		  /* There is a warning for this a bit later in the flow */
	io = check_io_found(this,io,eventname,&onmain);				  /* @@@TBD Creating a ghost here is likely bad as imb check belwo can find one! */
	break;
    }

    /* If no match and this event is considered an IMB, then check look-aside list */
    /* We do this after the above nominal *exact match* logic                      */
    if ((io == NULL) && (this->imbtyp != 0))
    {
        if ((io = imb_active_find(this)) != NULL)
        {
            q0printf( "DBG[%05d]: looking for @%12.9f:%8lu+%6lu, found %12.9f:%8lu+%6lu on %s list\n", __LINE__,
                    this->timeinfo.time, this->sector, this->length,
                      io->timeinfo.time,   io->sector,   io->length,
                    "imb_active");
            dprintf( "DBG[%05d]: looking for @%12.9f:%8lu+%6lu, found %12.9f:%8lu+%6lu on %s list\n", __LINE__,
                    this->timeinfo.time, this->sector, this->length,
                      io->timeinfo.time,   io->sector,   io->length,
                    "imb_active");

            /* Its possible this is still stuck on the staged queue, if so move */
            /* it to the mainio queue where 'C'ompletion logic expects it to be */
            printf( "DBG[%05d]: %s(staged = %d)\n", __LINE__, __func__, io->ioflags & IS_STAGED );
            if ((io->ioflags & IS_STAGED) != 0)
            {
                printf( "DBG[%05d]: call move_staged_to_mainio()...\n", __LINE__ );
                move_staged_to_mainio(io);                          /* <== inProgress stats updated in there */
                                                                    /*     should we also move to postio?    */
            }
            printf( "DBG[%05d]: %s(staged = %d)\n", __LINE__, __func__, io->ioflags & IS_STAGED );
            _assert( (io->ioflags & IS_STAGED) == 0 );
            if ((io->ioflags & IS_POSTIO) == 0) onmain=1;
            else                                onpost=1;
            found_type = 'I';                                       /* likely unset up to this point         */
        }
    }


    /* If no match and special is set, give a second special look */
    if ((io == NULL) && (nonio == 1) && ((this->specials & SPCFLG_00) != 0))
	if ((io = search_mainio_special1(this,io,eventname,&onmain)) != NULL)
	    found_type = 'Z';

    if (io != NULL) 
    {

	if ((this->cpu != io->cpu) && (this->cpu < MAXCPUS))
	{
	    samp.cpu_crx[this->cpu]++;
	    summ.cpu_crx[this->cpu]++;
	}
        dbg_add_event_to_io(this,io,__LINE__,NULL);

        dprintf( "DBG[%05d]: looking for @%12.9f:%8lu+%6lu, found %12.9f:%8lu+%6lu on %s list {subio:%p via '%c'}\n", __LINE__, 
	    this->timeinfo.time, this->sector, this->length, 
              io->timeinfo.time,   io->sector,   io->length,
	    onmain==0?(onpost==0?"staged":"postio"):"mainio", bio, found_type );

        /* This is where things can get "weird" in that due to C-Whole+2-NthBIO behavior,	*/
	/* other other non 1:1 D:C enviroments, do we or don't we change infligh/inprogress     */
	/* status now or not? Or only when we output the events?  And does it matter?  In theory*/
        /* we should change the status now as the first C event for an io is *the* completion   */
        /* of the io -- hardware is only going to return 1 completion status -- its the io stack*/
        /* that splits that 1 hardware completion into multiple software based completions.  So */
        /* first completion is *the* completion of the io.  But since we don't output the values*/
        /* until completed io "times out" on postio queue, only changing them at that time makes*/
        /* sense... except do we care that then the counts are off/delayed within the annotated */
        /* output? So, choices choices.  Since first C event is notification from hardware that */
        /* the io completed, lets go ahead and change the inflight/inprogress counts upon first */
	/* C event... and expand the ctracker structure to capture those values to be used at   */
	/* output time.  This allows immediate output like annotate to reflect hardware queue   */
	/* status, but allows the output when it happens to be accurrate as we've grabbed a     */
        /* snapshot of the stat counters needed for output.                                     */

	/* state.inProgress/inFlight updates, if any  */

        /* Now housekeeping, update last event        */
        /* @@@TBD review which fields other lstevt    */
        io->lstcpu =  this->cpu;
        io->lstact =  this->prmact;
        strcpy(io->lsttyp, this->evttyp);
        bcopy(this, &io->lstevt, sizeof(typ_event));

	this->request = io;
        _assert(io->info != NULL);
        if (state.isPlugged == 1) io->info->plug_state |= PLUGSTATE_C;

        /* capture C event info in events                           */
        if (io->info != NULL) actions = &io->info->events;
        else                  actions = &temp_actions;
        line = this->timeinfo.line;
        time = this->timeinfo.time;

        if (actions->complete.line == 0)
        {
             /* this is first complete event for this io */
             actions->complete.line = line;
             actions->complete.time = time;

             /* only grab a ticket @first complete time                       */
             /* Assigning event Q/I/D/C timestamp processing.                 */
             /* CSeqNo will be used to calc iosched reorder @dispatch time    */
             state.CSeqNo++;
             io->info->CSeqNo = state.CSeqNo;

	     /* inProgress counts are updated in remove from mainio routines  */
        }
	else
	    printf( "DBG[%05d]: actions->complete.line = %d already marked complete!\n", __LINE__, actions->complete.line );
        io->event_mask            |= EVTMSK_C; /* @@ */
	set_event_mask( io,       EVTNDX_C );
        actions->complete.line  = line;
        actions->complete.time  = time;
        io->info->cnt_completes++;
        io->info->CSeqNo_Ghost     = state.CSeqNo;    /* this just reflects C ticket in state at last C event for this io, not assigned ticket, it "ghosts" ticket # */
   
        tprintf( "tDBG[%05d]: event %c:%16ld.%8ld assign complete time %13.9f\n", __LINE__, _prmtyp(this->prmtyp), this->sector, this->length, this->timeinfo.time );


        /* Merge event flags, add procname if not previously available,     */
        /* ditto for extras.                                                */
        io->evtflags |= this->evtflags;
	if ((this->procname[0] != 0) && (io->procname[0] == 0))
        {
	    /* should be there unless this is backfill */
            strcpy(io->procname, this->procname);
	}
	if ((this->extras[0] != 0) && (io->extras[0] == 0))
        {
            strcpy(io->extras  , this->extras  );
	}

        if (io->info->events.complete.time < io->info->events.first.time )
        {
            dprintf( "%%E[%05d]: complete io %10ld %6ld F:%12.9f > C:%12.9f (-%12.9f)\n", __LINE__, this->sector, this->length,
                io->info->events.first.time, 
	        io->info->events.complete.time,
                io->info->events.complete.time - io->info->events.first.time );
        }
	else
	{
            dprintf( "%%I[%05d]: complete io %10ld %6ld F:%12.9f < C:%12.9f (+%12.9f)\n", __LINE__, this->sector, this->length,
                io->info->events.first.time, 
	        io->info->events.complete.time,
                io->info->events.first.time - io->info->events.complete.time );
	}

	/* Okay, here is the "normal" point we'd output the completed io to the output file */
	/* But due to the needed postio delays needed to handle various multiple C event    */
        /* environments, we'll check to see if we can just output the event and be done, or */
        /* need to push the io request onto the postio queue for delayed output.  We can do */
	/* direct output of completion only if this event has no merged BIOs -- so we should*/
        /* only ever get the 1 C event... .AND. the postio queue is empty.  If not empty,   */
        /* then we've delayed output of a previous completed event waiting for possible     */
        /* multiple C events against BIOs in this io.                                       */
        /* Corner case checks: treat FWFS and WFS as if they have multiple BIO.             */
	corner_case = 0;
	if ((io->subio == NULL) && ((io->evtflags & EVTFLG_SPECIAL_FWS) == 0) &&
            ((strncmp(io->evttyp,"FWFS",4) == 0) || (strncmp(io->evttyp,"WFS",3) == 0)))
	{
	    /* so this io hasn't been marked before @ C time but its possibly special case */
            corner_case++;
	    printf( "%%W[%05d]-corner case {FWFS*,WFS*} detected, force to postio: '%s'\n", __LINE__, state.inpline );
	    io->ioflags |= IS_EXCEPTION;
	}
	if  (postio_list == NULL) d1printf( "DBG[%05d]: %s() postio_list is empty; corner_case=%d\n", __LINE__, __func__, corner_case );
        if ((postio_list == NULL) && (io->subio == NULL) && (corner_case == 0))
        {
	    /* @@@TBD: could move stat to output_completed_io() so its in one place */
	    /* @@@TBD: or at move to post where inProgress counts are updated       */
            /* @@@TBD: but we don't move to post until the whole request is marked  */
	    /* @@@TBD: complete which may take a couple C events... is that good    */
	    /* @@@TBD: of should we always move to post and wait there for other C  */
	    /* @@@TBD: to catch up via tmo mechanism?                               */
	    /* @@@NOTE: Just because its on postio does not mean it got here via    */
	    /*          a 'D','C' sequence... the inFlight is upped at D event, so  */
	    /*          if no 'D' event, no inFlight count++ so don't count--       */
	        if ((io->evtflags & EVTFLG_GHOST) != 0) q0printf( "DBG[%05d]: %s() is GHOST, stats not updated for ghosts\n", __LINE__, __func__ );
	        if ((io->event_mask & EVTMSK_D)   == 0) q0printf( "DBG[%05d]: %s() has no D event\n", __LINE__, __func__ );
            if (((io->evtflags & EVTFLG_GHOST) == 0) && ((io->event_mask & EVTMSK_D) != 0))
	    {
                /* in ascending order:
                 * read       = IOTYP_READ
                 * write      = IOTYP_WRITE, IOTYP_META, IOTYP_BARRIER
                 * discard    = IOTYP_DISCARD, treat as writes for inflight counter purposes
                 */
                state.inFlight--;		/* it *has* been returned by storage lldd		*//*...and any io 'D'ispatched takes up a lun queue slot */
                if      (io->prmtyp == IOTYP_READ ) --state.inFlight_Read;
                else if (io->prmtyp >= IOTYP_WRITE) --state.inFlight_Write;	/* write, meta, barrier, discard */
	        cnt_printf( "DBG[%05d]: %24s() iocnt (%5d) inFlight--   %5d: %5d,%5d %s\n", __LINE__, __func__, state.inProgress, state.inFlight, state.inFlight_Read, state.inFlight_Write,
			(((state.inFlight_Read < 0.0) || (state.inFlight_Write < 0.0))?" : counter is negative":"") );
                cnt_fprintf( outf, "DBG[%05d]: %c:%08ld.%06ld iocnt (%5d) inFlight--   %5d: %5d,%5d\n", __LINE__, 
		    _prmtyp(this->prmtyp), this->sector, this->length, state.inProgress, state.inFlight, state.inFlight_Read, state.inFlight_Write );
	    }
	    if (state.inFlight > state.inProgress)
	    {
		_EXIT( printf( "DBG[%05d]: %s()\n", __LINE__, __func__ ) );
	    }


	    event_sig_add(io, this);	/* Add matched event signature to io context before moved to done queue */

            samp.cnt_completes++;
            summ.cnt_completes++;

            test_sample_time_boundary(io);			

            output_completed_io(io,"",MAINIO_QUEUE);		/* use state.inProgress, state.inFlight			       */
    
            dbg_lineno = __LINE__;
            annotate_event(this,3,io);				/* we're about to make this io disappear		       */
	    move_mainio_to_done(io);				/* this is bypassing postio queue where some stats are updated */
	    io = NULL;						/* its gone. don't event think about using it again.           */
	}
	else
	{
	    /* defer output until later so possible follow-on C events tgt this request	    */
	    /* create ctracker, add info, set timeouts, move to postio_list                 */
	    /* NOTE: Only update inflight data the first time we transfer mainio to postio  */
	    /*       don't count duplicate completions on the same request after that       */
	    if (io->ctracker != NULL) printf( "DBG[%05d]: ctracker is not null.\n", __LINE__);
	    if (io->ctracker == NULL)
	    {
		/* 1st completion against this request					    */
	        if ((io->evtflags   & EVTFLG_GHOST) != 0) q0printf( "DBG[%05d]: is GHOST\n", __LINE__ );
	        if ((io->event_mask & EVTMSK_D    ) == 0) q0printf( "DBG[%05d]: has no D event\n", __LINE__ );
                if (((io->evtflags  & EVTFLG_GHOST) == 0) && ((io->event_mask & EVTMSK_D) != 0))
		{
            	    /* in ascending order:
             	    * read       = IOTYP_READ
             	    * write      = IOTYP_WRITE, IOTYP_META, IOTYP_BARRIER
             	    * discard    = IOTYP_DISCARD, treat as write for inflight counter purposes
             	    */
                    state.inFlight--;		/* it *has* been returned by storage lldd		*//*...and any io 'D'ispatched takes up a lun queue slot */
                    if      (io->prmtyp == IOTYP_READ ) --state.inFlight_Read;
                    else if (io->prmtyp >= IOTYP_WRITE) --state.inFlight_Write;	/* write, meta, barrier, discard */
	            cnt_printf( "DBG[%05d]: %24s() iocnt (%5d) inFlight--   %5d: %5d,%5d %s\n", __LINE__, __func__, state.inProgress, state.inFlight, state.inFlight_Read, state.inFlight_Write,
			(((state.inFlight_Read < 0.0) || (state.inFlight_Write < 0.0))?" : counter is negative":"") );
                    cnt_fprintf( outf, "DBG[%05d]: %c:%08ld.%06ld iocnt (%5d) inFlight--   %5d: %5d,%5d\n", __LINE__, 
		        _prmtyp(this->prmtyp), this->sector, this->length, state.inProgress, state.inFlight, state.inFlight_Read, state.inFlight_Write );
		}
		if (state.inFlight > state.inProgress)
	        {
		    _EXIT( printf( "DBG[%05d]: %s()\n", __LINE__, __func__ ) );
	        }

                samp.cnt_completes++;
                summ.cnt_completes++;

		bytes = sizeof(typ_ctracker) + (sizeof(typ_cevent)*((io->info->cnt_merges*2)+2));
	        if ((io->ctracker = malloc(bytes)) == NULL)
                {		
                    RUNTIME_FAULT(NULL,(int),"allocation of ctracker failed.", CTL_FAULT_FORCE );
		}
		bzero(io->ctracker, bytes);
		io->ctracker->inProgress       = state.inProgress;
		io->ctracker->inProgress_Read  = state.inProgress_Read;
		io->ctracker->inProgress_Write = state.inProgress_Write;
	        io->ctracker->inFlight         = state.inFlight;
	        io->ctracker->inFlight_Read    = state.inFlight_Read;
	        io->ctracker->inFlight_Write   = state.inFlight_Write;
	        io->ctracker->last_completed_sector = state.last_completed_sector;
                io->ctracker->last_completed_length = state.last_completed_length;
		io->ctracker->last_queue_t          = state.last_queue_t;

                cnt_printf( "DBG[%05d]: %24s() iocnt (%5d) inProgress   %5d: %5d,%5d\n", __LINE__, __func__, state.inFlight, state.inProgress, state.inProgress_Read, state.inProgress_Write );
	        cnt_printf( "DBG[%05d]: %24s() iocnt (%5d) inFlight     %5d: %5d,%5d\n", __LINE__, __func__, state.inProgress, state.inFlight, state.inFlight_Read, state.inFlight_Write );
                cnt_fprintf( outf, "DBG[%05d]: %c:%08ld.%06ld iocnt (%5d) inProgress   %5d: %5d,%5d (ctrack capture)\n", __LINE__, 
		    _prmtyp(io->prmtyp), io->sector, io->length, state.inFlight, state.inProgress, state.inProgress_Read, state.inProgress_Write );
                cnt_fprintf( outf, "DBG[%05d]: %c:%08ld.%06ld iocnt (%5d) inFlight     %5d: %5d,%5d (ctrack capture)\n", __LINE__, 
		    _prmtyp(io->prmtyp), io->sector, io->length, state.inProgress, state.inFlight, state.inFlight_Read, state.inFlight_Write );

		io->ctracker->numb_completions = (io->info->cnt_merges*2)+3;

	    }
	    ndx = io->ctracker->used_completions++;
	    assert( io->ctracker->used_completions < io->ctracker->numb_completions);
	    io->ctracker->completions[ndx].line   = this->timeinfo.line;
	    io->ctracker->completions[ndx].time   = this->timeinfo.time;
	    io->ctracker->completions[ndx].sector = this->sector;
	    io->ctracker->completions[ndx].length = this->length;

	    io->ctracker->last_line               = this->timeinfo.line;
	    io->ctracker->last_time               = this->timeinfo.time;

	    if (ndx == 0)
	    {
	        /* Only set the tmo based upon first event, vs constantly extending for each subsequent C event for this request */
	        if (corner_case == 0)
	        {
		    io->ctracker->tmo_line_value          =                       CTRACKER_TMO_LINE;
		    io->ctracker->tmo_time_value          =                       CTRACKER_TMO_TIME;
	            io->ctracker->tmo_line                = this->timeinfo.line + CTRACKER_TMO_LINE;	/* 50 additional event lines */
	            io->ctracker->tmo_time                = this->timeinfo.time + CTRACKER_TMO_TIME;	/* 100ms		     */
	        }
	        else
		{
		    io->ctracker->tmo_line_value          =                       CTRACKER_FWS_LINE;
		    io->ctracker->tmo_time_value          =                       CTRACKER_FWS_TIME;
	            io->ctracker->tmo_line                = this->timeinfo.line + CTRACKER_FWS_LINE;	/* 10 additional event lines */
	            io->ctracker->tmo_time                = this->timeinfo.time + CTRACKER_FWS_TIME;	/* 10ms		             */
		}
	    }

	    dprintf( "DBG[%05d]: ctracker update case '%c' %ld:%ld ; line -> tmo %d->%d , time -> tmo %11.6f -> %11.6f\n", __LINE__,
                (found_type==0)?'-':found_type,
		io->sector, io->length,
		this->timeinfo.line, io->ctracker->tmo_line,
		this->timeinfo.time, io->ctracker->tmo_time );

            switch (found_type)
            {
		case 'I': /* I) IMB event/match							  */
		case 'B': /* B) search mainio_list for full coverage io only                      */
			  io->ioflags |= IS_WHOLE_COMPLETE;
			  dprintf( "DBG[%05d]: %ld:%ld set IS_WHOLE_COMPLETE\n", __LINE__, io->sector, io->length );
	                  for (subio = io->subio; subio != NULL; subio = subio->subio)
				subio->ioflags |= IS_WHOLE_COMPLETE;
		          move_mainio_to_post(io);  
			  break;
		case 'C': /* C) search postio_list for (sub)BIO match only 			  */
			  dprintf( "DBG[%05d]: %ld:%ld set IS_BIO_COMPLETE\n", __LINE__, io->sector, io->length );
			  /* the following were set in the detection phase */
			  /* as multiple bio could be covered              */
			  /*  io->ioflags |= IS_BIO_COMPLETE;  */
			  /* bio->ioflags |= IS_BIO_COMPLETE;  */
			  /*  io->info->cnt_completed_subio++; */
			  /* if this completes this io, then it will be output, in proper order,  */
			  /* next completiong event.  There can be other events before it still   */
			  /* waiting...                                                           */
			  break;
		case 'D': /* D) search mainio_list for (sub)BIO match only                        */
			  assert( bio != NULL );
			  dprintf( "DBG[%05d]: %ld:%ld set IS_BIO_COMPLETE\n", __LINE__, io->sector, io->length );
			   io->ioflags |= IS_BIO_COMPLETE;
			  bio->ioflags |= IS_BIO_COMPLETE;
			   io->info->cnt_completed_subio++;
		          move_mainio_to_post(io);
			  break;
                case 'E': /* B.0 search postio_list for "special" FWS case, sector match only    */
			  /* nothing to do here as 1st complete did all the heavy lifting        */
			  break;

	        case 'Z': /* SPECIAL CASE.1 "barrier" type io					 */		
			  /* mark the whole zero length io completed (duh)                       */
			  io->ioflags |= IS_WHOLE_COMPLETE;
		          move_mainio_to_post(io);
			  break;

                case 'F': /* F) dm- device (Q,C events only) 					  */
			  /*    if this is {F}FWS{M} corner case, treat it like (B) else fault    */
		          /*    search mainio_list for full coverage io only                      *//* @@@TBD should verify this is case! */
			  if (corner_case == 0)
		          { int tmpcnt=0;
			      /* plain dm- io, this code is same as dm- + corner_case below       */
			      /* done this way in case there is a differentiator detected later   */
			      io->ioflags |= IS_WHOLE_COMPLETE;
			      dprintf( "DBG[%05d]: %ld:%ld set IS_WHOLE_COMPLETE {special {F}WFS{M})\n", __LINE__, io->sector, io->length );
	                      for (subio = io->subio; subio != NULL; subio = subio->subio)
			      {
			          subio->ioflags |= IS_WHOLE_COMPLETE;
				  tmpcnt++;
				  dprintf( "DBG[%05d]: subio[%2d] %ld:%ld\n", __LINE__, tmpcnt, subio->sector, subio->length );
			      }
		              move_mainio_to_post(io);  
			      break;
			  }
			  else
		          { int tmpcnt=0;
			      io->ioflags |= IS_WHOLE_COMPLETE;
			      dprintf( "DBG[%05d]: %ld:%ld set IS_WHOLE_COMPLETE {special {F}WFS{M})\n", __LINE__, io->sector, io->length );
	                      for (subio = io->subio; subio != NULL; subio = subio->subio)
			      {
			          subio->ioflags |= IS_WHOLE_COMPLETE;
				  tmpcnt++;
				  dprintf( "DBG[%05d]: subio[%2d] %ld:%ld\n", __LINE__, tmpcnt, subio->sector, subio->length );
			      }
		              move_mainio_to_post(io);  
			      break;
			  }
		default : sprintf( reason, "internal logic fault, matched type %c:'%d' processing missing!.", (found_type != 0)?found_type:'-', this->prmtyp );
                          MISS_FEATURE_FAULT(this,(int),reason,CTL_FAULT_DEFAULT);
	    }
	}
    }
    else if (nonio == 0)
    {
        /* Nope, not any list we could match... must be orphan  */
	/* check_io_found() would have taken care of orphans    */
	/* but this is completion, so it's been discarded as    */
        /* these is nothing to backfill, but this means we're   */
        /* going to loose any visibility to this event other    */
        /* the events warning of the discard.  Rethink? @@@TBD  */
	/* So.... we're just discarding this event for some reason. Log&ret  */
	NOTARGET_FAULT(this,(int),"orphan 'C' event, discard",CTL_FAULT_DEFAULT );
	logIprintf( "%%I[%05d]-continuing after discard of 'C' event.\n", __LINE__ );

        /* Nope, not on either list. Weird */
        /* new one: this needs to be backfilled, but for now add event to exceptions list and ignore */
        /* @@@TBD - for now treat this as a "notarget fault" rather than programming process fault   */
	/*          although could be "missing feature" in that we didn't dectect this as front of   */
        /*          file orphan case.  Or data processing because the current code is inadequate     I*/
    }

    /* last thing before returning, output annotated event           */
    if (state.flag_annotated == 0)
    {
	event_sig_add(io, this);	/* Add matched event signature to io context */

	/* *may* have done it above as we moved io to done */
        dbg_lineno = __LINE__;
        annotate_event(this,3,io);
    }
    _return(0);
}

/**
 * ==========================================================================================
 * Function : plug_event -- process a P, U or UT event
 * Args     : @this:       current event information
 *            @typ :       1 = plug, 0 = unplug, and -1 is UT event
 * Returns  : isPlugged:   0 = unplugged, 1 = plugged
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * This is a scheduler (non-data movement) io.  A P and U increment/decrement the plug counters
 * by 1, but a UT event will drop the difference between plug/unplug to just 1.  
 * Set/track isPlugged stateful information.
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * UT events in a lot of datasets are followed by U event shortly thereafter.  So the code had
 * been taking a N plug count and reducing it to 1 with expecations that the follow on U event
 * would take it to zero.  But a new dataset only has UT events (no P, no U, just UT).  Need 
 * a flexible model that handles these type of cases and does not assert() out.  There is no
 * pressing reason to assert()/coredump out if the program model doesn't match what is happening
 * in the dataset.
 *
 * The real issue here is if we get P,P,U,U,U ... that last U should not push the unplug
 * count to be greater than the Plug count.  At least I haven't see a dataset where a 
 * pre-emptive unplug was used to mask a following plug.
 **/
int plug_event(typ_event *this, int typ )
{
static double last_UT_time = -1.0;
static int    last_UT_line = -1;
char msg[256];
char info[256];
int near_top = 0;
int allow    = 0;
int save_plug = state.isPlugged;

    TRACE_FUNCTION;
    if (typ == -1)
    {
        last_UT_time = this->timeinfo.time;
	last_UT_line = this->timeinfo.line;
    }
    this->request = REQ_NOCONTEXT;

    if ((state.line < MAX_TOP_OF_FILE_LINES) || (state.QSeqNo < MAX_TOP_OF_FILE_QEVENTS)) near_top = 1;

    if (typ == 1)
    {
	/* 'P'lug event, could be first, could be nth */
	/* nested, don't care, just count them up     */
	/* well... we care if a bunch of U events are */
	/* processed before first P event.  At 1st P  */
	/* set P count to unplug count + 1 ... just a */
	/* guess on our part. This will undo any prior*/
	/* orphan Us and force into isPlugged state   */

	/* Currently in unplugged state, which means  */
        /* PlugCount <= Unplug count                  */
	if (state.PlugCount > 0)
            state.PlugCount++;
	else
	    state.PlugCount = state.UnplugCount+1;

	/* isPlugged will either be zero (unplugged)  */
	/* or some positive value due to P,P,... nest */
        if ((state.isPlugged = (state.PlugCount - state.UnplugCount )) < 0) state.isPlugged = 0;

	event_sig_add(NULL, this);	/* Add matched event signature to io context */

        dbg_lineno = __LINE__;
        annotate_event(this,1,NULL);
        _return(state.isPlugged);
    }

    if ((typ == 0))
    {
	/* 'U'nplug event, could be first, could be  */
	/* nth - don't care?                         */
        state.UnplugCount++;

	/* While counting up P,P,P... events above is*/
        /* just fine, treating unplug events are a   */
	/* bit more tricky.  For now just count 'em  */
	/* but eventually will need a conf_ policy   */
	/* on how to treat U and UT events.  E.g.    */
	/* first U event bump unplug count to be same*/
	/* as plug account -- aka this is just a flg */
	/* and not an actual counter as this could be*/
	/* case in some kernel implementations...    */
        if ((state.isPlugged = (state.PlugCount - state.UnplugCount )) < 0) 
	{
	    state.isPlugged = 0;
            msg[0] = 0;
	    info[0]= 0;
            allow  = 0;
	    /* Okay, special case time.  Was the last UT event a short while ago? */
	    if ((last_UT_line >= 0) && (this->timeinfo.line < (last_UT_line+5)))
	    {
		/* Special UT,U case where UT takes the count to 1 and next U to zero */
		/* but since we cannot tell at UT time if that will be the case, UT   */
		/* takes it to zero unless the conf_UT_policy is set to do otherwise  */
		/* So... this is no harm, no foul.  This U is just mate to recent UT. */
		/* Don't alert on this, but do roll-back the UnplugCount as we bumped */
		/* UnplugCount at the recent UT event which covers this one           */
		state.UnplugCount--;
		if (((state.PlugCount - state.UnplugCount) < 0) && (state.PlugCount > 0))
	        {
		    /* now complain. reset count. */
		    state.alerts |= ALERTFLG_NEG1_U;
		    state.alert_cnt_neg1_u++;
		    sprintf( msg, " %%W[%05d]-'U'nplug  event near UT bad cnt : @%d line (%d|%lu:%lu) @%s %s\n", __LINE__, 
			state.line,
			save_plug, state.PlugCount, state.UnplugCount, state.inpline, (near_top==0)?"":"[near bgn of input file]" );
		    if (state.alert_cnt_neg1_u <= MAX_ALLOWED_UNPLUG_MSG) allow = 1;
		    if (state.alert_cnt_neg1_u == MAX_ALLOWED_UNPLUG_MSG)
			sprintf( info, "%%I[%05d]-Disable further individual reports of 'U'nplug|'P'lug protocol warnings.\n", __LINE__ );
		}
		else if (state.PlugCount == 0)
		{
		    sprintf( msg, " %%I[%05d]-'U'nplug  event near UT  ok cnt : @%d line (%d|%lu:%lu) @%s %s\n", __LINE__,
			state.line,
			save_plug, state.PlugCount, state.UnplugCount, state.inpline, (near_top==0)?"":"[near bgn of input file]" );
                    allow = 1;
		}
	    }
	    else
	    {
	        if (state.PlugCount == 0) 
                {
	            state.alerts |= ALERTFLG_ZERO_U;
	            state.alert_cnt_zero_u++;
		    sprintf( msg, " %%I[%05d]-'U'nplug  event when #Plugs=0   : @%d line (%d|%lu:%lu) @%s %s\n", __LINE__, 
			state.line,
			save_plug, state.PlugCount, state.UnplugCount, state.inpline, (near_top==0)?"":"[near bgn of input file]" );
		    if (state.alert_cnt_zero_u <= MAX_ALLOWED_UNPLUG_MSG) allow = 1;
		    if (state.alert_cnt_zero_u == MAX_ALLOWED_UNPLUG_MSG)
			sprintf( info, " %%I[%05d]-Disable further individual reports of 'U'nplug|'P'lug protocol warnings.\n", __LINE__ );
	        }
	        else
	        {
		    state.alerts |= ALERTFLG_NEG_U;
		    state.alert_cnt_neg_u++;
		    sprintf( msg, " %%I[%05d]-'U'nplug  event when not plugged: @%d line (%d|%lu:%lu) @%s %s\n", __LINE__,
			state.line,
			save_plug, state.PlugCount, state.UnplugCount, state.inpline, (near_top==0)?"":"[near bgn of input file]" );
		    if (state.alert_cnt_neg_u <= MAX_ALLOWED_UNPLUG_MSG) allow = 1;
		    if (state.alert_cnt_neg_u == MAX_ALLOWED_UNPLUG_MSG)
			sprintf( info, " %%I[%05d]-Disable further individual reports of 'U'nplug|'P'lug protocol warnings.\n", __LINE__ );
	        }
	    }
	    if (msg[0] != 0)
	    {
		if (allow != 0) 
	            fputs( msg, outf );
		if (conf_no_annotation == 0)
		    fprintf( addf, "DBG[%05d]\n", __LINE__ );
	        fputs( msg, addf );
	    }
            if (info[0] != 0)
            {
		if (conf_no_annotation == 0)
		    fprintf( addf, "DBG[%05d]\n", __LINE__ );
	        fputs( info, outf );
	    }
        }
	event_sig_add(NULL, this);	/* Add matched event signature to io context */

        dbg_lineno = __LINE__;
        annotate_event(this,1,NULL);
        _return(state.isPlugged);
    }


    if (typ == -1)
    {
	msg[0] = 0;
	/* 'U'nplug due to plug timeout event, 		*/
	/* If plug count non-zero, then set unplug count*/
	/* to same as plug count, otherwise just count  */
	/* as in some datasets we're only going to see  */
	/* U and UTs.  Need to flag this behavior       */
	if (state.PlugCount > 0)
	{
	    sprintf( msg, " %%I[%05d]-'U'nplug/timeout event, bump Unplug %lu->%lu: @%d line (%d|%lu:%lu) @%s %s\n", __LINE__,
			state.UnplugCount, state.PlugCount,
			state.line,
			save_plug, state.PlugCount, state.UnplugCount, state.inpline, (near_top==0)?"":"[near bgn of input file]" );
	    state.UnplugCount = state.PlugCount;
	}
	else
	{
	    /* This can happen in files with only U,UT  */
	    sprintf( msg, " %%I[%05d]-'U'nplug/timeout event, no Plug events present %lu->%lu: @%d line (%d|%lu:%lu) @%s %s\n", __LINE__,
			state.UnplugCount, state.UnplugCount+1,
			state.line,
			save_plug, state.PlugCount, state.UnplugCount, state.inpline, (near_top==0)?"":"[near bgn of input file]" );
	    state.alerts |= ALERTFLG_ZERO_UT;
	    state.alert_cnt_zero_ut++;
	    state.UnplugCount++;
        }
	if (flag_unplugs == 0)
	    fputs( msg, stdout );
        if (conf_no_annotation == 0)
	    fputs( msg, addf   );

	state.isPlugged = 0;

	event_sig_add(NULL, this);	/* Add matched event signature to io context */

        dbg_lineno = __LINE__;
        annotate_event(this,1,NULL);
        _return(state.isPlugged);
    }

}

/**
 * ==========================================================================================
 * Function : split_event
 * Args     : @this:       current event information
 * Returns  : 0
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Find the staging io this belongs to -or- create a new typ_io and place it on the staging
 * queue.  Transfer information from event to typ_io.
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * A split event includes two sectors, the starting sector of a previous io, and a new sector
 * at which that io is to be split into two.  So finding a match requires two stages, match
 * the io type/starting sector and then verify that the new io starting sector of the split
 * is covered by the found io.
 **/
int split_event(typ_event *this)
{
static int garbage_collect=0;

typ_event *clone, *dbg_event;
typ_io *io, *split;
typ_io *staged, *next;
typ_actions *actions;
typ_ioinfo *info;
int rw;
int lstndx;
int onmain= 0;
int nonio = 0;
int valid = 0;
int count;
unsigned long bgn_sector;
unsigned long end_sector;
unsigned long xxx_sector;       /* match on request with this as starting sector */
unsigned long tgt_sector;
unsigned long evt_length;
unsigned long new_length;
unsigned long new_sector;
static char eventname[16]="xsplit    ";

    TRACE_FUNCTION;
    io = NULL;
    if ((rw = R_OR_W(this))                    >= 0) valid++;
    if ((this->evtflags & EVTFLG_VALID_SECTOR) != 0) valid++;		/* Has 1st io starting sector */
    if ((this->evtflags & EVTFLG_VALID_SIZE  ) != 0) valid++;		/* Has 2nd io starting sector */

    /* There are two types of X Split events						  */
    /* 1.  253,470 122    14377    17.252122378 1343941  X   W    307342496 / 307342592 [kworker/u291:3]  << size of difference between these to numbers.	*/
    /* 2.    8,96    6     3241    22.305786048 1621409  X   W 201980276200 / 116813800 [kworker/u18:2]   << size is unknown until 'G' event, diff ref bases	*/
    d1printf( "DBG[%05d]: split_event(this:%ld:%6ld,split:%ld)\n", __LINE__, this->sector, (this->length - this->sector)+1, this->length );
    bgn_sector = this->sector;
    end_sector = this->length-1;	/* 'length' is first sector of 2nd/split io 	  */
    xxx_sector = end_sector + 1;	/*  start   of new split io                       */
    evt_length = this->length - this->sector;
    if (valid == 3)
    {
        /* Ok, first find the io associated with this event on the staging queue  */
        /* There should have been a Q event prior to this X event -- need that Q  */
        /* data structure to split into two back onto staging queue               */
        io = search_staged2(this,eventname,__LINE__);
	if (io != NULL)
	d1printf( "DBG[%05d]: found event for X Split [%6d] %ld => %ld : %ld\n", __LINE__, state.line, this->sector, io->sector, io->length );
	else
	d1printf( "DBG[%05d]: found event for X Split [%6d] %ld => <nil>\n", __LINE__, state.line, this->sector );
    }
    else
    {
        dprintf( "DBG[%05d]: io filtered off, will not search stage queue for io\n", __LINE__ );
        /* will never be able to match this to a staging io so just build new io */
        /* Need to create and backfill a mainio ... or just move to exceptions   */
        /* and forget about it.                                                  */
        nonio = 1;
    }

    /* Did we find an io on the staging queue? */
    /* if ((io = check_io_found(this,io,eventname,&onmain)) != NULL) */
    if (io != NULL)
    {
        /* Now housekeeping, update last event        */
        /* Fold basic info of this event into context */
        /* @@@TBD review which fields other lstevt    */
        io->lstcpu =  this->cpu;
        io->lstact =  this->prmact;
        strcpy(io->lsttyp, this->evttyp);
        bcopy(this, &io->lstevt, sizeof(typ_event));

	assert(io->info != NULL );
        io->EVENTS.split.line = this->timeinfo.line;
        io->EVENTS.split.time = this->timeinfo.time;
        io->event_mask |= EVTMSK_X; /* @@ */
	set_event_mask( io, EVTNDX_X );
	
	/* OK, the existing io is all updated... */
	/* or is it...                           */
	if (this->sector != io->sector)
	{
	    /* Split sector != io starting sector, splitting off tail of io    */
	    /* Case 1: io are pealed off from the end of the "parent"          */
	    /*         the "parent" will start as "Q/A" and then be last split */
	    /*         as each split can become split                          */

	    /* A. change the original io length to remove this split from end  */

	    new_length = io->length - evt_length;
	    printf( "DBG[%05d]: found X split %ld/%ld target found: %ld,%ld\n", __LINE__,
		    this->sector, this->length, io->sector, io->length );
	    printf( "DBG[%05d]: existing io   %ld,%ld %p\n", __LINE__, io->sector, io->length, io );
	    printf( "DBG[%05d]: adjusted io   %ld,%ld %p\n", __LINE__, io->sector, evt_length, io );
    
	    split = create_io(this);
	    info  = split->info;		/* Save this we're about to overwrite */
	    bcopy(io, split,sizeof(typ_io));
	    split->info = info;		/* Restore pointer                    */
	    bcopy(io->info, split->info, sizeof(typ_ioinfo));
	    dprintf( "DBG[%05d]: io->info %p  split->info %p\n", __LINE__, io->info, split->info );
	    dprintf( "DBG[%05d]: split    io   %ld,%ld %p\n", __LINE__, this->length, new_length, split);
	    dprintf( "DBG[%05d]: io %p GSeqNo %ld (split)\n", __LINE__, split, split->info->GSeqNo );
    
            /* Adjust sector,length on the two io 		  */
	    split->next = NULL;
	    assert(io->sector == this->sector);
	    split->sector = this->length;
	    io->length    = evt_length;
	    split->length = new_length;
    
	    /* Last, set special SPCFLG_XPARENT in main/1st io */
	    state.XSeqNo++;
	    io->specials       |= SPCFLG_XPARENT;
	    io->info->XSeqNo    = state.XSeqNo;
	    split->specials    |= SPCFLG_XTARGET;
	    split->xsplit_level = io->xsplit_level+1;
            split->info->XSeqNo = state.XSeqNo;
	    split->xparent      = io;			/* @@@TBD, this is dangerous if the main io is somehow completed and freed *//*debug use only! */
    
	    printf( "DBG[%05d]: orig.1   io   %ld,%ld %p\n", __LINE__, io->sector, io->length, io );
	    printf( "DBG[%05d]: split    io   %ld,%ld %p\n", __LINE__, split->sector, split->length, split );
    
	    #       ifdef DEBUG
            /* Clone events between io -> split */
            /* need separate lists              */
            split->info->dbg_num_events = 0;
            split->info->dbg_events     = NULL;
            split->info->dbg_last_event = NULL;
            dbg_event = io->info->dbg_events;
            while (dbg_event != NULL)
            {
                clone = clone_event(dbg_event);
    
                if ((split->info->dbg_num_events++) == 0)
                    split->info->dbg_events = split->info->dbg_last_event = clone;
                else
                {
                    split->info->dbg_last_event->next = clone;
                    split->info->dbg_last_event       = clone;
                }
    
                dbg_event = dbg_event->next;
            }
#           endif
	}
	else
	{
	    /* Split sector == io starting sector, splitting off front of io      */
	    /* Case 2: splits from pealed off from top of parent (A/Q original io */

	    /* A. io: update the io length to reflect the removal of this split   */
	    /* B. io: update the io sector to reflect the removal of this split   */
            bgn_sector = this->sector;
	    end_sector = this->length-1;
	    if (((evt_length = (end_sector - bgn_sector)+1) < 0) || (evt_length > MAX_IO_SIZE))
	    {
	        d1printf( "DBG[%05d]: 1st io size %ld is < 0 or > %d (MAX_IO_SIZE)\n", __LINE__, evt_length, MAX_IO_SIZE );
		if (evt_length < 0)
		fprintf( outf, "%%E[%05d]-split io size %ld < MIN_IO_SIZE (%d), default to %d.\n", __LINE__, evt_length, conf_default_xsplit_size);
		else
		fprintf( outf, "%%E[%05d]-split io size %ld > MAX_IO_SIZE (%d), default to %d.\n", __LINE__, evt_length, MAX_IO_SIZE, conf_default_xsplit_size);
	        /* The base refrence for the two sectors is not 'disk absolute' */
		if (io->split_address == 0)
		{
		    /* first split -- assume conf_default_xsplit_size until shown wrong 	      */
            	    /* split impossible to size until follow on 'G' events, but 2nd split use this    */
		    evt_length = conf_default_xsplit_size;
		    d1printf( "DBG[%05d]: split_event() default 1st split to %d\n", __LINE__, conf_default_xsplit_size );
		    d1printf( "DBG[%05d]: split_event() change split sector %ld -> %ld\n", __LINE__, this->length, (this->sector + evt_length));
		    this->length = this->sector + evt_length;
		    end_sector   = this->length - 1;
		    io->split_address = this->length;
		    d1printf( "DBG[%05d]: split_event() split_address set to %p.%ld\n", __LINE__, io, io->split_address );
		}
		else
		{
		    /* We know the calculated length from xsplit event this->length is bogus, so lets go through same above */
		    evt_length = conf_default_xsplit_size;
		    this->length = this->sector + evt_length;
		    end_sector   = this->length - 1;
		    d1printf( "DBG[%05d]: split_event() split_address     is %p.%ld\n", __LINE__, io, io->split_address );
		    evt_length = this->length - io->split_address;
		    d1printf( "DBG[%05d]: split_event() calculated split length '%ld' from %ld->%ld\n", __LINE__,
				    evt_length, io->split_address, this->length );
		    io->split_address = this->length;
		}
		if (io->orig_length == 0)
		{
		    /* Capture the original info before its changed */
		    io->orig_sector = io->sector;
		    io->orig_length = io->length;
		}
	    }

            new_length = io->length - evt_length;
	    new_sector = io->sector + evt_length;
            d1printf( "DBG[%05d]: found X split %ld/%ld found target: %ld,%ld\n", __LINE__,
                    this->sector, this->length, io->sector, io->length );
            d1printf( "DBG[%05d]: existing io   %ld,%ld %p -> %ld\n", __LINE__, io->sector, io->length, io, evt_length );
            d1printf( "DBG[%05d]:   +split io   %ld,%ld %p\n", __LINE__, new_sector, new_length, io );

	    /* Clone the io to split */
            split = create_io(this);
            info  = split->info;                /* Save this we're about to overwrite */
            bcopy(io, split,sizeof(typ_io));
            split->info = info;         /* Restore pointer                    */
            bcopy(io->info, split->info, sizeof(typ_ioinfo));
            dprintf( "DBG[%05d]: io->info %p  split->info %p\n", __LINE__, io->info, split->info );
            dprintf( "DBG[%05d]: split    io   %ld,%ld %p\n", __LINE__, this->length, new_length, split);
            dprintf( "DBG[%05d]: io %p GSeqNo %ld (split)\n", __LINE__, split, split->info->GSeqNo );

            /* Adjust sector,length on the two io                 */
            split->next = NULL;
            assert(io->sector == this->sector);
            split->sector = this->sector;
            split->length = evt_length;
            io->length    = new_length;
	    io->sector    = new_sector;

            /* Last, set special SPCFLG_XPARENT2 in main/1st io */
            state.XSeqNo++;
            io->specials       |= (SPCFLG_XPARENT | SPCFLG_XPARENT2);
            io->info->XSeqNo    = state.XSeqNo;
            split->specials    |= SPCFLG_XTARGET;
            split->xsplit_level = io->xsplit_level+1;
            split->info->XSeqNo = state.XSeqNo;
            split->xparent      = io;                   /* @@@TBD, this is dangerous if the main io is somehow completed and freed *//*debug use only! */

            d1printf( "DBG[%05d]: orig.2   io   %ld,%ld %p.%ld\n", __LINE__, io->sector, io->length, io, io->split_address );
            d1printf( "DBG[%05d]: split    io   %ld,%ld %p.%ld\n", __LINE__, split->sector, split->length, split, split->split_address );
	}


        /* Sanity checks                                */
        assert(split->subio    == NULL);
        assert(split->lstsubio == NULL);
        assert(split->parent   == NULL);
        assert(split->ctracker == NULL);

        assert(split->info->orphan == NULL);
        assert(split->info->bucket == NULL);
        assert(split->info->this   == NULL);
        assert(split->info->completed_subio == NULL);

        /* Insert split after matched 'io' on staged list */
        split->next = io->next;
        io->next    = split;
        staged_on_list++;
        if (state.last_staged_io == io) state.last_staged_io = split;

        /* Assign the split io to this request vs io as   */
        /* this event created the split vs io             */
        this->request = split;


	/* 4.18'ism - X-split parent io never seem to get a C event  */
	/* and they end up cluttering the staged list, move them to  */
	/* deadio list                                               */
	d1printf( "DBG[%05d]: major:%3d QSeqNo:%5d XSeqNo:%5d GSeqNo:%5d ISegNo:%5d DSegNo:%5d CSeqNo:%5d\n", __LINE__,
			io->major, state.QSeqNo, state.XSeqNo, state.GSeqNo, state.ISeqNo, state.DSeqNo, state.CSeqNo );
	if (conf_xsplits != CFG_XSPLITS_PRESENT)
	{
	    if ((io->major == 253) && (state.QSeqNo > 1000) && (state.CSeqNo > 1000) && (state.ISeqNo == 0) && (state.DSeqNo == 0)) 
	    {
	        /* Hmmm it seems we're working with an LV device */
	        if (garbage_collect == 0)
	        {
		    printf( "%%E[%05d]- one time garbage collection, move potentially 'dead' XPARENTS to deadio\n", __LINE__ );
	            /* Do a one time garbage collect of XPARENTs from staged -> deadio */
		    garbage_collect++;
		    count  = 0;
		    staged = staged_list;
		    while (staged != NULL)
		    {
		        next = staged->next;
		        if ((staged->major == 253) && ((staged->specials & SPCFLG_XPARENT) != 0) && (staged != io))
		        {
		            move_staged_to_dead(staged);
			    count++;
		        }
		        staged = next;
		    }
		    printf( "DBG[%05d]: moved %d staged io to deadio\n", __LINE__, count );
                }
	        /* Now move the io which just had XPARENT set */
	        printf( "DBG[%05d]: move new XPARENT after split to deadio list\n", __LINE__ );
	        move_staged_to_dead(io);
	    }
	}
	    

	event_sig_add(io, this);	/* Add matched event signature to io context */

        dbg_lineno = __LINE__;
        annotate_event(this,3,io);  
        _return(0);

        MISS_FEATURE_FAULT(this,(int),"split event processing not yet implemented",CTL_FAULT_DEFAULT);
	return(0);
	/* @@@TBD CLONE IO -> new
	 *        1) change old io length 
	 *        2) set    new io sector, length
	 *        3) insert new just after io on stage queue

        io->EVENTS.merge.line = this->timeinfo.line;
        io->EVENTS.merge.time = this->timeinfo.line;
        io->event_mask |= EVTMSK_X; /- @@ -/
	 */
    }
    /* ===== NO MATCH So we get here, correct? =====							*/
    staged = io;
    assert(staged == NULL );
    /*
     * Ok, if the original staged io for this X split doesn't exist, and it is early within the
     * input file - ignore the event, we can't split off this event from the parent as the 
     * parent must have started before blktrace capture started.
     */
    if (staged == NULL)
    {
        if ((state.line < MAX_TOP_OF_FILE_LINES) || (state.QSeqNo < MAX_TOP_OF_FILE_QEVENTS))
        {
	    /* Early in input file: Determined that we're at the front of the file where orphan events can occur */
            printf( "%%W[%05d]-could not find 'staged' io request to %s %16lu:%8d into @%s, line=%d (limit=%d), Qevents=%d (limit=%d) [near bgn file|event]\n", __LINE__, eventname,
                this->sector, this->length, state.inpline, state.line, MAX_TOP_OF_FILE_LINES, state.QSeqNo, MAX_TOP_OF_FILE_QEVENTS );
            dbg_lineno = __LINE__;
            /* This should qualify for a discard, but should try and do better -- but hammer time! aka discard */
            this->evtflags |= (EVTFLG_DISCARDED | EVTFLG_EXCEPTION); /* too early in input file, cannot find prior event to split */
            annotate_event(this,1,NULL);  /* skipping this one as likely just missing parts of io we want to split off from */
        }
        else
        {
	    /* Not at the beginning of file so flag and %Error rather than assert failure and stopping processing */
	    /* This *shouldn't** happen, but if start of input file settings used above arent generouse enough... */
            printf( "%%E[%05d]-could not find 'staged' io request to %s %16lu:%8d into @%s, discarding; line=%d (limit=%d), QEvents=%d (limit=%d)\n", __LINE__, eventname,
                this->sector, this->length, state.inpline, state.line, MAX_TOP_OF_FILE_LINES, state.QSeqNo, MAX_TOP_OF_FILE_QEVENTS );
            if (conf_orphan_event_policy == 0)
            {
                /* do not allow orphans at all                        */
                printf( "%%F[%05d]-tbd, missing feature, orphans not allowed via conf_orphan_event_policy=%d.\n", __LINE__, conf_orphan_event_policy );
                MISS_FEATURE_FAULT(this,(int),"split event orphan, orphans not allowed via conf_orphan_event_policy", CTL_FAULT_DEFAULT);
            }
            if (conf_orphan_event_policy == 1)
            {
                /* This is the default policy set at program level in absense of value in .conf file */
		output_key_header();
                fprintf( outf, " %%E[%05d]-orphan %s event detected, discarding '%s'; line=%d (limit=%d), QEvents=%d (limit=%d)\n", __LINE__, eventname,
                   state.inpline, state.line, MAX_TOP_OF_FILE_LINES, state.QSeqNo, MAX_TOP_OF_FILE_QEVENTS );
            }
            /* conf_orphan_event_policy > 1 ; silent */
	    /* @@@TBD just hammer this event and discard for now */
            this->evtflags |= (EVTFLG_DISCARDED | EVTFLG_EXCEPTION); /* too early in input file, cannot find prior event to split */
            annotate_event(this,1,NULL);  /* skipping this one as likely just missing parts of io we want to split off from */
        }

#       ifdef NOT_YET
        /* Ok, policy is to allow ghost creation, if possible              */
        /* create ghost request on appropriate queue and return io address */
        /* With some events, like C, a ghost will not be created and we're */
        /* returning a null request.                                       */
        io = ghost_create(this,GHOST_1STHAND,onmain);
        exceptionevent(this,__LINE__, (io!=NULL)?"detected as orphan event, forced  ghost request creation":
                                                 "detected as orphan event, skipped ghost request creation" );
    
        MISS_FEATURE_FAULT(this,(int),"split event processing not yet implemented",CTL_FAULT_DEFAULT);
#       endif
    }
    return(0);


    event_sig_add(io, this);	/* Add matched event signature to io context */

    dbg_lineno = __LINE__;
    annotate_event(this,3,io);  
    _return(0);
}


/**
 * ==========================================================================================
 * Function : bounce_event
 * Args     : @this:       current event information
 * Returns  : 0
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Find the staging io this belongs to -or- create a new typ_io and place it on the staging
 * queue.  Transfer information from event to typ_io.
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Really should *not* find a matching io present unless there are 
 **/
int bounce_event(typ_event *this)
{
    MISS_FEATURE_FAULT(this,(int),"bounce event routine not yet implemented",CTL_FAULT_DEFAULT);
}

/**
 * ==========================================================================================
 * Function : message_event
 * Args     : @this:       current event information
 * Returns  : 0
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * This is a noop event, just adds a message record to blkparse output here in the blkparse_fmt.c
 * code:
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int message_event(typ_event *this)
{
    this->request = REQ_MESSAGE;
    if (this->prmact != 'm'        ) { _EXIT( printf( "%%F[%05d]-expected message primary action of 'm' found '%c'. Exit.\n",  __LINE__, this->prmact ) ); }
    if (this->prmtyp != IOTYP_NONE ) { _EXIT( printf( "%%F[%05d]-expected message primary type   of '%d' found '%d'. Exit.\n", __LINE__, IOTYP_NONE, this->prmtyp ) ); }
    summ.cnt_messages++;

    return(0);
}

/**
 * ==========================================================================================
 * Function : nomoveio_event
 * Args     : @this:       current event information
 * Returns  : 0
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Find the staging io this belongs to -or- create a new typ_io and place it on the staging
 * queue.  Transfer information from event to typ_io.
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Really should *not* find a matching io present unless there are 
 **/
int nomoveio_event(typ_event *this)
{
    return(0);
}


/**
 * ==========================================================================================
 * Function : flush_annotate --  flush out last read in blkparse input line
 * Args     : @<none>
 * Returns  : 0
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Flush out the last input line, but w/o any state information add ons present.  
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int flush_annotate()
{
    /* output annotated line if we've accumulated an event */
    /* and haven't flushed out the annotated line          */
    if (state.flag_annotated == 0)
    {
        dbg_lineno = __LINE__;
        if (state.lstline[0] != '#') /* addf has its own header (above), don't output from input file */
	    annotate_event(NULL,4,NULL);
    }
    return(0);
}



/**
 * ==========================================================================================
 * Function : annotate_event --  flush out last read in blkparse input line along with state
 * Args     : @event         : current parsed event informatoin
 *            @mask          : 0x1 set, output event from input file
 *                             0x2 set, output annotation regarding the event (skip if event 
 *                                      wasn't processed for example)
 *            @io            : mainio that the event is associated with, maybe null (none)
 * Returns  : 0
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Flush out the last input line, with stateful sequence numbers associated with the io that
 * this event is part of.  If no io is provided (looking at you P,U,UT!), then sequence
 * numbers of the state structure are used instead.
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *  The io pointer shouldn't be null, but *might* be for KWIOBARRIER and other special cases
 *  where a match could not be found.  If so, DBG flag, but skip otherwise.
 **/
int annotate_event( typ_event *event, int mask, typ_io *io)
{
char buffer[MAXBUF];
char bias1 [MAXBUF];
char bias2 [MAXBUF];
char odd;
int  pad;
unsigned long QSeqNo, QSeqNo_Ghost, DSeqNo, CSeqNo;

    /* NOTE: event can be null, do not access event */
    /*       pointer until **AFTER** mask 0x4 case  */

    /* Check for "special" skipped event case	*/
    if (mask == 0x4)
    {
        /* this line was *not* processed, it was skipped so output with precursor */
        /* char in column 1 to denote this event was skipped/not-processed.       */
        pad = (96-strlen(state.lstline))>1?(96-strlen(state.lstline)):0;
	if (conf_no_annotation == 0)
            fprintf( addf, "%05d >%s %*.*s ;\n", __LINE__, state.lstline, pad,pad," " );
        _return(0);
    }

    if (event->prmact == 'm') _return(0);		/* skip annotation of 'm'essage events */

    pad = (93-strlen(state.lstline))>1?(93-strlen(state.lstline)):0;

    /* check to see if this io was attached to a io context or not  */
    /* if not, then event was discarded!                            */
    if ((event->request == NULL) && (state.flag_annotated == 0))
    {
	dprintf( "DBG[%05d]: annotate_event() - event discarded, no assigned request context\n", __LINE__ );
	if (conf_no_annotation == 0)
	    fprintf( addf, "%%W[%05d]-the following event at [%7d] %13.f %c %5s %10ld%s:%6ld%s has been discarded.\n", __LINE__,
	        event->timeinfo.line, event->timeinfo.time, event->prmact, event->evttyp, 
	        event->sector, (((event->evtflags & EVTFLG_VALID_SECTOR)==0)?"  ":".!"),
	        event->length, (((event->evtflags & EVTFLG_VALID_LENGTH)==0)?"  ":".!") );
        if (conf_exceptions_inhibit == 0)
	    fprintf( excf, "%%W[%05d]-the following event at [%7d] %13.f %c %5s %10ld%s:%6ld%s has been discarded.\n", __LINE__,
	        event->timeinfo.line, event->timeinfo.time, event->prmact, event->evttyp, 
	        event->sector, (((event->evtflags & EVTFLG_VALID_SECTOR)==0)?"  ":".!"),
	        event->length, (((event->evtflags & EVTFLG_VALID_LENGTH)==0)?"  ":".!") );
	/* annotation, no we're not going to add to discard, but we expect DISCARD flag to be set */
	if ((event->evtflags & EVTFLG_DISCARDED) == 0)
	{
	    /* huh? */
	    printf( "DBG[%05d]: annotate_event() - event->io block <nil>, but event flag DISCARDED not set?\n", __LINE__ );
	    state.events_discarded++;
	    if (event->prmact != 'C') state.events_discarded_nonC++;
	}
    }
    else
    {
	dprintf( "DBG[%05d]: event used. not discarded.\n", __LINE__);
    }


    /* Need to find the mainio that this event is tied to, if any   */
    /* As sequence numbers are only tracked/added/applied to mainio */
    if ((io == NULL) || (io->info == NULL))
    {
        /* Use info from state (master ticket numbers		    */
	/* This is expected for Unplug/Plug, others?                */
	if ((event->prmact != 'U') && (event->prmact != 'P'))
	    if (conf_no_annotation == 0)
	        fprintf( addf, "use state.xSeqNo\n");
        QSeqNo       = state.QSeqNo;
        QSeqNo_Ghost = state.QSeqNo;	/* there is no relative "Ghost" on the state, that only applies to real io */
        DSeqNo       = state.DSeqNo;
        CSeqNo       = state.CSeqNo;
    }
    else
    {
	/* fprintf( addf, "use io->info->.xSeqNo\n"); */ /* nominal/expected case, reduce clutter */
        QSeqNo       = io->info->QSeqNo;
        QSeqNo_Ghost = io->info->QSeqNo_Ghost;
        DSeqNo       = io->info->DSeqNo;
        CSeqNo       = io->info->CSeqNo;
    } 

    if ((event->prmact == 'D') && (state.isPlugged > 0)) odd='@';   /* least important */  /* can be determined by P/U field */
    else                                                 odd=' ';
    if ((event->evtflags & IS_ORPHAN_IO     )     != 0 ) odd='$';   /* med.  important */  /* this is program's view only    *//* ... which may be wrong */
    if ((event->evtflags & IS_CONFLICTED_IO)      != 0 ) odd='&';   /* med.  important */  /* this shouldn't happen too often*//* ... subcase of overlap */
    if ((event->evtflags & IS_OVERLAPPED_IO )     != 0 ) odd='#';   /* most  important */  /* can't tell except by this flag */

    pad = (96-strlen(state.inpline))>1?(96-strlen(state.inpline)):0;
    if (mask == 0x3)
    {
	/* NOTE:
         *
         * staged_on_list are not considered inProgress until they get moved to 
         * the mainio queue!  For example A,M,Q vs A,M,x -- if we only have the 
         * A events we don't know if this event will be merged into another io
         * and cease to exist as a separate countable io, or whether it will become
         * a separate countable io and moved to the mainio queue.  The inProgress
         * should reflect all io on the mainio queue.  Whereas inFlight should reflect
         * io that have a 'D' event but not a 'C' event.  Any io on the postio or done
         * queues are considered completed and should no longer count against inflight
         * or inprogress counts.
         */
	if ((event->prmact == 'D') || 
            (event->prmact == 'C'))   sprintf(bias1,"%4d", DSeqNo - QSeqNo_Ghost );
        else                          sprintf(bias1,"-");
	if  (event->prmact == 'C')    sprintf(bias2," %4d", CSeqNo - DSeqNo       );
        else                          sprintf(bias2,"");
	sprintf( buffer, "%s %*.*s ;%c%c%-3d %10lu %10lu %10lu|%4u|%4u:%4u,%4u|%4u:%4u,%4u|%s%s\n", state.inpline, pad,pad," ",
		odd,
                (state.isPlugged>=1)?'P':'U', (state.PlugCount - state.UnplugCount), 
                QSeqNo, DSeqNo, CSeqNo,
	        staged_on_list,
                state.inProgress, state.inProgress_Read, state.inProgress_Write,
                state.inFlight,   state.inFlight_Read,   state.inFlight_Write,
		bias1, bias2 );
    }
    else if (mask == 0x1)
    {
	sprintf( buffer, "%s %*.*s ;%c%c%1d\n", state.inpline, pad,pad," ",
		odd,
                (state.isPlugged>=1)?'P':'U', (state.PlugCount - state.UnplugCount) );
    }
    else /* mask == 0x0 */
    {
	/* Is this actually invoked anywhere? */
	sprintf( buffer, "=%s %*.*s ;\n", state.inpline, pad,pad," " );
    }
    /*fprintf( addf, "staged on list:%4u\n", staged_on_list );*/
    if (conf_no_annotation == 0)
        fprintf( addf, "%05d  %s", dbg_lineno, buffer );
    if (event->prmact == 'C')
        cnt_fprintf( outf, ">> %s", buffer );
    q1printf(        "%s", buffer );
    state.flag_annotated++;		/* denote/flag that the current event has been output to annotation file */
    dbg_lineno=0;
    return(0);
}

/* SECTION: FUNCTION BLOCK ; IO Processing */
/* ================================================================================================================= */
/* === IO Processing =============================================================================================== */
/* ================================================================================================================= */


/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * If EVTFLG_GHOST flag is set in 'this' event, *do not* capture event type/time/line information
 * from 'this' -- just the basics that should have been present from previous events *if* there
 * had been some (a GHOST means an orphan event has been encountered, an orphan being one where 
 * the program cannot find a request context that should have been created at A|Q or other prior
 * event time).
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
typ_io *create_io(typ_event *this)
{
typ_io *io;
typ_actions *actions, temp_actions;
int line;
double time;

    TRACE_FUNCTION;
    dprintf( "DBG[%05d]:     %20s(%c %-6s %ld+%ld '%s')\n", __LINE__, "create_io", this->prmact, this->evttyp, this->sector, this->length, this->procname );
     printf( "DBG[%05d]:     %20s(%c %-6s %ld+%ld '%s')\n", __LINE__, "create_io", this->prmact, this->evttyp, this->sector, this->length, this->procname );
    if ((io = _malloc_io(sizeof(typ_io))) == NULL)
    {
        printf( "%%F[%05d]-malloc of typ_io(%d) failed.  Total allocated memory %ld, total IOs allocated %d:%ld\n", __LINE__,
	    sizeof(typ_event), state.allocated_memory_total, state.allocated_io, state.allocated_memory_io );
	RUNTIME_FAULT(NULL,(typ_io *),"malloc failed",CTL_FAULT_FORCE);
    }
    bzero(io,sizeof(typ_io));
    state.allocated_io++;
    state.allocated_memory_io     += sizeof(typ_io);
    state.allocated_memory_total  += sizeof(typ_io);

    /* An info struct is allocated, although later if we find out its a subio, this will be removed */
    /* as for subio it contains extraneous and partial event flow                                   */
    if ((io->info = _malloc_ioinfo(sizeof(typ_ioinfo))) == NULL)
    {
        printf( "%%F[%05d]-malloc of typ_ioinfo(%d) failed.  Total allocated memory %ld, total IOs allocated %d:%ld\n", __LINE__,
	    sizeof(typ_event), state.allocated_memory_total, state.allocated_io, state.allocated_memory_io );
	RUNTIME_FAULT(NULL,(typ_io *),"malloc failed",CTL_FAULT_FORCE);
    }
    bzero(io->info,sizeof(typ_ioinfo));
    state.allocated_memory_total  += sizeof(typ_io);

    /* Copy of critical fields from event to io */
    if ((this->evtflags & EVTFLG_VALID_FROMSECT) != 0) io->ioflags |= VALID_FROM_SECTOR;
    if ((this->evtflags & EVTFLG_VALID_SECTOR  ) != 0) io->locflg  |= LOCFLG_SECTOR;
    if ((this->evtflags & EVTFLG_VALID_SIZE    ) != 0) io->locflg  |= LOCFLG_LENGTH;

    io->lstcpu   = this->cpu;
    io->lstact   = this->prmact;
    strcpy(io->lsttyp, this->evttyp );
    bcopy(this, &io->lstevt, sizeof(typ_event));
 
    _assert(io->info != NULL);
    if (state.isPlugged == 1) io->info->plug_state |= PLUGSTATE_Q;

    io->evtflags = this->evtflags;
    io->from_major = this->from_major;
    io->from_minor = this->from_minor;
    io->from_sector= this->from_sector;
    io->major      = this->major;
    io->minor      = this->minor;
    io->prmact     = this->prmact;
    io->prmtyp     = this->prmtyp;
    io->imbtyp     = this->imbtyp;
    io->iomask     = this->iomask;
    io->pid        = this->pid;
    io->cpu        = this->cpu;
    io->seqnum     = this->seqnum;
    io->length     = this->length;
    io->sector     = this->sector;
    io->timeinfo.line = this->timeinfo.line;
    io->timeinfo.time = this->timeinfo.time;
    strcpy(io->evtact, this->evtact);
    strcpy(io->evttyp, this->evttyp);
    strcpy(io->procname, this->procname);
    strcpy(io->extras  , this->extras  );
    /* this only thing that isn't copied over is the actual text line within the event */

    io->evtflags &= ~EVTFLG_GHOST;		/* clear GHOST flag in newly created io context */

    if (io->info != NULL) actions = &io->info->events;
    else                  actions = &temp_actions;
    line = this->timeinfo.line;
    time = this->timeinfo.time;
    if ((this->evtflags & EVTFLG_GHOST) == 0)
    {
        if (actions->first.line == 0) 
        {
	    actions->first_prmtyp = this->prmtyp;
            actions->first.line = line; 
            actions->first.time = time;
        }
        switch (this->prmact)
        {
            case 'A': io->event_mask |= EVTMSK_A; set_event_mask(io,EVTNDX_A); actions->remap.line         = line; actions->remap.time         = time; break;
            case 'Q': io->event_mask |= EVTMSK_Q; set_event_mask(io,EVTNDX_Q); actions->queue.line         = line; actions->queue.time         = time; break;
            case 'S': io->event_mask |= EVTMSK_S; set_event_mask(io,EVTNDX_S); actions->sleep_first.line   = line; actions->sleep_first.time   = time;  
					          actions->sleep.line         = line; actions->sleep.time         = time; break;
            case 'G': io->event_mask |= EVTMSK_G; set_event_mask(io,EVTNDX_G); actions->getrq.line         = line; actions->getrq.time         = time; break;
            case 'M': io->event_mask |= EVTMSK_M; set_event_mask(io,EVTNDX_M); actions->merge.line         = line; actions->merge.time         = time; break;
            case 'F': io->event_mask |= EVTMSK_F; set_event_mask(io,EVTNDX_F); actions->front.line         = line; actions->front.time         = time; break;
            case 'X': io->event_mask |= EVTMSK_X; set_event_mask(io,EVTNDX_X); actions->split.line         = line; actions->split.time         = time; break;
            case 'I': io->event_mask |= EVTMSK_I; set_event_mask(io,EVTNDX_I); actions->insert_first.line  = line; actions->insert_first.time  = time; 
					          actions->insert.line        = line; actions->insert.time        = time; break;
            case 'D': io->event_mask |= EVTMSK_D; set_event_mask(io,EVTNDX_D); actions->dispatch_first.line= line; actions->dispatch_first.time= time;  
					          actions->dispatch.line      = line; actions->dispatch.time      = time; break;
            case 'R': io->event_mask |= EVTMSK_R; set_event_mask(io,EVTNDX_D); actions->requeue_first.line = line; actions->requeue_first.time = time; 
					          actions->requeue.line       = line; actions->requeue.time       = time; break;
            case 'C': io->event_mask |= EVTMSK_C; set_event_mask(io,EVTNDX_C); actions->complete.line      = line; actions->complete.time      = time; break;
         /* case 'P':
            case 'U':
            case 'T': */
            default : /* io->event_mask |= EVTMSK_x; actions->other.line         = line; actions->other.time         = time; */ break; 
        }
	if (((this->prmact == 'A') || (this->prmact == 'Q')) &&
	     (this->imbtyp !=  0 ) && (io->imbtyp   ==  0 ))
        {
	    printf( "DBG[%05d]: %s() set io imbtyp %d from event %d.\n", __LINE__, __func__, io->imbtyp, this->imbtyp );
	    io->imbtyp = this->imbtyp;
	}
     }
     else
     {
	/* GHOST io is being allocated/setup */
        if (actions->first.line == 0) 
        {
	    actions->first_prmtyp = 'Q';		/* synthesize a 'Q' event in first.time		*/
            actions->first.line   = LINENUM_GHOST;	/* mark as GHOST using special line number      */
            actions->first.time   = time;
        }
     }

     if (io->cpu < MAXCPUS)
     {
         samp.cpu_bgn[io->cpu]++;
	 summ.cpu_bgn[io->cpu]++;
     }

    _return(io);
}


/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int add_io_to_staged(typ_io *this)
{
    TRACE_FUNCTION;
    dprintf( "DBG[%05d]:     %20s(%p ; %c %-6s %ld+%ld '%s') %p\n", __LINE__, "add_staged", this, this->prmact, this->evttyp, this->sector, this->length, this->procname );
    verify_staged_list(__LINE__);
    verify_mainio_list(__LINE__);
    _assert( ((staged_list == NULL) && (state.last_staged_io == NULL)) ||
             ((staged_list != NULL) && (state.last_staged_io != NULL)) );
    if (state.last_staged_io == NULL)
    {
	staged_list = this;
        state.last_staged_io = this;
        staged_on_list++;
    }
    else
    {
        state.last_staged_io->next = this;
        state.last_staged_io       = this;
        staged_on_list++;
    }
    this->ioflags |= IS_STAGED;
    dprintf( "DBG[%05d]: set IS_STAGED on io %p %10ld:%6ld\n", __LINE__, this, this->sector, this->length );
    verify_staged_list(__LINE__);
    verify_mainio_list(__LINE__);
    _assert( ((staged_list == NULL) && (state.last_staged_io == NULL)) ||
             ((staged_list != NULL) && (state.last_staged_io != NULL)) );
    _return(staged_on_list);
}

/**
 * ==========================================================================================
 * Function : add_io_to_mainio
 *            @
 * Args     : @this:          ghost request 
 *
 * Returns :
 *
 * Description
 * Create a "ghost" io event, one that we didn't process a A|Q event for, but have 1 and likely
 * more events for.  A "ghost" io event just provides a landing place for all those bits and pieces...
 * almost off of such events happen at the start of the sample as the trace starts in the middle of
 * io processing so remAp and Queue events happened before the trace started.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * 1) only used for ghost io, so inProgress etc are not touched.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int add_io_to_mainio(typ_io *this)
{
typ_io *io, *last;

    TRACE_FUNCTION;
    dprintf( "DBG[%05d]:     %20s(%p %c %-6s %ld+%ld '%s')%s\n", __LINE__, "mov_mainio ", this, this->prmact, this->evttyp, this->sector, this->length, this->procname,
	" <= move ghost io mainio list" );

    _assert( (this->evtflags & EVTFLG_GHOST) != 0);

    /* dbg_verify_staged_dump++ ; */
    verify_mainio_list(__LINE__); 
    /* --dbg_verify_staged_dump;  */

    /* Add to (top of) active list */
    this->next  = mainio_list;
    mainio_list = this;
    mainio_on_list++;

    _return(mainio_on_list);
}
/**
 * ==========================================================================================
 * Function : sub_io_from_mainio
 *            @
 * Args     : @this:          io context, removing for merging between active io on mainio queue
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * 1) only used merging between active io whereby we need to remove and already active io from mainio queue
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int sub_io_from_mainio(typ_io *this)
{
typ_io *io, *last;

    TRACE_FUNCTION;
    dprintf( "DBG[%05d]:     %20s(%p %c %-6s %ld+%ld '%s')%s\n", __LINE__, "sub_mainio ", this, this->prmact, this->evttyp, this->sector, this->length, this->procname,
	" <= remove io from mainio queue" );

    /* dbg_verify_staged_dump++ ; */
    verify_mainio_list(__LINE__); 
    /* --dbg_verify_staged_dump;  */

    /* Sub from active list       */
    if (mainio_list == this)
    {
	/* remove from top of list */
	mainio_list = this->next;
	this->next  = (typ_io *)NULL;
        --mainio_on_list;
    }
    else
    {
        for (io=mainio_list; (io->next != NULL) && (io->next != this); io=io->next);
        if (io->next == this)
        {
            io->next = this->next;
            --mainio_on_list;
            this->next = (typ_io *)NULL;
        }
        else
        { char reason[256];
            sprintf( reason, "internal logic failure, %p not on mainio_list.", this );
            PROG_FEATURE_FAULT1(this,(int),reason,CTL_FAULT_FORCE);
        }
    }
    this->ioflags &= (~IS_STAGED);
    dprintf( "DBG[%05d]: clr IS_STAGED on io %p %10ld:%6ld\n", __LINE__, this, this->sector, this->length );

    if (mainio_list == NULL)
        /* state.last_mainio_io = NULL; */ ;

    /* Adjust the stats associated with mainio list */
    /* Undo stats from move_staged_to_mainio()      */
    if ((this->evtflags & EVTFLG_GHOST) == 0)
    {
        dprintf( "DBG[%05d]: %s() - inProgress-- = %d\n", __LINE__, __FUNCTION__, state.inProgress-1 );
        /* avg queue depth here before inProgress changed */
        state.inProgress--;                               /* not all io on the active queue may be qualified as read or write */
        if  (this->prmtyp == IOTYP_READ       )
        {
            state.inProgress_Read--;
            state.started_reads--;
        }
        if ((this->prmtyp == IOTYP_WRITE      ) ||
            (this->prmtyp == IOTYP_META       ) ||
            (this->prmtyp == IOTYP_BARRIER    ) ||
            (this->prmtyp == IOTYP_DISCARD    ))
        {
            state.inProgress_Write--;
            state.started_writes--;
        }
        cnt_printf( "DBG[%05d]: %24s() iocnt (%5d) inProgress-- %5d: %5d,%5d\n", __LINE__, __func__, state.inFlight, state.inProgress, state.inProgress_Read, state.inProgress_Write );
        cnt_fprintf( outf, "DBG[%05d]: %c:%08ld.%06ld iocnt (%5d) inProgress-- %5d: %5d,%5d\n", __LINE__, 
		_prmtyp(this->prmtyp), this->sector, this->length, state.inFlight, state.inProgress, state.inProgress_Read, state.inProgress_Write );
    }


    verify_mainio_list(__LINE__); 
    _return(mainio_on_list);
}


/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int sub_io_from_staged(typ_io *this)
{
typ_io *io, *last;

    TRACE_FUNCTION;
    dprintf( "DBG[%05d]:     %20s(%p %c %-6s %ld+%ld '%s')%s\n", __LINE__, "sub_staged ", this, this->prmact, this->evttyp, this->sector, this->length, this->procname,
	" <= remove io from staged list" );
    if (state.last_staged_io == this)
    {
        /* 'this' is at end of list (...and *maybe* at front of list too!} */ /* special case: need to update state.last_staged_io */
        verify_staged_list(__LINE__);
        if (staged_list == this)
        {
	    /* there is only the one 'this' on the list      */
	    /* there is no next-to-last to find in this case */
	    staged_list = NULL;
	    state.last_staged_io = NULL;
	    _assert(staged_on_list == 1);
        }
        else
        {
	    /* move to next to last entry                    */
            for (last=NULL,io=staged_list; io->next != NULL; last=io, io=io->next);
	    dprintf( "DBG[%05d]: last %p io %p\n", __LINE__, last, io );
            _assert(last->next == this);
            last->next = NULL;
            state.last_staged_io = last;
        }
	--staged_on_list;
        _assert(this->next == NULL);
    }
    else if (staged_list == this)
    {
        /* 'this' is at top of list */
	staged_list = staged_list->next;
        --staged_on_list;
        this->next = (typ_io *)NULL;
    }
    else
    {
        for (io=staged_list; (io->next != NULL) && (io->next != this); io=io->next);
        if (io->next == this)
        {
	    io->next = this->next;
	    --staged_on_list;
	    this->next = (typ_io *)NULL;
	}
        else
        { char reason[256];
	    sprintf( reason, "internal logic failure, %p not on staged_list.", this );
	    PROG_FEATURE_FAULT1(this,(int),reason,CTL_FAULT_FORCE);
        }
    }
    this->ioflags &= (~IS_STAGED);
    dprintf( "DBG[%05d]: clr IS_STAGED on io %p %10ld:%6ld\n", __LINE__, this, this->sector, this->length );

    if (staged_list == NULL)
        state.last_staged_io = NULL;

    verify_staged_list(__LINE__);
    _assert( ((staged_list == NULL) && (state.last_staged_io == NULL)) ||
             ((staged_list != NULL) && (state.last_staged_io != NULL)) );
    _return(staged_on_list);
}




/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int move_staged_to_mainio(typ_io *this)
{
typ_io *io, *last;

    TRACE_FUNCTION;
    dprintf( "DBG[%05d]:     %20s(%p %c %-6s %ld+%ld '%s')%s\n", __LINE__, "mov_staged ", this, this->prmact, this->evttyp, this->sector, this->length, this->procname,
	" <= remove io from staged list, add to mainio list" );

    _assert( (this->ioflags & IS_STAGED) != 0 );
    /* dbg_verify_staged_dump++ ; */
    verify_staged_list(__LINE__); 
    /* --dbg_verify_staged_dump;  */

    /* Removed from staged list */
    if (state.last_staged_io == this)
    {
        /* 'this' is at end of list (...and *maybe* at front of list too!} */ /* special case: need to update state.last_staged_io */
	_assert( this->next     == NULL);
        if (staged_list == this)
        {
	    /* ok, 1 items on list */
            _assert( staged_on_list == 1 );
	    staged_list = NULL;
	    last        = NULL;
	}
        else
	{
            for (last=NULL,io=staged_list; io->next != NULL; last=io, io=io->next);
            _assert(last->next == this);
            last->next = NULL;
	}
        state.last_staged_io = last;
	--staged_on_list;
    }
    else if (staged_list == this)
    {
	 /* on top of list, but not only entry as that was handled above */
         staged_list = this->next;
         --staged_on_list;
    }
    else
    {
        for (last = staged_list; (last->next != NULL) && (last->next != this); last = last->next);
        if (last->next != this)
        { char reason[256];
	    sprintf( reason, "internal logic failure, %p not on staged_list.", this );
	    PROG_FEATURE_FAULT1(this,(int),reason,CTL_FAULT_FORCE);
	}
        last->next = this->next;
	--staged_on_list;
    }
    this->ioflags &= (~IS_STAGED);
    dprintf( "DBG[%05d]: clr IS_STAGED on io %p %10ld:%6ld\n", __LINE__, this, this->sector, this->length );

    /* Add to (top of) active list */
    this->next  = mainio_list;
    mainio_list = this;
    mainio_on_list++;

    /* Adjust the stats associated with mainio list */
    if ((this->evtflags & EVTFLG_GHOST) == 0)
    {
	dprintf( "DBG[%05d]: %s() - inProgress++ = %d\n", __LINE__, __FUNCTION__, state.inProgress+1 );
	/* avg queue depth here before inProgress changed */
        state.avgqu_weighted += (this->info->events.first.time - state.avgqu_lasttime) * (double)state.inProgress;
        samp.avgqu_weighted  += (this->info->events.first.time -  samp.avgqu_lasttime) * (double)state.inProgress;
        summ.avgqu_weighted  += (this->info->events.first.time -  summ.avgqu_lasttime) * (double)state.inProgress;
	state.avgqu_lasttime  =  this->info->events.first.time;
	samp.avgqu_lasttime   =  this->info->events.first.time;
	summ.avgqu_lasttime   =  this->info->events.first.time;
        if (state.inProgress > samp.avgqu_max) samp.avgqu_max = state.inProgress;
        if (state.inProgress > summ.avgqu_max) summ.avgqu_max = state.inProgress;
        state.inProgress++;                               /* not all io on the active queue may be qualified as read or write */
        if  (this->prmtyp == IOTYP_READ       )
        {
            state.inProgress_Read++;
            state.started_reads++;
        }
        if ((this->prmtyp == IOTYP_WRITE      ) ||
            (this->prmtyp == IOTYP_META       ) ||
            (this->prmtyp == IOTYP_BARRIER    ) ||
            (this->prmtyp == IOTYP_DISCARD    ))
        {
            state.inProgress_Write++;
            state.started_writes++;
        }
        cnt_printf( "DBG[%05d]: %24s() iocnt (%5d) inProgress++ %5d: %5d,%5d\n", __LINE__, __func__, state.inFlight, state.inProgress, state.inProgress_Read, state.inProgress_Write );
        cnt_fprintf( outf, "DBG[%05d]: %c:%08ld.%06ld iocnt (%5d) inProgress++ %5d: %5d,%5d\n", __LINE__, 
		_prmtyp(this->prmtyp), this->sector, this->length, state.inFlight, state.inProgress, state.inProgress_Read, state.inProgress_Write );
    }

    _return(mainio_on_list);
}


/**
 * ==========================================================================================
 * Function : move_staged_to_dead
 *            @this	   io structure
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * Move an io from staged to deadio
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * This is used against XPARENT io blocks in LV (253) devices that, by practice, do not
 * seem to ever have C events (Q/X/.../X/nil vs expected Q/X/.../X/C)
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int move_staged_to_dead(typ_io *this)
{
typ_io *io, *last;

    TRACE_FUNCTION;
     printf( "DBG[%05d]:     %20s(%p %c %-6s %ld+%ld '%s')%s\n", __LINE__, "mov_deadio ", this, this->prmact, this->evttyp, this->sector, this->length, this->procname,
	" <= remove io from staged list, add to deadio list" );
    dprintf( "DBG[%05d]:     %20s(%p %c %-6s %ld+%ld '%s')%s\n", __LINE__, "mov_deadio ", this, this->prmact, this->evttyp, this->sector, this->length, this->procname,
	" <= remove io from staged list, add to deadio list" );

    _assert( (this->ioflags & IS_STAGED) != 0 );
    /* dbg_verify_staged_dump++ ; */
    verify_staged_list(__LINE__); 
    /* --dbg_verify_staged_dump;  */

    /* Removed from staged list */
    if (state.last_staged_io == this)
    {
        /* 'this' is at end of list (...and *maybe* at front of list too!} */ /* special case: need to update state.last_staged_io */
	_assert( this->next     == NULL);
        if (staged_list == this)
        {
	    /* ok, 1 items on list */
            _assert( staged_on_list == 1 );
	    staged_list = NULL;
	    last        = NULL;
	}
        else
	{
            for (last=NULL,io=staged_list; io->next != NULL; last=io, io=io->next);
            _assert(last->next == this);
            last->next = NULL;
	}
        state.last_staged_io = last;
	--staged_on_list;
    }
    else if (staged_list == this)
    {
	 /* on top of list, but not only entry as that was handled above */
         staged_list = this->next;
         --staged_on_list;
    }
    else
    {
        for (last = staged_list; (last->next != NULL) && (last->next != this); last = last->next);
        if (last->next != this)
        { char reason[256];
	    sprintf( reason, "internal logic failure, %p not on staged_list.", this );
	    PROG_FEATURE_FAULT1(this,(int),reason,CTL_FAULT_FORCE);
	}
        last->next = this->next;
	--staged_on_list;
    }

    /* Add to (top of) deadio list */
    this->next  = deadio_list;
    deadio_list = this;
    deadio_on_list++;

    _return(mainio_on_list);
}


/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int move_mainio_to_done(typ_io *this)
{
typ_io *io, *last;

    TRACE_FUNCTION;
    dprintf( "DBG[%05d]:     %20s(%p %c %-6s %ld+%ld '%s')%s\n", __LINE__, "mov_mainio ", this, this->prmact, this->evttyp, this->sector, this->length, this->procname,
	" <= remove io from mainio list, add to done   list" );
    printf( "DBG[%05d]:     %20s(%p %c %-6s %ld+%ld '%s')%s\n", __LINE__, "mov_mainio ", this, this->prmact, this->evttyp, this->sector, this->length, this->procname,
	" <= remove io from mainio list, add to done   list" );

    _assert( (this->ioflags & IS_STAGED) == 0 );
    verify_mainio_list(__LINE__);

    if (mainio_list == this)
    {
	 /* on top of list, but not only entry as that was handled above */
         mainio_list = this->next;
         --mainio_on_list;
    }
    else
    {
        for (last = mainio_list; (last->next != NULL) && (last->next != this); last = last->next);
        if (last->next != this)
        { char reason[256];
	    sprintf( reason, "internal logic failure, %p not on mainio list.", this );
	    PROG_FEATURE_FAULT1(this,(int),reason,CTL_FAULT_FORCE);
	}
        last->next = this->next;
	--mainio_on_list;
    }

    /* Ok, its removed from postio queue, check to see if it needs to be flushed from ibm active */
    if (this->imbtyp != 0)
    {
        printf( "DBG[%05d]: %s(%p imbtyp %d)\n", __LINE__, __func__, this, this->imbtyp );
        imb_active_rem(this);
    }

    /* Add to (top of) done list */
    /* @@@TBD done_list          */
    /* @@@TBD yeah known leak?   */
    /* @@@TBD done list is to be used to detect out of band events after its thought to be done */

    /* this is done when we move the io to post queue */
    /* but we may be doing a move mainio->done which  */
    /* bypasses post queue, so do them if that is case*/
    if ((this->evtflags & EVTFLG_INPROGDONE) == 0)
    {
        /* Some io are mainio->post->done and yet others mainio->done */
        /* Allow for either case by using flag to protect inProgress  */
        /* counts do they are only done once.                         */
        dprintf( "DBG[%05d]: updated inProgress here @move_io_to_done() time.\n", __LINE__ );
        this->evtflags |= EVTFLG_INPROGDONE;
        if ((this->evtflags & EVTFLG_GHOST) == 0)
        {
            /* Adjust the stats associated with mainio list */
	    dprintf( "DBG[%05d]: %s() - inProgress-- = %d\n", __LINE__, __FUNCTION__, state.inProgress-1 );
	    /* avg queue depth here before inProgress changed */
            state.avgqu_weighted += (this->info->events.complete.time - state.avgqu_lasttime) * (double)state.inProgress;
            samp.avgqu_weighted  += (this->info->events.complete.time -  samp.avgqu_lasttime) * (double)state.inProgress;
            summ.avgqu_weighted  += (this->info->events.complete.time -  summ.avgqu_lasttime) * (double)state.inProgress;
	    state.avgqu_lasttime  =  this->info->events.complete.time;
	    samp.avgqu_lasttime   =  this->info->events.complete.time;
	    summ.avgqu_lasttime   =  this->info->events.complete.time;
            if (state.inProgress > samp.avgqu_max) samp.avgqu_max = state.inProgress;
            if (state.inProgress > summ.avgqu_max) summ.avgqu_max = state.inProgress;
            state.inProgress--;                               /* not all io on the active queue may be qualified as read or write */
            if  (this->prmtyp == IOTYP_READ       )
            {
                state.inProgress_Read--;
	        state.completed_reads++;
            }
            if ((this->prmtyp == IOTYP_WRITE      ) ||
                (this->prmtyp == IOTYP_META       ) ||
                (this->prmtyp == IOTYP_BARRIER    ) ||
                (this->prmtyp == IOTYP_DISCARD    ))
            {
                state.inProgress_Write--;
                state.completed_writes++;
            }
            cnt_printf( "DBG[%05d]: %24s() iocnt (%5d) inProgress-- %5d: %5d,%5d\n", __LINE__, __func__, state.inFlight, state.inProgress, state.inProgress_Read, state.inProgress_Write );
            cnt_fprintf( outf, "DBG[%05d]: %c:%08ld.%06ld iocnt (%5d) inProgress-- %5d: %5d,%5d\n", __LINE__, 
		_prmtyp(this->prmtyp), this->sector, this->length, state.inFlight, state.inProgress, state.inProgress_Read, state.inProgress_Write );

	    if (state.inProgress == 0)
            {
		/* device queue just became idle! */
	        state.IEvtTime   = this->lstevt.timeinfo.time;
		state.idle_state = Q_IS_IDLE;
		dprintf( "DBG[%05d]: queue state set idle @%12.9f here @move_mainio_to_done()\n", __LINE__, state.IEvtTime );
	    }
        }
        else
        {
	    state.ghosts_completed++;
        }
    }

    /* Should be able to free all the allocated structures associated with this io */

    _return(mainio_on_list);
}

/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int move_mainio_to_post(typ_io *this)
{
typ_io *io, *last;

    TRACE_FUNCTION;
    dprintf( "DBG[%05d]:     %20s(%p %c %-6s %ld+%ld '%s')%s\n", __LINE__, "mov_mainio ", this, this->prmact, this->evttyp, this->sector, this->length, this->procname,
	" <= remove io from mainio list, add to postio list" );
    dprintf( "DBG[%05d]:     %20s(%p %c %-6s %ld+%ld '%s')%s\n", __LINE__, "mov_mainio ", this, this->prmact, this->evttyp, this->sector, this->length, this->procname,
	" <= remove io from mainio list, add to postio list" );

    _assert( (this->ioflags & IS_STAGED) == 0 );
    _assert( (this->ioflags & IS_POSTIO) == 0 );
    verify_mainio_list(__LINE__);
    verify_postio_list(__LINE__);

    if (mainio_list == NULL)
    { char reason[256];
	sprintf( reason, "internal logic failure, %p not on mainio list, list empty!.", this );
	PROG_FEATURE_FAULT1(this,(int),reason,CTL_FAULT_FORCE);
    }
    if (mainio_list == this)
    {
	 /* on top of list, but not only entry as that was handled above */
         mainio_list = this->next;
         --mainio_on_list;
    }
    else
    {
        for (last = mainio_list; (last->next != NULL) && (last->next != this); last = last->next);
        if (last->next != this)
        { char reason[256];
	    sprintf( reason, "internal logic failure, %p not on mainio list.", this );
	    PROG_FEATURE_FAULT1(this,(int),reason,CTL_FAULT_FORCE);
	}
        last->next = this->next;
	--mainio_on_list;
    }

    this->next = NULL; 
    this->ioflags |= IS_POSTIO;

    /* Add to (end of) postio list */ /* postio is time ordered oldest @top, newest @bot for timeout ordered processing */
    if (postio_list == NULL)
    {
	postio_list = this;
	postio_last = this;
	postio_on_list++;
    }
    else
    {
	postio_last->next = this;
	postio_last       = this;
        postio_on_list++;
    }

    /* Other B,C,D stuffs, @@@TBD check notes       */

    /* ...and should we do this now, here, or later */
    /* now.  this is first complete against this io */
    /* so technically it is done.                   */
    if ((this->evtflags & EVTFLG_INPROGDONE) == 0)
    {
	/* Some io are mainio->post->done and yet others mainio->done */
	/* Allow for either case by using flag to protect inProgress  */
	/* counts do they are only done once.                         */
        dprintf( "DBG[%05d]: updated inProgress here @move_io_to_post() time.\n", __LINE__ );
	this->evtflags |= EVTFLG_INPROGDONE;
        if ((this->evtflags & EVTFLG_GHOST) == 0)
        {
            /* Adjust the stats associated with mainio list */
	    dprintf( "DBG[%05d]: %s() - inProgress-- = %d\n", __LINE__, __FUNCTION__, state.inProgress-1 );
	    /* avg queue depth here before inProgress changed */
            state.avgqu_weighted += (this->info->events.complete.time - state.avgqu_lasttime) * (double)state.inProgress;
            samp.avgqu_weighted  += (this->info->events.complete.time -  samp.avgqu_lasttime) * (double)state.inProgress;
            summ.avgqu_weighted  += (this->info->events.complete.time -  summ.avgqu_lasttime) * (double)state.inProgress;
	    state.avgqu_lasttime  =  this->info->events.complete.time;
	    samp.avgqu_lasttime   =  this->info->events.complete.time;
	    summ.avgqu_lasttime   =  this->info->events.complete.time;
            if (state.inProgress > samp.avgqu_max) samp.avgqu_max = state.inProgress;
            if (state.inProgress > summ.avgqu_max) summ.avgqu_max = state.inProgress;
            state.inProgress--;                               /* not all io on the active queue may be qualified as read or write */
            if  (this->prmtyp == IOTYP_READ       )
            {
                state.inProgress_Read--;
	        state.completed_reads++;
            }
            if ((this->prmtyp == IOTYP_WRITE      ) ||
                (this->prmtyp == IOTYP_META       ) ||
                (this->prmtyp == IOTYP_BARRIER    ) ||
                (this->prmtyp == IOTYP_DISCARD    ))
            {
                state.inProgress_Write--;
                state.completed_writes++;
            }
            cnt_printf( "DBG[%05d]: %24s() iocnt (%5d) inProgress-- %5d: %5d,%5d\n", __LINE__, __func__, state.inFlight, state.inProgress, state.inProgress_Read, state.inProgress_Write );
            cnt_fprintf( outf, "DBG[%05d]: %c:%08ld.%06ld iocnt (%5d) inProgress-- %5d: %5d,%5d\n", __LINE__, 
		_prmtyp(this->prmtyp), this->sector, this->length, state.inFlight, state.inProgress, state.inProgress_Read, state.inProgress_Write );

	    if (state.inProgress == 0)
            {
		/* device queue just became idle! */
	        state.IEvtTime   = this->lstevt.timeinfo.time;
		state.idle_state = Q_IS_IDLE;
		dprintf( "DBG[%05d]: queue state set idle @%12.9f here @move_mainio_to_post()\n", __LINE__, state.IEvtTime );
	    }

	    /* Before calling this routine, a ctracker should have been  */
	    /* created and snapshot'd inProgress and inFlight counters   */
            /* to be used later when the io is actually sent to output   */
        }
        else
        {
	    state.ghosts_completed++;
        }
    }

    _return(postio_on_list);
}
/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int move_postio_to_done(typ_io *this)
{
typ_io *io, *last;

    TRACE_FUNCTION;
    dprintf( "DBG[%05d]:     %20s(%p %c %-6s %ld+%ld '%s')%s\n", __LINE__, "mov_postio ", this, this->prmact, this->evttyp, this->sector, this->length, this->procname,
	" <= remove io from postio list, add to done   list" );
    printf( "DBG[%05d]:     %20s(%p %c %-6s %ld+%ld '%s')%s\n", __LINE__, "mov_postio ", this, this->prmact, this->evttyp, this->sector, this->length, this->procname,
	" <= remove io from postio list, add to done   list" );

    _assert( (this->ioflags & IS_POSTIO) != 0 );
    verify_postio_list(__LINE__);

    if (postio_list == this)
    {
	/* on top of list, but not only entry as that was handled above */
        postio_list = this->next;
        --postio_on_list;
	     if (postio_on_list == 0) postio_last = NULL;
	else if (postio_last == this)
        {
	    /* Find list in list */
            for (last = postio_list; (last->next != NULL); last = last->next);
	    postio_last = last;
 	}
    }
    else
    {
        for (last = postio_list; (last->next != NULL) && (last->next != this); last = last->next);
        if (last->next != this)
        { char reason[256];
	    sprintf( reason, "internal logic failure, %p not on postio list.", this );
	    PROG_FEATURE_FAULT1(this,(int),reason,CTL_FAULT_FORCE);
	}
        last->next = this->next;
	--postio_on_list;

	if (postio_last == this)
        {
	    /* Find list in list */
            for (last = postio_list; (last->next != NULL); last = last->next);
	    postio_last = last;
	}
    }
    this->ioflags &= (~IS_POSTIO); 

    /* Ok, its removed from postio queue, check to see if it needs to be flushed from ibm active */
    if (this->imbtyp != 0)
    {
        printf( "DBG[%05d]: %s(%p imbtyp %d)\n", __LINE__, __func__, this, this->imbtyp );
        imb_active_rem(this);
    }

    /* Add to (top of) done list */
    /* @@@TBD done_list          */
    /* @@@TBD yeah known leak?   */
    /* @@@TBD done list is to be used to detect out of band events after its thought to be done */

    /* Adjust the stats associated with mainio list */
    /* NOTE: not needed, as this was done when io   */
    /*       was moved mainio -> postio             */

    _return(postio_on_list);
}




/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int add_subio_to_mainio(typ_io *this, typ_io *subio, char *rsn )
{

    TRACE_FUNCTION;
    dprintf( "DBG[%05d]:     %20s(%p %c %-6s %ld+%ld '%s')%s\n", __LINE__, "add_subio  ", this, this->prmact, this->evttyp, this->sector, this->length, this->procname, 
	" <= mainio" );
    dprintf( "DBG[%05d]:     %20s(%p %c %-6s %ld+%ld '%s')%s\n", __LINE__, "add_subio.1", subio,subio->prmact,subio->evttyp,subio->sector,subio->length, subio->procname, rsn );

    /* free any info block on the subio */
    if (subio->info != NULL)
    {
        _free_ioinfo(subio->info);
        subio->info = (typ_ioinfo *)NULL;
    }

    if (this->subio == NULL)
    {
        _assert( this->lstsubio == NULL );
        subio->lstsubio = (typ_io *)NULL;	/* points back to "head"                   */
        this->subio = this->lstsubio = subio;   /* "head" and last point to 1st/only subio */
    }
    else
    {
	_assert( this->lstsubio != NULL );
        subio->lstsubio       = this->lstsubio; /* point back to previous subio           */
        subio->subio          = (typ_io *)NULL; /* point to next ("tail") of subio list   */
        this->lstsubio->subio = subio;
        this->lstsubio        = subio;
    }
    subio->next     = (typ_io *)NULL;		/* not used in subio!                     */
    subio->parent   = this;			/* point back to "parent"/mainio          */
    subio->ioflags |= IS_SUBIO;			/* flag subio as subio only when on list  */

    this->info->cnt_merges++;			/* reflect # subio on list                */

    _return(this->info->cnt_merges);
}


/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
typ_io *clone_to_subio( typ_io *this )
{
typ_io *clone;

    TRACE_FUNCTION;
    dprintf( "DBG[%05d]:     %20s(%p %c %-6s %ld+%ld '%s')%s\n", __LINE__, "clone2subio", this, this->prmact, this->evttyp, this->sector, this->length, this->procname, 
	" <= clone copy of mainio into subio form" );
    if ((clone = _malloc_io(sizeof(typ_io))) == NULL)
    {
        printf( "%%F[%05d]-malloc of typ_io(%d) failed.  Total allocated memory %ld, total IOs allocated %d:%ld\n", __LINE__,
	    sizeof(typ_event), state.allocated_memory_total, state.allocated_io, state.allocated_memory_io );
	RUNTIME_FAULT(NULL,(typ_io *),"malloc of clone subio failed",CTL_FAULT_FORCE);
    }
    bzero(clone,sizeof(typ_io));
    state.allocated_io++;
    state.allocated_memory_io     += sizeof(typ_io);
    state.allocated_memory_total  += sizeof(typ_io);

    bcopy(this,clone,sizeof(typ_io));
    /* make sure pointers are all initialized to null */
    clone->next     = (typ_io *)NULL;
    clone->subio    = (typ_io *)NULL; 
    clone->lstsubio = (typ_io *)NULL; 
    clone->parent   = (typ_io *)NULL; 
    clone->ctracker = (typ_ctracker *)NULL;

    /* we only clone the main portion of the io */
    clone->info     = (typ_ioinfo *)NULL;
    _return(clone);
}

/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int verify_staged_list(int line )
{
int    cnt;
int    err;
typ_io *io, *last;

    for (err=cnt=0, last=NULL, io=staged_list; io != NULL; io = io->next)
    { 
	cnt++;
        if (io->next == NULL) last = io;
	if ((io->ioflags & IS_STAGED) == 0) { err++; printf( "DBG[%05d]: staged io %p:%ld,%ld IS_STAGED is not set!\n", __LINE__, io, io->sector, io->length ); }
    }
    if ((cnt != staged_on_list) || (last != state.last_staged_io) || (err != 0))
    {
        printf( "DBG[%05d]: verify_staged_list(failed)\n", line );
        if (last != state.last_staged_io)
	    printf( "DBG[%05d]: last on staged list %p != %p state.last_staged_io\n", __LINE__, last, state.last_staged_io );
	printf( "DBG[%05d]: verify_staged_list[---] %8s %6s     %8s %6s    %p (head)\n", line, " ", " ", " ", " ", staged_list );
        for (cnt=0, io=staged_list; io != NULL; io = io->next)
	{
	    cnt++;
	    printf( "DBG[%05d]: verify_staged_list[%3d] %10ld:%6ld (<- %10ld:%6ld) %p\n", __LINE__, cnt,
	        io->sector, io->length, io->from_sector, (io->from_sector != 0)?io->length:0, io->next );
        }
        printf( "DBG[%05d]: verify_staged_list[%3d] <= staged_on_list count\n", __LINE__, staged_on_list );
        fflush(stdout);
	sleep(1);
    }
    else if (dbg_verify_staged_dump != 0)
    {
	printf( "DBG[%05d]:     last_staged_io[---] %8s %6s     %8s %6s    %p (state)\n", line, " ", " ", " ", " ", state.last_staged_io );
	printf( "DBG[%05d]:   dump_staged_list[---] %8s %6s     %8s %6s    %p (head)\n", line, " ", " ", " ", " ", staged_list );
        for (cnt=0, io=staged_list; io != NULL; io = io->next)
	{
	    cnt++;
	    printf( "DBG[%05d]:   dump_staged_list[%3d] %10ld:%6ld (<- %10ld:%6ld) %p\n", __LINE__, cnt,
	        io->sector, io->length, io->from_sector, (io->from_sector != 0)?io->length:0, io->next );
        }
        printf( "DBG[%05d]:   dump_staged_list[%3d] <= staged_on_list count\n", __LINE__, staged_on_list );
        fflush(stdout);
    }

    _assert( cnt == staged_on_list );
    _assert( last == state.last_staged_io );
    dprintf( "DBG[%05d]: verify_staged_list(ok:%d)\n", line, staged_on_list );
    return(0);
}


/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int verify_mainio_list(int line)
{
int    cnt, subcnt, errs;
typ_io *io, *last, *subio;

    TRACE_FUNCTION;
    dprintf( "DBG[%05d]: verify_mainio_list\n", line );
    errs = 0;
    for (cnt=0, last=NULL, io=mainio_list; io != NULL; io = io->next)
    {
        cnt++;
        if (io->next  == NULL) last = io;
	if (io->subio != NULL)
	{
	    for (subcnt=0, subio=io->subio; subio != NULL; subio = subio->subio) subcnt++;
	    if (subcnt != io->info->cnt_merges)
	    {
		errs++;
		printf( "DBG[%05d]: verify_mainio_list(failed:subio miscount)\n", line );
	        printf( "DBG[%05d]: verify_mainio_list[---] %8s %6s     %8s %6s   %p (head)\n", line, " ", " ", " ", " ", io );
	        printf( "DBG[%05d]: verify_mainio_list[---] %10ld:%6ld (<- %10ld:%6ld) %p\n", __LINE__,
	                io->sector, io->length, io->from_sector, (io->from_sector != 0)?io->length:0, io->subio );
                for (subcnt=0, subio=io->subio; subio != NULL; subio = subio->subio)
	        {
	            subcnt++;
	            printf( "DBG[%05d]: verify_mainio_list[%3d] %10ld:%6ld (<- %10ld:%6ld) %p\n", __LINE__, subcnt,
	                subio->sector, subio->length, subio->from_sector, (subio->from_sector != 0)?subio->length:0, subio->subio );
                }
                fflush(stdout);
	        sleep(1);
	    }
	}
    }
    if (cnt != mainio_on_list) 
    {
	errs++;
        printf( "DBG[%05d]: verify_mainio_list(failed)\n", line );
	printf( "DBG[%05d]: verify_mainio_list[---] %8s %6s     %8s %6s   %p (head)\n", line, " ", " ", " ", " ", mainio_list );
        for (cnt=0, io=mainio_list; io != NULL; io = io->next)
	{
	    cnt++;
	    printf( "DBG[%05d]: verify_mainio_list[%3d] %10ld:%6ld (<- %10ld:%6ld) %p\n", __LINE__, cnt,
	        io->sector, io->length, io->from_sector, (io->from_sector != 0)?io->length:0, io->next );
        }
        printf( "DBG[%05d]: verify_mainio_list[%3d] <= mainio_on_list count\n", __LINE__, mainio_on_list );
        fflush(stdout);
	sleep(1);
    }
    _assert( cnt == mainio_on_list );
    _assert( errs == 0             );
    dprintf( "DBG[%05d]: verify_mainio_list(ok:%d)\n", line, mainio_on_list );
    return(0);
}

/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int verify_postio_list(int line)
{
int    cnt, subcnt;
typ_io *io, *last, *subio;
int    errs;

    errs = 0;
    for (cnt=0, last=NULL, io=postio_list; io != NULL; io = io->next)
    {
        cnt++;
        if (io->next == NULL) last = io;
        if (io->subio != NULL)
        {
            for (subcnt=0, subio=io->subio; subio != NULL; subio = subio->subio) subcnt++;
            if (subcnt != io->info->cnt_merges)
            {
                errs++; 
                printf( "DBG[%05d]: verify_postio_list(failed:subio miscount)\n", line );
                printf( "DBG[%05d]: verify_postio_list[---] %8s %6s     %8s %6s   %p (head)\n", line, " ", " ", " ", " ", io );
                printf( "DBG[%05d]: verify_postio_list[---] %10ld:%6ld (<- %10ld:%6ld) %p\n", __LINE__, 
                        io->sector, io->length, io->from_sector, (io->from_sector != 0)?io->length:0, io->subio );
                for (subcnt=0, subio=io->subio; subio != NULL; subio = subio->subio)
                {   
                    subcnt++;
                    printf( "DBG[%05d]: verify_postio_list[%3d] %10ld:%6ld (<- %10ld:%6ld) %p\n", __LINE__, subcnt,
                        subio->sector, subio->length, subio->from_sector, (subio->from_sector != 0)?subio->length:0, subio->subio );
                }
                fflush(stdout);
                sleep(1);
            }
        } 
    }
    if (cnt != postio_on_list) 
    {
        printf( "DBG[%05d]: verify_postio_list(failed)\n", line );
	printf( "DBG[%05d]: verify_postio_list[---] %8s %6s     %8s %6s   %p (head)\n", line, " ", " ", " ", " ", postio_list );
        for (cnt=0, io=postio_list; io != NULL; io = io->next)
	{
	    cnt++;
	    printf( "DBG[%05d]: verify_postio_list[%3d] %10ld:%6ld (<- %10ld:%6ld) %p\n", __LINE__, cnt,
	        io->sector, io->length, io->from_sector, (io->from_sector != 0)?io->length:0, io->next );
        }
        printf( "DBG[%05d]: verify_postio_list[%3d] <= postio_on_list count\n", __LINE__, postio_on_list );
        fflush(stdout);
	sleep(1);
    }
    _assert( cnt == postio_on_list );
    _assert( errs == 0             );
    dprintf( "DBG[%05d]: verify_postio_list(ok)\n", line );
    return(0);
}

/* SECTION: FUNCTION BLOCK ; MEMORY MANAGEMENT */
/* ================================================================================================================= */
/* === MEMORY MANAGEMENT =========================================================================================== */
/* ================================================================================================================= */
void *_malloc_event (unsigned int size) { return(malloc(size)); }
void *_malloc_io    (unsigned int size) { return(malloc(size)); }
void *_malloc_ioinfo(unsigned int size) { return(malloc(size)); }
void  _free_ioinfo  (void *ptr        ) { free(ptr); return;    }

/* SECTION: FUNCTION BLOCK ; STATS UTILITIES */
/* ================================================================================================================= */
/* === STATS UTILITIES ============================================================================================= */
/* ================================================================================================================= */

/*
 * STATS consist of several things.  
 *   a) typ_accumulator
 *      - the accumulator structure includes counts and totals -- so total number of reads, total number
 *        of writes, total accumulated await time.  So at end of sample boundary the average await time
 *        can be computed.  Note that min/max/tot are tracked for each N2N type dTime value (Q2C, D2C, et.al.)
 *   b) "bins" containing counts and totals within each bin
 *      - for example, the await "bins" contain the number of io that fall into that sorted bin,
 *        so 1st bin is 1ms, any io with await 0-1ms are placed in that bin.  The next bin is 2ms,
 *        so any io >1ms but <= 2ms are counted in this 2nd bin, and so forth. 
 */


/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int stats_samp_init()
{
    _stats_accum_init( &samp );
    return(0);
}

/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int stats_summ_init()
{
    _stats_accum_init( &summ );
    return(0);
}


/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int _stats_accum_init( typ_accumulator *accum )
{
double boundary;
long   inflight;

    boundary = accum->boundary;		/* save "no init" fields    */
    inflight = accum->inflight;
    bzero(accum,sizeof(typ_accumulator));
    accum->boundary = boundary;         /* restore "no init" fields */
    accum->inflight = inflight;

    /* accum->rqm_reads    = 0;		*/
    /* accum->rqm_writes   = 0;		*/
    /* accum->cnt_reads    = 0;		*/
    /* accum->cnt_writes   = 0;		*/
    /* accum->blks_read    = 0;		*/
    /* accum->blks_written = 0;		*/

    /* accum->seek         = 0;		*/

    accum->dt_idle          = 0.00;

    accum->dt_tot_read.queue.time    = 0.00; 
    accum->dt_tot_read.insert.time   = 0.00;
    accum->dt_tot_read.dispatch.time = 0.00;
    accum->dt_tot_read.complete.time = 0.00;
    accum->dt_tot_read.requeue.time  = 0.00;
    accum->dt_tot_read.d2c_first.time= 0.00;
    accum->dt_tot_read.d2c_last.time = 0.00;
    accum->dt_tot_read.d2d.time      = 0.00;
    accum->dt_tot_read.insert_first.time   = 0.0;
    accum->dt_tot_read.dispatch_first.time = 0.0;
    accum->dt_tot_read.requeue_first.time  = 0.0;

    accum->dt_max_read.queue.time    = 0.00; 
    accum->dt_max_read.insert.time   = 0.00;
    accum->dt_max_read.dispatch.time = 0.00;
    accum->dt_max_read.complete.time = 0.00;
    accum->dt_max_read.requeue.time  = 0.00;
    accum->dt_max_read.d2c_first.time= 0.00;
    accum->dt_max_read.d2c_last.time = 0.00;
    accum->dt_max_read.d2d.time      = 0.00;
    accum->dt_max_read.insert_first.time   = 0.0;
    accum->dt_max_read.dispatch_first.time = 0.0;
    accum->dt_max_read.requeue_first.time  = 0.0;

    accum->dt_min_read.queue.time    = 99999.99; 
    accum->dt_min_read.insert.time   = 99999.99;
    accum->dt_min_read.dispatch.time = 99999.99;
    accum->dt_min_read.complete.time = 99999.99;
    accum->dt_min_read.requeue.time  = 99999.99;
    accum->dt_min_read.d2c_first.time= 99999.99;
    accum->dt_min_read.d2c_last.time = 99999.99;
    accum->dt_min_read.d2d.time      = 99999.99;
    accum->dt_min_read.insert_first.time   = 0.0;
    accum->dt_min_read.dispatch_first.time = 0.0;
    accum->dt_min_read.requeue_first.time  = 0.0;

    accum->dt_tot_writes.queue.time    = 0.00; 
    accum->dt_tot_writes.insert.time   = 0.00;
    accum->dt_tot_writes.dispatch.time = 0.00;
    accum->dt_tot_writes.complete.time = 0.00;
    accum->dt_tot_writes.requeue.time  = 0.00;
    accum->dt_tot_writes.d2c_first.time= 0.00;
    accum->dt_tot_writes.d2c_last.time = 0.00;
    accum->dt_tot_writes.d2d.time      = 0.00;
    accum->dt_tot_writes.insert_first.time   = 0.0;
    accum->dt_tot_writes.dispatch_first.time = 0.0;
    accum->dt_tot_writes.requeue_first.time  = 0.0;

    accum->dt_max_writes.queue.time    = 0.00; 
    accum->dt_max_writes.insert.time   = 0.00;
    accum->dt_max_writes.dispatch.time = 0.00;
    accum->dt_max_writes.complete.time = 0.00;
    accum->dt_max_writes.requeue.time  = 0.00;
    accum->dt_max_writes.d2c_first.time= 0.00;
    accum->dt_max_writes.d2c_last.time = 0.00;
    accum->dt_max_writes.d2d.time      = 0.00;
    accum->dt_max_writes.insert_first.time   = 0.0;
    accum->dt_max_writes.dispatch_first.time = 0.0;
    accum->dt_max_writes.requeue_first.time  = 0.0;

    accum->dt_min_writes.queue.time    = 99999.99; 
    accum->dt_min_writes.insert.time   = 99999.99;
    accum->dt_min_writes.dispatch.time = 99999.99;
    accum->dt_min_writes.complete.time = 99999.99;
    accum->dt_min_writes.requeue.time  = 99999.99;
    accum->dt_min_writes.d2c_first.time= 99999.99;
    accum->dt_min_writes.d2c_last.time = 99999.99;
    accum->dt_min_writes.d2d.time      = 99999.99;
    accum->dt_min_writes.insert_first.time   = 0.0;
    accum->dt_min_writes.dispatch_first.time = 0.0;
    accum->dt_min_writes.requeue_first.time  = 0.0;

    accum->dt_tot_discards.queue.time    = 0.00; 
    accum->dt_tot_discards.insert.time   = 0.00;
    accum->dt_tot_discards.dispatch.time = 0.00;
    accum->dt_tot_discards.complete.time = 0.00;
    accum->dt_tot_discards.requeue.time  = 0.00;
    accum->dt_tot_discards.d2c_first.time= 0.00;
    accum->dt_tot_discards.d2c_last.time = 0.00;
    accum->dt_tot_discards.d2d.time      = 0.00;
    accum->dt_tot_discards.insert_first.time   = 0.0;
    accum->dt_tot_discards.dispatch_first.time = 0.0;
    accum->dt_tot_discards.requeue_first.time  = 0.0;

    accum->dt_max_discards.queue.time    = 0.00; 
    accum->dt_max_discards.insert.time   = 0.00;
    accum->dt_max_discards.dispatch.time = 0.00;
    accum->dt_max_discards.complete.time = 0.00;
    accum->dt_max_discards.requeue.time  = 0.00;
    accum->dt_max_discards.d2c_first.time= 0.00;
    accum->dt_max_discards.d2c_last.time = 0.00;
    accum->dt_max_discards.d2d.time      = 0.00;
    accum->dt_max_discards.insert_first.time   = 0.0;
    accum->dt_max_discards.dispatch_first.time = 0.0;
    accum->dt_max_discards.requeue_first.time  = 0.0;

    accum->dt_min_discards.queue.time    = 99999.99; 
    accum->dt_min_discards.insert.time   = 99999.99;
    accum->dt_min_discards.dispatch.time = 99999.99;
    accum->dt_min_discards.complete.time = 99999.99;
    accum->dt_min_discards.requeue.time  = 99999.99;
    accum->dt_min_discards.d2c_first.time= 99999.99;
    accum->dt_min_discards.d2c_last.time = 99999.99;
    accum->dt_min_discards.d2d.time      = 99999.99;
    accum->dt_min_discards.insert_first.time   = 0.0;
    accum->dt_min_discards.dispatch_first.time = 0.0;
    accum->dt_min_discards.requeue_first.time  = 0.0;

    accum->avgqu_lasttime = 0.00;
    accum->avgqu_weighted = 0.00;
    accum->avgqu_sz       = 0.00;
    accum->avgqu_max      = 0;

    /* accum->cnt_requeues_reads = 0;		*/
    /* accum->cnt_requeues_writes= 0;		*/
    /* accum->cnt_sleep_reads    = 0;		*/
    /* accum->cnt_sleep_writes   = 0;		*/

    accum->inflight;		/* don't change this pass the start of the file */ /* obsolete, is tracked in state structure */
    return(0);
}

/**
 * ==========================================================================================
 * Function : test_sample_time_boundary()
 *            @called at Q,I,D action times to display Q time vs boundary time
 * Args     : @event:      current parsed event info
 *
 * Returns : 0
 *
 * Description
 * This just provides hints and visibility to the issue of the program outputing events at 
 * Completion time but Q/I/D time may have occurred significantly earlier in time, in another
 * second sample time.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int test_sample_time_boundary(typ_io *io)
{ 
    TRACE_FUNCTION;
    xfprintf( outf, "xDBG: current, boundary = %12.9f, %12.9f can only output on 'C' event?\n", io->info->events.first.time, samp.boundary );
     xprintf(       "xDBG: current, boundary = %12.9f, %12.9f can only output on 'C' event?\n", io->info->events.first.time, samp.boundary );
    _return(0);
}


/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * 1) called from output_completed_io(), which is called from flush_postio(), and in turn
 *    this will call stats_samp_output(1) if the time is past the last set boundary time.
 *    aka: flush the per second stats to the appropriate output file. Before we do that
 *    though, we need to add in any additional/appropriate idle time from last io completion
 *    resulting in idle queue until the end of the sample we're flushing. 
 *
 *    the postio queue is needed to delay tossing the io away in case of those
 *    environments which have the main io complete and then one or more of the 
 *    subio (bio) individually complete.  So a completed io is first placed on
 *    the postio queue where is can age out and then cauase output_completed_io()
 *    to be called -- which not only outputs the out but also does the accumulation
 *    thereof.  Since this is "sometime later" after the actual C event that moves
 *    the io to the postio queue, the io event type *must* capture all the data at
 *    move to postio time within the event that it might later need.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int stats_check_boundary( typ_io *io, int handle_idle)
{
int blocks=0;

    TRACE_FUNCTION;
    /* output a series of per second events as needed to catch up to the    */
    /* current point in time... this may span muliple output blocks         */
    /* it is up to stats_samp_ouput() to prevent spamming multiple empty    */
    /* summary blocks -- but we still need the csv data for same.           */
    dprintf( "DBG[%05d]: stats_check_boundary(%12.9f) flg:%d inPrg:%d idle:%d evtime:%12.9f\n", __LINE__,
	samp.boundary, handle_idle, state.inProgress, state.idle_state, state.IEvtTime );
    dprintf( "DBG[%05d]: io event first=%12.9f this %12.9f\n", __LINE__, 
		(io->info != NULL)?io->info->events.first.time:9999.99, io->timeinfo.time );

    /* First handle summ accum block idle as we're going to change state    */
    if ((handle_idle == 1) && (state.inProgress == 0))
    {
	/* NOTE: state.idle_state is set busy @ first A|Q -- but inProgress */
        /*       count is only bumped when the io block is moved to the     */
        /*       mainio queue.  So if above checks are true, perform one    */
        /*       more check... if idle_state is idle, then and only then    */
        /*       update summ idle amount                                    */
        if (state.idle_state == Q_IS_IDLE)
        {
	    summ.dt_idle += (io->timeinfo.time - state.IEvtTime);
	    dprintf( "DBG[%05d]: added summ idle time from %12.9f to %12.9f (%12.9f: total %12.9f)\n", __LINE__,
		state.IEvtTime, io->timeinfo.time, (io->timeinfo.time - state.IEvtTime),
		summ.dt_idle );
	}
    }

    while ( ((io->info != NULL) && (io->info->events.first.time >= samp.boundary)) ||
                                   (io->timeinfo.time           >= samp.boundary))
    {
        /* dump accumulated information and reset */
	/* but first, if handle_idle is set, this io event is either an A|Q */
	/* and is being asked to account for any idle time in this sample   */
        if ((handle_idle == 1) && (state.inProgress == 0))
        {
	    /* This is first A|Q event on other side of per second boundary */
	    /* Split the idle time between the current per second and the   */
	    /* next sample.                                                 */
	    if (state.IEvtTime <= samp.boundary)
	    {
		if (state.idle_state == Q_IS_IDLE)
	        {
	            samp.dt_idle  += (samp.boundary - state.IEvtTime);
	            dprintf( "DBG[%05d]: added samp idle time from %12.9f to %12.9f (%12.9f: total %12.9f)\n", __LINE__,
		        state.IEvtTime, samp.boundary, (samp.boundary - state.IEvtTime), samp.dt_idle );
		}
		state.IEvtTime =  samp.boundary;

	    }
        }
	/* Round up weighted avgque to sample boundary */
        samp.avgqu_weighted  += (samp.boundary -  samp.avgqu_lasttime) * (double)state.inProgress;
        samp.avgqu_lasttime   =  samp.boundary;

        stats_samp_output(1);
	samp.avgqu_lasttime = samp.boundary;
        samp.boundary       = samp.boundary + 1.0000;

        /* Round up weighted avgque from sample boundary to this time of this event, regardless of type */
        samp.avgqu_weighted  += (io->timeinfo.time - samp.avgqu_lasttime) * (double)state.inProgress;
        samp.avgqu_lasttime   =  io->timeinfo.time;
	samp.avgqu_max        = state.inProgress;
    }

    /* now handle any idle time -- whether full or remaining -- in the curr */
    /* samp per second sample                                               */
    if ((handle_idle == 1) && (state.inProgress == 0))
    {
	if (state.idle_state == Q_IS_IDLE)
        {
	    samp.dt_idle     += (io->timeinfo.time - state.IEvtTime);
	    dprintf( "DBG[%05d]: added samp idle time from %12.9f to %12.9f (%12.9f: total %12.9f)\n", __LINE__,
	        state.IEvtTime, io->timeinfo.time, (io->timeinfo.time - state.IEvtTime), samp.dt_idle );
            state.idle_state  = Q_IS_BUSY;
            state.IEvtTime    = io->lstevt.timeinfo.time;
	    dprintf( "DBG[%05d]: queue state set busy @%12.9f, in progress=%d(+1 - not incremented yet)\n", __LINE__, io->timeinfo.time, state.inProgress );
	}
    }
    _return(0);
}


/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int stats_samp_output( int tbc )
{
char styp[8] = "SEC";

    _stats_accum_output(&samp,styp,1);

    /* Add any sample appropriate alerts */
    if ((samp.cnt_requeues > 0) || (samp.cnt_sleeps > 0) || (samp.cnt_barrier_writes > 0) || (samp.cnt_barrier_reads > 0) || (samp.cnt_barrier_discards))
    {
	/* note: the above master counters are *always* incremented on their events */
	/* but the read/write counts associated with same may have cases where      */
        /* neither are updated.  So the logic above gets us to output the alert, but*/
	/* the read,write counts might be displayed as zeros.  In that case look at */
	/* the raw event stream in the dataset as to cause why.                     */
         fprintf( outf, "#%s: --- Alert ---------------------------------------------------------------------------------------------------------------\n", styp );
         if (samp.cnt_sleeps > 0)
             fprintf( outf, "#%s: ALERT %%W-'S'leep   events encountered (%8d reads, %8d writes, %4d discards), this can significantly slow down perceived storage response time! (@%5d secs)\n",
                styp, samp.cnt_sleep_reads,  samp.cnt_sleep_writes, samp.cnt_sleep_discards, (int)(samp.boundary-1.0) );
         if (samp.cnt_requeues > 0)
         {
             fprintf( outf, "#%s: ALERT %%W-'R'equeue events encountered (%8d reads, %8d writes, %4d discards), this can significantly slow down perceived storage response time! (@%5d secs)\n",
                styp, samp.cnt_requeues_reads,  samp.cnt_requeues_writes, samp.cnt_requeues_discards, (int)(samp.boundary-1.0));
             if (chk_use_include_d2d == 0)
             {
                 fprintf( outf, "#%s: ALERT %%W-Add 'include_d2d=1' to ./blktrace.conf recommended if there are a significant number of retries present within the data!%*.*s (@%5d secs)\n",
                    styp, 9,9," ", (int)(samp.boundary-1.0) );
                 chk_use_include_d2d++;
             }
         }
         if ((samp.cnt_barrier_writes > 0) || (samp.cnt_barrier_reads > 0) || (samp.cnt_barrier_discards))
             fprintf( outf, "#%s: ALERT %%W-IOBarrier events encountered (%8d reads, %8d writes, %4d discards), this can significantly slow down perceived storage response time! (@%5d secs)\n",
                styp, samp.cnt_barrier_reads, samp.cnt_barrier_writes, samp.cnt_barrier_discards, (int)(samp.boundary-1.0) );
	 
         fprintf( outf, "#%s: -------------------------------------------------------------------------------------------------------------------------\n", styp );
    }
    fprintf( outf, "#\n");

    if (tbc != 0) output_io_header(outf);
    stats_samp_init();
    return(0);
}


/**
 * ==========================================================================================
 * Function : stats_summ_output - output the accumulated summary output data for the whole file.
 *            @
 * Args     : @flg:          whether to ouptut event header after output.
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int stats_summ_output( int flg )
{
char styp[8] = "SUM";

    _stats_accum_output(&summ,styp,0);

    dump_remaps();

    /* Add ALERTs, if any... */
    if ((summ.cnt_requeues > 0) || (summ.cnt_sleeps > 0) || (state.alerts != 0) || (summ.cnt_discards > 0))
    {
        /* note: the above master counters are *always* incremented on their events */
        /* but the read/write counts associated with same may have cases where      */
        /* neither are updated.  So the logic above gets us to output the alert, but*/
        /* the read,write counts might be displayed as zeros.  In that case look at */
        /* the raw event stream in the dataset as to cause why.                     */
        fprintf( outf, "#%s: --- Alert ---------------------------------------------------------------------------------------------------------------\n", styp );

        if (summ.cnt_sleeps > 0)
             fprintf( outf, "#%s: ALERT %%W-'S'leep   events encountered (%8d reads, %8d writes, %4d discards), this can significantly slow down perceived storage response time!\n",
                styp, summ.cnt_sleep_reads,  summ.cnt_sleep_writes, summ.cnt_sleep_discards );

        if (summ.cnt_requeues > 0)
        {
            fprintf( outf, "#%s: ALERT %%W-'R'equeue events encountered (%8d reads, %8d writes, %4d discards), this can significantly slow down perceived storage response time!\n",
                styp, summ.cnt_requeues_reads,  summ.cnt_requeues_writes, summ.cnt_requeues_discards );
	    /* Always output the include_d2d option alert in summary section */
            fprintf( outf, "#%s: ALERT %%I-Add 'include_d2d=1' to ./blktrace.conf recommended if there are a significant number of retries present within the data!\n", styp );
        }

	if (summ.cnt_messages > 0)
             fprintf( outf, "#%s: ALERT %%W-'m'essage events encountered (%8d total), these may provide additional context for any issues present but otherwise are ignored.\n",
		styp, summ.cnt_messages );

         if ((samp.cnt_barrier_writes > 0) || (samp.cnt_barrier_reads > 0) || (samp.cnt_barrier_discards))
             fprintf( outf, "#%s: ALERT %%W-IOBarrier events encountered (%8d reads, %8d writes, %4d discards ), this can significantly slow down perceived storage response time!\n",
		styp, summ.cnt_barrier_reads, summ.cnt_barrier_writes, summ.cnt_barrier_discards );

	if ((state.alerts & ALERTFLG_UNMATCHED_UNPLUG ) != 0)
	    fprintf( outf, "#%s: DATA  %%I-'U'nplug  events encountered (%8d total), while plug count < unplug count\n", styp, state.alert_cnt_unmatched_u );
	if ((state.alerts & ALERTFLG_NEG_U            ) != 0)
	    fprintf( outf, "#%s: DATA  %%I-'U'nplug  events encountered (%8d total), caused negative (Plug->Unplug) while  P events present in dataset\n", styp, state.alert_cnt_neg_u );
	if ((state.alerts & ALERTFLG_NEG1_U           ) != 0)
	    fprintf( outf, "#%s: DATA  %%I-'U'nplug  events encountered (%8d total), caused negative (Plug->Unplug) but no P events prior within dataset\n", styp, state.alert_cnt_neg1_u );
	if ((state.alerts & ALERTFLG_ZERO_U           ) != 0)
	    fprintf( outf, "#%s: DATA  %%I-'U'nplug  events encountered (%8d total), but no P events prior within dataset\n", styp, state.alert_cnt_zero_u );
	if ((state.alerts & ALERTFLG_ZERO_UT          ) != 0)
	    fprintf( outf, "#%s: DATA  %%I-'UT'unplug/tmo events encounterd (%8d total), but no P events prior within dataset\n", styp, state.alert_cnt_zero_ut );

	if ((state.alerts & ALERTFLG_X360_FORCED      ) != 0)
	    fprintf( outf, "#%s: DATA  %%E-x360 A,D,C matching forced, unpredictable event merging results may have occurred.\n", styp );


	/* Output the following duplicate matching stats, but only if any of the other alerts happened */
	if (state.best_match_contexts > 0)
	    fprintf( outf, "#%s: STATS %%I-%d duplicated request contexts needed best_match() to resolve matching\n", styp, state.best_match_contexts );
	if (state.best_match_checks > 0)
        {
	    fprintf( outf, "#%s: STATS %%I-%d best_match() calls made\n", styp, state.best_match_checks );
	    fprintf( outf, "#%s: STATS %%I-%d best_match() calls resulted in %d high confidence matching\n", styp, state.best_match_checks, state.best_match_high );
	    fprintf( outf, "#%s: STATS %%I-%d best_match() calls resulted in %d good confidence matching\n", styp, state.best_match_checks, state.best_match_good );
	}

	if (state.best_match_special1_contexts > 0)
	    fprintf( outf, "#%s: STATS %%I-%d duplicated 'sched barrier' request contexts needed best_match() to resolve matching\n", styp, state.best_match_special1_contexts );
	if (state.best_match_special1_checks > 0)
        {
	    fprintf( outf, "#%s: STATS %%I-%d best_match_special1() calls made\n", styp, state.best_match_special1_checks );
	    fprintf( outf, "#%s: STATS %%I-%d best_match_special1() calls resulted in %d high confidence matching\n", styp, state.best_match_special1_checks, state.best_match_special1_high );
	    fprintf( outf, "#%s: STATS %%I-%d best_match_special1() calls resulted in %d good confidence matching\n", styp, state.best_match_special1_checks, state.best_match_special1_good );
	    fprintf( outf, "#%s: STATS %%I-%d best_match_special1() calls resulted in %d weak confidence matching\n", styp, state.best_match_special1_checks, state.best_match_special1_weak );
	    fprintf( outf, "#%s: STATS %%I-%d best_match_special1() calls resulted in %d tied matches\n",             styp, state.best_match_special1_checks, state.best_match_special1_ties );
	}

        fprintf( outf, "#%s: -------------------------------------------------------------------------------------------------------------------------\n", styp );
    }
    fprintf( outf, "#\n");

    return(0);
}

/**
 * ==========================================================================================
 * Function : _stats_accum_output -- output specified accumulator data
 *            @
 * Args     : @data:          which accumulator to output, sample or summary
 *            @styp:          string name of the above accumulator to use on printf
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int        _stats_accum_output( typ_accumulator *data, char *styp, int typ )
{
static int iostat_hdr=0;
int device_lvm;
float q2i, q2d, d2d, d2c, q2c;
float ftotal_io, ftotal_complete;
double idle_percent;
int mm, ss, num;


    
    /* dump accumulated information */
    fprintf( outf, "\n"); 

    /* convert all dt to ms                       */
    data->dt_idle *= 1000.0;
    data->util     =  100.0 - ((data->dt_idle * 100.0) / 1000.0);		    /* %util = 100.0% - idle-percentage */
    data->avgqu_sz =    0.0;
    if (data->dt_idle < 1000.0)
    data->avgqu_sz = (data->avgqu_weighted * 1000.0)  / (1000.0 - data->dt_idle);   /* dTime * inProgress / busy-time = avg io depth */

    data->dt_tot_read.insert.time         *= 1000.0;
    data->dt_tot_read.dispatch.time       *= 1000.0;
    data->dt_tot_read.complete.time       *= 1000.0;
    data->dt_tot_read.requeue.time        *= 1000.0;
    data->dt_tot_read.d2c_first.time      *= 1000.0;
    data->dt_tot_read.d2c_last.time       *= 1000.0;
    data->dt_tot_read.d2d.time            *= 1000.0;
    data->dt_tot_read.requeue_first.time  *= 1000.0;
    data->dt_tot_read.insert_first.time   *= 1000.0;
    data->dt_tot_read.dispatch_first.time *= 1000.0;

    data->dt_max_read.insert.time         *= 1000.0;
    data->dt_max_read.dispatch.time       *= 1000.0;
    data->dt_max_read.complete.time       *= 1000.0;
    data->dt_max_read.requeue.time        *= 1000.0;
    data->dt_max_read.d2c_first.time      *= 1000.0;
    data->dt_max_read.d2c_last.time       *= 1000.0;
    data->dt_max_read.d2d.time            *= 1000.0;
    data->dt_max_read.requeue_first.time  *= 1000.0;
    data->dt_max_read.insert_first.time   *= 1000.0;
    data->dt_max_read.dispatch_first.time *= 1000.0;

    data->dt_min_read.insert.time         *= 1000.0;
    data->dt_min_read.dispatch.time       *= 1000.0;
    data->dt_min_read.complete.time       *= 1000.0;
    data->dt_min_read.requeue.time        *= 1000.0;
    data->dt_min_read.d2c_first.time      *= 1000.0;
    data->dt_min_read.d2c_last.time       *= 1000.0;
    data->dt_min_read.d2d.time            *= 1000.0;
    data->dt_min_read.requeue_first.time  *= 1000.0;
    data->dt_min_read.insert_first.time   *= 1000.0;
    data->dt_min_read.dispatch_first.time *= 1000.0;

    data->dt_tot_writes.insert.time       *= 1000.0;
    data->dt_tot_writes.dispatch.time     *= 1000.0;
    data->dt_tot_writes.complete.time     *= 1000.0;
    data->dt_tot_writes.requeue.time      *= 1000.0;
    data->dt_tot_writes.d2c_first.time      *= 1000.0;
    data->dt_tot_writes.d2c_last.time       *= 1000.0;
    data->dt_tot_writes.d2d.time            *= 1000.0;
    data->dt_tot_writes.requeue_first.time  *= 1000.0;
    data->dt_tot_writes.insert_first.time   *= 1000.0;
    data->dt_tot_writes.dispatch_first.time *= 1000.0;

    data->dt_max_writes.insert.time       *= 1000.0;
    data->dt_max_writes.dispatch.time     *= 1000.0;
    data->dt_max_writes.complete.time     *= 1000.0;
    data->dt_max_writes.requeue.time      *= 1000.0;
    data->dt_max_writes.d2c_first.time    *= 1000.0;
    data->dt_max_writes.d2c_last.time     *= 1000.0;
    data->dt_max_writes.d2d.time          *= 1000.0;
    data->dt_max_writes.requeue_first.time  *= 1000.0;
    data->dt_max_writes.insert_first.time   *= 1000.0;
    data->dt_max_writes.dispatch_first.time *= 1000.0;

    data->dt_min_writes.insert.time       *= 1000.0;
    data->dt_min_writes.dispatch.time     *= 1000.0;
    data->dt_min_writes.complete.time     *= 1000.0;
    data->dt_min_writes.requeue.time      *= 1000.0;
    data->dt_min_writes.d2c_first.time    *= 1000.0;
    data->dt_min_writes.d2c_last.time     *= 1000.0;
    data->dt_min_writes.d2d.time          *= 1000.0;
    data->dt_min_writes.requeue_first.time  *= 1000.0;
    data->dt_min_writes.insert_first.time   *= 1000.0;
    data->dt_min_writes.dispatch_first.time *= 1000.0;

    data->dt_tot_discards.insert.time       *= 1000.0;
    data->dt_tot_discards.dispatch.time     *= 1000.0;
    data->dt_tot_discards.complete.time     *= 1000.0;
    data->dt_tot_discards.requeue.time      *= 1000.0;
    data->dt_tot_discards.d2c_first.time      *= 1000.0;
    data->dt_tot_discards.d2c_last.time       *= 1000.0;
    data->dt_tot_discards.d2d.time            *= 1000.0;
    data->dt_tot_discards.requeue_first.time  *= 1000.0;
    data->dt_tot_discards.insert_first.time   *= 1000.0;
    data->dt_tot_discards.dispatch_first.time *= 1000.0;

    data->dt_max_discards.insert.time       *= 1000.0;
    data->dt_max_discards.dispatch.time     *= 1000.0;
    data->dt_max_discards.complete.time     *= 1000.0;
    data->dt_max_discards.requeue.time      *= 1000.0;
    data->dt_max_discards.d2c_first.time    *= 1000.0;
    data->dt_max_discards.d2c_last.time     *= 1000.0;
    data->dt_max_discards.d2d.time          *= 1000.0;
    data->dt_max_discards.requeue_first.time  *= 1000.0;
    data->dt_max_discards.insert_first.time   *= 1000.0;
    data->dt_max_discards.dispatch_first.time *= 1000.0;

    data->dt_min_discards.insert.time       *= 1000.0;
    data->dt_min_discards.dispatch.time     *= 1000.0;
    data->dt_min_discards.complete.time     *= 1000.0;
    data->dt_min_discards.requeue.time      *= 1000.0;
    data->dt_min_discards.d2c_first.time    *= 1000.0;
    data->dt_min_discards.d2c_last.time     *= 1000.0;
    data->dt_min_discards.d2d.time          *= 1000.0;
    data->dt_min_discards.requeue_first.time  *= 1000.0;
    data->dt_min_discards.insert_first.time   *= 1000.0;
    data->dt_min_discards.dispatch_first.time *= 1000.0;

    /* @@@TBD; refactor out device_lvm and device_nvme -- These were used to infer a event stream behavior */
    /*         that is no longer actually required as we added .line capture to validate whether event detected */
    if (((data->dt_tot_read.insert.time   > 0.000000000) && (data->dt_tot_read.dispatch.time   > 0.000000000)) ||
        ((data->dt_tot_writes.insert.time > 0.000000000) && (data->dt_tot_writes.dispatch.time > 0.000000000)) ||
	((data->dt_tot_discards.insert.time>0.000000000) && (data->dt_tot_discards.dispatch.time>0.000000000)))
    {
	/* not an lvm device, has insert/dispatch event times */
	device_lvm=0;
    }
    else
    {
	/* lvm device, no I or D events, just Q & C */
	if (state.device_nvme == 0)
	    device_lvm=1;
    }
    /* @@@ force device_lvm off, depend on .line and other methods */
    device_lvm = 0;


    if (conf_include_d2d == 0)
        fprintf( outf, "#%s: dTime(sec)         Q2I(ms)      Q2D(ms)      D2C(ms)      Q2C(ms;await) io_cnt avrq          KiB  reQ:       seeks prog flt\n", styp );
    else
        fprintf( outf, "#%s: dTime(sec)         Q2I(ms)      Q2D(ms)      D2D(ms)      D2C(ms)      Q2C(ms;await) io_cnt avrq          KiB  reQ:       seeks prog flt\n", styp );

    /* Protect against corner case */
    if ((data->cnt_reads + data->cnt_writes + data->cnt_discards) == 0)
    {
	fprintf( outf, "#%s: no io present to summarize, cnt_reads=%ld cnt_writes=%ld cnt_discards=%ld\n", styp, data->cnt_reads, data->cnt_writes, data->cnt_discards );
        return(0);
    }


    /* TYP: dTime(sec)         Q2I(ms)      Q2D(ms)      D2C(ms)      Q2C(ms;await)  reads avrq      KiB  reQ:writes avrq      KiB  reQ:     seeks prog flt
                          12345678.x12 12345678.x12 12345678.x12 %100 123456789.123 999999 9999 99999999 9999:999999 9999 99999999 9999: 999999999 9999 999
                                12.3        12.3          12.3               13.3   123456 1234 12345678 1234:123456 1234 12345678 9999: 123456789 1234 123

       TYP: dTime(sec)         Q2I(ms)      Q2D(ms)      D2D(ms)      D2C(ms)      Q2C(ms;await)  reads avrq      KiB  reQ:writes avrq      KiB  reQ:     seeks prog flt
                          12345678.x12 12345678.x12 12345678.x12 12345678.x12 %100 12345678.x123 999999 9999 99999999 9999:999999 9999 99999999 9999: 999999999 9999 999
                                12.3        12.3          12.3         12.3              13.4    123456 1234 12345678 1234:123456 1234 12345678 9999: 123456789 1234 123

       TYP: dTime(sec)         Q2I(ms)      Q2D(ms)      D2C(ms)      Q2C(ms;await) io_cnt avrq          KiB  reQ:       seeks prog flt
                          12345678.x12 12345678.x12 12345678.x12 %100 123456789.123 999999 9999 999999999999 9999 999999999999 9999 999
                                12.3        12.3          12.3               13.3   123456 1234 123456789.12 1234 123456789.12 1234 123
    */
    /* 'lvm' devices don't have 'I' or 'D' events -- just 'Q' and 'C' */

    dprintf( "DBG[%05d]: %s %6.0f\n", __LINE__, styp, data->boundary-1.0 );
    dprintf( "DBG[%05d]: cnt_reads    = %ld\n", __LINE__, data->cnt_reads );
    dprintf( "DBG[%05d]: cnt_writes   = %ld\n", __LINE__, data->cnt_writes );
    dprintf( "DBG[%05d]: cnt_discards = %ld\n", __LINE__, data->cnt_discards );
    dprintf( "DBG[%05d]: read, tot_complete = %14.9f\n", __LINE__, data->dt_tot_read.complete.time );
    dprintf( "DBG[%05d]: writ, tot_complete = %14.9f\n", __LINE__, data->dt_tot_writes.complete.time );
    dprintf( "DBG[%05d]: disc, tot_complete = %14.9f\n", __LINE__, data->dt_tot_discards.complete.time );
    d2d = 0.0;
    if (conf_include_d2d == 0)
    {
        q2i = ((device_lvm==0)?( data->dt_tot_read.insert.time   + data->dt_tot_writes.insert.time   + data->dt_tot_discards.insert.time   ):0.0);
        q2d = ((device_lvm==0)?( data->dt_tot_read.dispatch.time + data->dt_tot_writes.dispatch.time + data->dt_tot_discards.dispatch.time ):0.0);
        if (flag_negrequeue == 0) 
	{
            d2c = ((device_lvm==0)?( data->dt_tot_read.d2c_last.time + data->dt_tot_writes.d2c_last.time + data->dt_tot_discards.d2c_last.time):0.0);
	}
	else
	{
	    /* move D2D time from Q2D to D2C but using the dispatch_first field */
            d2c = ((device_lvm==0)?( data->dt_tot_read.d2c_first.time + data->dt_tot_writes.d2c_first.time + data->dt_tot_discards.d2c_first.time ):0.0);
	}
    }
    else
    {
	/* Q2I to be to first insert, not last     */
	/* Q2D to be to first dispatch, not last   */
	/* D2C to remain last dispatch to complete */
	/* D2D to be calculated                    */
        q2i = ((device_lvm==0)?( data->dt_tot_read.insert_first.time   + data->dt_tot_writes.insert_first.time   + data->dt_tot_discards.insert_first.time   ):0.0);
	q2d = ((device_lvm==0)?( data->dt_tot_read.dispatch_first.time + data->dt_tot_writes.dispatch_first.time + data->dt_tot_discards.dispatch_first.time ):0.0);
        d2c = ((device_lvm==0)?( data->dt_tot_read.d2c_last.time       + data->dt_tot_writes.d2c_last.time       + data->dt_tot_discards.d2c_last.time       ):0.0);
        d2d = ((device_lvm==0)?( data->dt_tot_read.d2d.time            - data->dt_tot_writes.d2d.time            + data->dt_tot_discards.d2d.time            ):0.0);
    }
    ftotal_io       = (float)(data->cnt_reads                 + data->cnt_writes                 + data->cnt_discards );
    ftotal_complete =        (data->dt_tot_read.complete.time + data->dt_tot_writes.complete.time+ data->dt_tot_discards.complete.time );


    /* Output accumulated totals... 	*/
    fprintf( outf, "#%s:%6.0f totals  %12.3f %12.3f", styp, data->boundary-1.0, q2i, q2d );
    if (conf_include_d2d != 0) fprintf( outf, " %12.3f", d2d );
    fprintf( outf, " %12.3f %%%3d %13.3f %6ld %4ld %12ld %4ld:%12ld %4ld %3d\n",
              d2c,
       (int)((d2c * 100.0) / ftotal_complete),
       	     ( data->dt_tot_read.complete.time + data->dt_tot_writes.complete.time + data->dt_tot_discards.complete.time ),
	     ( data->cnt_reads + data->cnt_writes + data->cnt_discards ),
             (((data->cnt_reads > 0) ? ((data->blks_read      )/ data->cnt_reads ):0) +
              ((data->cnt_writes> 0) ? ((data->blks_written   )/ data->cnt_writes):0) + 
              ((data->cnt_discards>0)? ((data->blks_discarded )/ data->cnt_discards):0)),
	     ( data->blks_read + data->blks_written + data->blks_discarded) / 2,
             ( data->cnt_requeues_reads  + data->cnt_requeues_writes + data->cnt_requeues_discards ),
              data->seek, data->inflight, state.in_progress );

    /* Output averaged info....		*/
    d2c = d2c / ftotal_io;
    dprintf( "DBG[%05d]: ftotal_complete = %14.9f\n", __LINE__, ftotal_complete );
    dprintf( "DBG[%05d]: ftotal_io = %14.9f\n", __LINE__, ftotal_io );
    dprintf( "DBG[%05d]: dtotal_io = %14ld (%10ld,%10ld,%10ld)\n", __LINE__, (data->cnt_reads+data->cnt_writes+data->cnt_discards), data->cnt_reads, data->cnt_writes, data->cnt_discards);
    fflush(stdout);
   
    fprintf( outf, "#%s:%6.0f tot.avg %12.3f %12.3f", styp, data->boundary-1.0, q2i/ftotal_io, q2d/ftotal_io );
    if (conf_include_d2d != 0) fprintf( outf, " %12.3f", d2d/ftotal_io );
    fprintf( outf, " %12.3f %%%3d %13.3f %6ld %4ld %12ld %4ld:%12ld\n",
              d2c,
       (int)((d2c * 100.0) / (ftotal_complete / ftotal_io)),
	     ((data->dt_tot_read.complete.time + data->dt_tot_writes.complete.time + data->dt_tot_discards.complete.time) / ftotal_io ),
              (data->cnt_reads                 + data->cnt_writes                  + data->cnt_discards                 ),
              (((data->cnt_reads > 0) ? ((data->blks_read      )/ data->cnt_reads ):0) +
               ((data->cnt_writes> 0) ? ((data->blks_written   )/ data->cnt_writes):0) +
              ((data->cnt_discards>0) ? ((data->blks_discarded )/ data->cnt_discards):0)),
	     ((data->blks_read + data->blks_written + data->blks_discarded) / (data->cnt_reads+data->cnt_writes+data->cnt_discards)) / 2,
             ((data->cnt_requeues_reads  + data->cnt_requeues_writes + data->cnt_requeues_discards ) / (data->cnt_reads+data->cnt_writes+data->cnt_discards)),
              (data->seek / (data->cnt_reads+data->cnt_writes+data->cnt_discards)) );

    /* ************************************************************************ */
    /* reads, read.avg, read.max                                                */
    /* ======================================================================== */
    if (conf_include_d2d == 0)
    {
        q2i = data->dt_tot_read.insert.time;
        q2d = data->dt_tot_read.dispatch.time;
        if (flag_negrequeue == 0)
            d2c = ((device_lvm==0)?( data->dt_tot_read.d2c_last.time ):0.0);
        else
            d2c = ((device_lvm==0)?( data->dt_tot_read.d2c_first.time):0.0);
    }
    else
    {
        q2i = data->dt_tot_read.insert_first.time;
        q2d = data->dt_tot_read.dispatch_first.time;
        d2c = ((device_lvm==0)?( data->dt_tot_read.d2c_last.time ):0.0);
        d2d = ((device_lvm==0)?( data->dt_tot_read.d2d.time      ):0.0);
    }
    ftotal_io       = (float)((data->cnt_reads>0)?data->cnt_reads:1);
    ftotal_complete =        ((data->cnt_reads>0)?data->dt_tot_read.complete.time:1.0);
    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
    fprintf( outf, "#%s:%6.0f reads   %12.3f %12.3f", styp, data->boundary-1.0, q2i/ftotal_io, q2d/ftotal_io );
    if (conf_include_d2d != 0) fprintf( outf, " %12.3f", d2d/ftotal_io );
    fprintf( outf, " %12.3f %%%3d %13.3f %6d %4d %12d %4d\n",
              d2c,
       (int)((d2c * 100.0) / ftotal_complete),
	        data->dt_tot_read.complete.time,
		data->cnt_reads,
              ((data->cnt_reads > 0) ? (data->blks_read / data->cnt_reads ):0),
		data->blks_read / 2,
		data->cnt_requeues_reads );

    d2c = d2c / ftotal_io;
    fprintf( outf, "#%s:%6.0f rd.avg  %12.3f %12.3f", styp, data->boundary-1.0, q2i/ftotal_io, q2d/ftotal_io );
    if (conf_include_d2d != 0) fprintf( outf, " %12.3f", d2d/ftotal_io );
    if (data->cnt_reads > 0)
    fprintf( outf, " %12.3f %%%3d %13.3f %6ld %4ld %12d %4ld\n",
              d2c,
       (int)((d2c * 100.0) / (ftotal_complete  / ftotal_io)),
             (( data->dt_tot_read.complete.time / (float)data->cnt_reads    )),
                data->cnt_reads,
             (( data->blks_read                 /        data->cnt_reads    )),
                data->blks_read / 2,
                data->cnt_requeues_reads );
    else
    fprintf( outf, " %12.3f %%%3d %13.3f %6ld %4ld %12ld %4ld\n", 0.0, 0, 0.0, 0, 0, 0, 0);

    /* Recalculating route... for max read info */
    if (conf_include_d2d == 0)
    {
        q2i = data->dt_max_read.insert.time;
        q2d = data->dt_max_read.dispatch.time;
        if (flag_negrequeue == 0)
            d2c = ((device_lvm==0)?( data->dt_max_read.d2c_last.time ):0.0);
        else
            d2c = ((device_lvm==0)?( data->dt_max_read.d2c_first.time): 0.0);
    }
    else
    {
        /* Q2I to be to first insert, not last     */
        /* Q2D to be to first dispatch, not last   */
        /* D2C to remain last dispatch to complete */
        /* D2D to be calculated                    */
        q2i = ((device_lvm==0)?( data->dt_max_read.insert_first.time  ):0.0);
        q2d = ((device_lvm==0)?( data->dt_max_read.dispatch_first.time):0.0);
        d2c = ((device_lvm==0)?( data->dt_max_read.d2c_last.time      ):0.0);
        d2d = ((device_lvm==0)?( data->dt_tot_read.d2d.time           ):0.0);
    }
    fprintf( outf, "#%s:%6.0f rd.max  %12.3f %12.3f", styp, data->boundary-1.0, q2i, q2d );
    if (conf_include_d2d != 0) fprintf( outf, " %12.3f", d2d );
    fprintf( outf, " %12.3f %%%3d %13.3f \n",
	      d2c,
       (int)((d2c * 100.0) / (data->dt_max_read.complete.time>0?data->dt_max_read.complete.time:1)),
	 (float)data->dt_max_read.complete.time );

    /* ************************************************************************ */
    /* writes, write.avg, write.max 						*/
    /* ======================================================================== */
    if (conf_include_d2d == 0)
    {
        q2i = data->dt_tot_writes.insert.time;
        q2d = data->dt_tot_writes.dispatch.time;
        if (flag_negrequeue == 0)
            d2c = ((device_lvm==0)?( data->dt_tot_writes.d2c_last.time ):0.0);
        else
            d2c = ((device_lvm==0)?( data->dt_tot_writes.d2c_first.time):0.0);
    }
    else
    {
        q2i = data->dt_tot_writes.insert_first.time;
        q2d = data->dt_tot_writes.dispatch_first.time;
        d2c = ((device_lvm==0)?( data->dt_tot_writes.d2c_last.time ):0.0);
        d2d = ((device_lvm==0)?( data->dt_tot_writes.d2d.time      ):0.0);
    }
    ftotal_io       = (float)((data->cnt_writes>0)?data->cnt_writes:1);
    ftotal_complete =        ((data->cnt_writes>0)?data->dt_tot_writes.complete.time:1.0);
    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
    fprintf( outf, "#%s:%6.0f writes  %12.3f %12.3f", styp, data->boundary-1.0, q2i/ftotal_io, q2d/ftotal_io );
    if (conf_include_d2d != 0) fprintf( outf, " %12.3f", d2d/ftotal_io );
    fprintf( outf, " %12.3f %%%3d %13.3f %6d %4d %12d %4d\n",
              d2c,
       (int)((d2c * 100.0) / ftotal_complete),
	        data->dt_tot_writes.complete.time,
		data->cnt_writes,
              ((data->cnt_writes > 0) ? (data->blks_written / data->cnt_writes ):0),
		data->blks_written / 2,
		data->cnt_requeues_writes );

    d2c = d2c / ftotal_io;
    fprintf( outf, "#%s:%6.0f wr.avg  %12.3f %12.3f", styp, data->boundary-1.0, q2i/ftotal_io, q2d/ftotal_io );
    if (conf_include_d2d != 0) fprintf( outf, " %12.3f", d2d/ftotal_io );
    if (data->cnt_writes > 0)
    fprintf( outf, " %12.3f %%%3d %13.3f %6ld %4ld %12d %4ld\n",
              d2c,
       (int)((d2c * 100.0) / (ftotal_complete / ftotal_io)),
             ((data->dt_tot_writes.complete.time / (float)data->cnt_writes    )),
             data->cnt_writes,
             (( data->blks_written          /        data->cnt_writes    )),
                data->blks_written / 2,
                data->cnt_requeues_writes );
    else
    fprintf( outf, " %12.3f %%%3d %13.3f %6ld %4ld %12ld %4ld\n", 0.0, 0, 0.0, 0, 0, 0, 0);

    /* Recalculating route... for max write info */
    if (conf_include_d2d == 0)
    {
        q2i = data->dt_max_writes.insert.time;
        q2d = data->dt_max_writes.dispatch.time;
        if (flag_negrequeue == 0)
            d2c = ((device_lvm==0)?( data->dt_max_writes.d2c_last.time ):0.0);
        else
            d2c = ((device_lvm==0)?( data->dt_max_writes.d2c_first.time):0.0);
    }
    else
    {
        /* Q2I to be to first insert, not last     */
        /* Q2D to be to first dispatch, not last   */
        /* D2C to remain last dispatch to complete */
        /* D2D to be calculated                    */
        q2i = ((device_lvm==0)?( data->dt_max_writes.insert_first.time  ):0.0);
        q2d = ((device_lvm==0)?( data->dt_max_writes.dispatch_first.time):0.0);
        d2c = ((device_lvm==0)?( data->dt_max_writes.d2c_last.time      ):0.0);
        d2d = ((device_lvm==0)?( data->dt_tot_writes.d2d.time           ):0.0);
    }
    fprintf( outf, "#%s:%6.0f wr.max  %12.3f %12.3f", styp, data->boundary-1.0, q2i, q2d );
    if (conf_include_d2d != 0) fprintf( outf, " %12.3f", d2d );
    fprintf( outf, " %12.3f %%%3d %13.3f \n",
	      d2c,
       (int)((d2c * 100.0) / (data->dt_max_writes.complete.time>0?data->dt_max_writes.complete.time:1)),
	(float)data->dt_max_writes.complete.time );


    /* ************************************************************************ */
    /* discards, discard.avg, discard.max					*/
    /* ======================================================================== */
    if (conf_include_d2d == 0)
    {
        q2i = data->dt_tot_discards.insert.time;
        q2d = data->dt_tot_discards.dispatch.time;
        if (flag_negrequeue == 0)
            d2c = ((device_lvm==0)?( data->dt_tot_discards.d2c_last.time ):0.0);
        else
            d2c = ((device_lvm==0)?( data->dt_tot_discards.d2c_first.time):0.0);
    }
    else
    {
        q2i = data->dt_tot_discards.insert_first.time;
        q2d = data->dt_tot_discards.dispatch_first.time;
        d2c = ((device_lvm==0)?( data->dt_tot_discards.d2c_last.time ):0.0);
        d2d = ((device_lvm==0)?( data->dt_tot_discards.d2d.time      ):0.0);
    }
    ftotal_io       = (float)((data->cnt_discards>0)?data->cnt_discards:1);
    ftotal_complete =        ((data->cnt_discards>0)?data->dt_tot_discards.complete.time:1.0);
    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
    fprintf( outf, "#%s:%6.0f discard %12.3f %12.3f", styp, data->boundary-1.0, q2i/ftotal_io, q2d/ftotal_io );
    if (conf_include_d2d != 0) fprintf( outf, " %12.3f", d2d/ftotal_io );
    fprintf( outf, " %12.3f %%%3d %13.3f %6d %4d %12d %4d\n",
              d2c,
       (int)((d2c * 100.0) / ftotal_complete),
	        data->dt_tot_discards.complete.time,
		data->cnt_discards,
              ((data->cnt_discards > 0) ? (data->blks_discarded / data->cnt_discards ):0),
		data->blks_discarded / 2,
		data->cnt_requeues_discards );

    d2c = d2c / ftotal_io;
    fprintf( outf, "#%s:%6.0f dx.avg  %12.3f %12.3f", styp, data->boundary-1.0, q2i/ftotal_io, q2d/ftotal_io );
    if (conf_include_d2d != 0) fprintf( outf, " %12.3f", d2d/ftotal_io );
    if (data->cnt_discards > 0)
    fprintf( outf, " %12.3f %%%3d %13.3f %6ld %4ld %12d %4ld\n",
              d2c,
       (int)((d2c * 100.0) / (ftotal_complete / ftotal_io)),
             ((data->dt_tot_discards.complete.time / (float)data->cnt_discards    )),
             data->cnt_discards,
             (( data->blks_discarded          /        data->cnt_discards    )),
                data->blks_discarded / 2,
                data->cnt_requeues_discards );
    else
    fprintf( outf, " %12.3f %%%3d %13.3f %6ld %4ld %12ld %4ld\n", 0.0, 0, 0.0, 0, 0, 0, 0);

    /* Recalculating route... for max discard info */
    if (conf_include_d2d == 0)
    {
        q2i = data->dt_max_discards.insert.time;
        q2d = data->dt_max_discards.dispatch.time;
        if (flag_negrequeue == 0)
            d2c = ((device_lvm==0)?( data->dt_max_discards.d2c_last.time ):0.0);
        else
            d2c = ((device_lvm==0)?( data->dt_max_discards.d2c_first.time):0.0);
    }
    else
    {
        /* Q2I to be to first insert, not last     */
        /* Q2D to be to first dispatch, not last   */
        /* D2C to remain last dispatch to complete */
        /* D2D to be calculated                    */
        q2i = ((device_lvm==0)?( data->dt_max_discards.insert_first.time  ):0.0);
        q2d = ((device_lvm==0)?( data->dt_max_discards.dispatch_first.time):0.0);
        d2c = ((device_lvm==0)?( data->dt_max_discards.d2c_last.time      ):0.0);
        d2d = ((device_lvm==0)?( data->dt_tot_discards.d2d.time           ):0.0);
    }
    fprintf( outf, "#%s:%6.0f dx.max  %12.3f %12.3f", styp, data->boundary-1.0, q2i, q2d );
    if (conf_include_d2d != 0) fprintf( outf, " %12.3f", d2d );
    fprintf( outf, " %12.3f %%%3d %13.3f \n",
	      d2c,
       (int)((d2c * 100.0) / (data->dt_max_discards.complete.time>0?data->dt_max_discards.complete.time:1)),
	(float)data->dt_max_discards.complete.time );





    idle_percent = (data->dt_idle * 100.0) / 1000.0;
    fprintf( outf, "#%s:%6.0f idle        %8.3fms (idle:%%%6.2f, busy:%%%6.2f)\n", styp, data->boundary-1.0, data->dt_idle, idle_percent, 100.0 - idle_percent );





    ss = (int)(data->boundary-1.0) + conf_base_seconds;
    mm = ss / 60;
    ss = ss % 60;
    if (((strcmp(styp,"SEC") == 0) && (iostat_hdr++ == 0)) || (strcmp(styp,"SEC") != 0))
    {
    /* 
     * Old formats:
    fprintf( outf, "#%s@MM:SS  tot/s    r/s    w/s   tkB/s   rkB/s   wkB/s    avrq qusz    await|disk  r_await|disk  w_await|disk   %%busy  :: #reQ #Slp\n", styp );
    fprintf( outf, "#%s@-----+------+------+------+-------+-------+-------+-------+----+--------|----+--------|----+--------|----+---------::-----+----+\n", styp );

    fprintf( outf, "#%s@MM:SS|  tot/s    r/s    w/s|   tkB/s   rkB/s   wkB/s|    avrq  qusz:max |    await:disk |  r_await:disk |  w_await:disk | Eff.   |  %%busy | #reQ #Slp #Bar\n", styp );
    fprintf( outf, "#%s@-----|-------+------+------|--------+-------+-------|--------+-----:----|---------:-----|---------:-----|---------:-----|--------|--------|-----+----+----+\n", styp );
     */
    fprintf( outf, "#%s@MM:SS|  tot/s    r/s    w/s    d/s|   tkB/s   rkB/s   wkB/s   dkB/s|    avrq  qusz:max |    await:disk |  r_await:disk |  w_await:disk | d_await:disk  | Eff.   |  %%busy | #reQ #Slp #Bar\n", styp );
    fprintf( outf, "#%s@-----|-------+------+------+------|--------+-------+-------+-------|--------+-----:----|---------:-----|---------:-----|---------:-----|---------:-----|--------|--------|-----+----+----+\n", styp );
    }
    fprintf( outf, "#%s@%02d:%02d|", styp, mm, ss );
    fprintf( outf, " %6d %6d %6d %6d|" , data->cnt_reads + data->cnt_writes + data->cnt_discards, data->cnt_reads, data->cnt_writes, data->cnt_discards );
    fprintf( outf, " %7d %7d %7d %7d|", (data->blks_read + data->blks_written + data->blks_discarded) / 2, data->blks_read/2, data->blks_written/2, data->blks_discarded/2 );
    fprintf( outf, " %7.2f %5.1f %3d |", ((float)(data->blks_read + data->blks_written + data->blks_discarded)) / ((float)(data->cnt_reads + data->cnt_writes + data->cnt_discards)), data->avgqu_sz, data->avgqu_max );

    d2d = 0.0;
    if (conf_include_d2d == 0)
    {
        if (flag_negrequeue == 0)
        {
            d2c = ((device_lvm==0)?( data->dt_tot_read.d2c_last.time + data->dt_tot_writes.d2c_last.time + data->dt_tot_discards.d2c_last.time ):0.0);
        }
        else
        {
            /* move D2D time from Q2D to D2C but using the dispatch_first field */
            d2c = ((device_lvm==0)?( data->dt_tot_read.d2c_first.time+ data->dt_tot_writes.d2c_first.time+ data->dt_tot_discards.d2c_first.time):0.0);
        }
    }
    else
    {
        d2c = ((device_lvm==0)?( data->dt_tot_read.d2c_last.time + data->dt_tot_writes.d2c_last.time + data->dt_tot_discards.d2c_last.time ):0.0);
        d2d = ((device_lvm==0)?( data->dt_tot_read.d2d.time      + data->dt_tot_writes.d2d.time      + data->dt_tot_discards.d2d.time      ):0.0);
    }
    q2c = (data->dt_tot_read.complete.time + data->dt_tot_writes.complete.time + data->dt_tot_discards.complete.time );
    num = data->cnt_reads + data->cnt_writes + data->cnt_discards;
    fprintf( outf, " %8.2f %3.0f%% |", q2c/(float)num, (q2c<=0.0001)?0.0:(((d2c+d2d)*100.0)/q2c) );


    d2d = 0.0;
    d2c = 0.0;
    if (conf_include_d2d == 0)
    {
        if (flag_negrequeue == 0)
            d2c = ((device_lvm==0)?( data->dt_tot_read.d2c_last.time ):0.0);
        else
            d2c = ((device_lvm==0)?( data->dt_tot_read.d2c_first.time):0.0);
    }
    else
    {
        d2c = ((device_lvm==0)?( data->dt_tot_read.d2c_last.time ):0.0);
        d2d = ((device_lvm==0)?( data->dt_tot_read.d2d.time      ):0.0);
    }
    q2c = (data->dt_tot_read.complete.time);
    num = (data->cnt_reads>0)?data->cnt_reads:1;
    fprintf( outf, " %8.2f %3.0f%% |", q2c/(float)num, (q2c<=0.0001)?0.0:(((d2c+d2d)*100.0)/q2c) );


    d2d = 0.0;
    d2c = 0.0;
    if (conf_include_d2d == 0)
    {
        if (flag_negrequeue == 0)
            d2c = ((device_lvm==0)?( data->dt_tot_writes.d2c_last.time ):0.0);
        else
            d2c = ((device_lvm==0)?( data->dt_tot_writes.d2c_first.time):0.0);
    }
    else
    {
        d2c = ((device_lvm==0)?( data->dt_tot_writes.d2c_last.time ):0.0);
        d2d = ((device_lvm==0)?( data->dt_tot_writes.d2d.time      ):0.0);
    }
    q2c = (data->dt_tot_writes.complete.time);
    num = (data->cnt_writes>0)?data->cnt_writes:1;
    fprintf( outf, " %8.2f %3.0f%% |", q2c/(float)num, (q2c<=0.0001)?0.0:(((d2c+d2d)*100.0)/q2c) );

    d2d = 0.0;
    d2c = 0.0;
    if (conf_include_d2d == 0)
    {
        if (flag_negrequeue == 0)
            d2c = ((device_lvm==0)?( data->dt_tot_discards.d2c_last.time ):0.0);
        else
            d2c = ((device_lvm==0)?( data->dt_tot_discards.d2c_first.time):0.0);
    }
    else
    {
        d2c = ((device_lvm==0)?( data->dt_tot_discards.d2c_last.time ):0.0);
        d2d = ((device_lvm==0)?( data->dt_tot_discards.d2d.time      ):0.0);
    }
    q2c = (data->dt_tot_discards.complete.time );
    num = (data->cnt_discards>0)?data->cnt_discards:1;
    fprintf( outf, " %8.2f %3.0f%% |", q2c/(float)num, (q2c<=0.0001)?0.0:(((d2c+d2d)*100.0)/q2c) );


    fprintf( outf,  "%7.2f |", ftotal_io<1.00?0.0:((1000.0 - data->dt_idle) / ftotal_io) );
    fprintf( outf, " %6.2f |", 100.0 - idle_percent );
    fprintf( outf, " %4d %4d %4d\n", 
        data->cnt_requeues_reads + data->cnt_requeues_writes + data->cnt_requeues_discards,
	data->cnt_sleep_reads    + data->cnt_sleep_writes    + data->cnt_sleep_discards, 
	data->cnt_barrier_reads  + data->cnt_barrier_writes  + data->cnt_barrier_discards );


    return(0);
}

/**
 * ==========================================================================================
 * Function : stats_samp_accumio
 *            @
 * Args     : @io:         completing io context to account for
 *
 * Returns :
 *
 * Description
 * There are two sets of statistical accumulators, 'samp' for 1 second samples that is reset
 * after each sample, and 'summ' which is for the whole file and is never reset.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int stats_samp_accumio(typ_io *io)
{
static int _first = 0;
char *ptr;
long seek;
double idle;
typ_actions *events;

#define STAT( _val, _base, _field ) \
samp.dt_tot_##_base._field.time += _val;\
if (_val > samp.dt_max_##_base._field.time) samp.dt_max_##_base._field.time = _val;\
if (_val < samp.dt_min_##_base._field.time) samp.dt_min_##_base._field.time = _val

    if (_first == 0)
    {
	_first++;
	stats_samp_init();
	samp.boundary = trunc(io->info->events.first.time) + 1.0000;
	state.last_completed_sector    = io->sector - io->length;
        state.last_completed_length    = io->length;
        state.last_queue_t             = io->info->events.first.time;
        state.IEvtTime                 = 0.0;
        state.idle_state               = Q_IS_IDLE;
        state.avgqu_lasttime           = 0.0;
	state.avgqu_weighted           = 0.0;
    }


    /* in ascending order:
     * read       = IOTYP_READ
     * write      = IOTYP_WRITE, IOTYP_META, IOTYP_BARRIER
     * discard    = IOTYP_DISCARD, @@@TBD
     */
    if ((io->prmtyp == IOTYP_READ) || (io->prmtyp >= IOTYP_WRITE))
    {
	/* known read/write io type(s):: ok to use/accumulate below */
    }
    else
    {
        /* These should be screened off before calling here(???)... */
	xprintf( "event ptr %016lX\n", io );
	xprintf( "event %d,%d seq=%d time=%12.9f pid=%d act='%c' iotyp='%s' %d:%ld,%ld\n",
		io->lstevt.major, io->lstevt.minor, io->lstevt.cpu, io->lstevt.seqnum, io->lstevt.timeinfo.time,
		io->lstevt.pid, io->lstevt.prmact, io->lstevt.evttyp, io->lstevt.evtflags, io->sector, io->length );
	logFprintf( "%%F-BUG: type not read or write? event type = '%s'\n", io->lstevt.evttyp );
	PROG_FEATURE_FAULT(NULL,(int),"target io neither read or write?",CTL_FAULT_FORCE);
    }

    /* Accumulation of idle time is handled at A|Q time, just after create_io()                        */ 

    /* this logic is sketchy at best, typically will only work with single stream, non-overlapping io! */
    /* what we really should track is seek at Q and C times separately... and seek at C time is prolly */
    /* more accurate for single disk rotating media.  But so few times any more is a "disk" really a   */
    /* single physical disk -- more likely a portion of a RAID'd disk in storage, thin mapping volume, */
    /* or some other type of data container like NVMe or SSD such that seek distance ends up quickly a */
    /* meaningless value at best or misleading at worse. Still localality of reference is often a sign */
    /* of a well architected application suite so track as best can                                    */
    seek = (io->sector - (state.last_completed_sector + state.last_completed_length));
    samp.seek         += abs(seek);

    if (io->prmtyp == IOTYP_READ)
    {
        samp.cnt_reads++;
        samp.blks_read   += io->length;

        events = &io->info->events;
	STAT( ((events->insert.line         != 0)?(events->insert.time         - events->first.time):0.0), read, insert   );   /* Q2I, last insert   */
	STAT( ((events->dispatch.line       != 0)?(events->dispatch.time       - events->first.time):0.0), read, dispatch );   /* Q2D, last dispatch */
	STAT( ((events->complete.line       != 0)?(events->complete.time       - events->first.time):0.0), read, complete );   /* Q2C                */
	STAT( ((events->requeue.line        != 0)?(events->requeue.time        - events->first.time):0.0), read, requeue  );

	STAT( ((events->requeue_first.line  != 0)?(events->requeue_first.time  - events->first.time):0.0), read, requeue_first );
	STAT( ((events->insert_first.line   != 0)?(events->insert_first.time   - events->first.time):0.0), read,  insert_first ); /* Q2I, first insert   */
	STAT( ((events->dispatch_first.line != 0)?(events->dispatch_first.time - events->first.time):0.0), read, dispatch_first); /* Q2D, first dispatch */

	if (events->complete.line           != 0)
        {
	STAT( ((events->dispatch.line       != 0)?(events->complete.time - events->dispatch.time      ):0.0), read, d2c_last   ); /* D2C, last dispatch  */
	STAT( ((events->dispatch_first.line != 0)?(events->complete.time - events->dispatch_first.time):0.0), read, d2c_first  ); /* D2C, first dispatch */
	STAT( ((events->dispatch_first.line != 0)?(events->dispatch.time - events->dispatch_first.time):0.0), read, d2d        ); /* D2D, first to last  */
	}

	/* @@@@@@@@ */
	if ((samp.dt_tot_read.insert.time < 0.0) ||
	    (samp.dt_tot_read.dispatch.time < 0.0) ||
	    (samp.dt_tot_read.insert_first.time  < 0.0) ||
	    (samp.dt_tot_read.dispatch_first.time < 0.0))
	{
	fprintf( outf, "DBG[%05d]:%5d insert   %13.9f %13.9f %13.9f\n", __LINE__, 
			events->insert.line, events->insert.time,   events->first.time, (events->insert.time   - events->first.time));
	fprintf( outf, "DBG[%05d]:%5d dispatch %13.9f %13.9f %13.9f\n", __LINE__, 
			events->dispatch.line, events->dispatch.time, events->first.time, (events->dispatch.time - events->first.time));
        fprintf( outf, "DBG[%05d]: %d    d_read  %13.9f     %13.9f                         %13.9f lines: %5d,%5d (first)\n", __LINE__, state.device_nvme,
                        samp.dt_tot_read.insert_first.time ,
                        samp.dt_tot_read.dispatch_first.time ,
                        samp.dt_tot_read.complete.time,
	                events->insert_first.line, events->dispatch_first.line  );
        fprintf( outf, "DBG[%05d]: %d  tot_read  %13.9f     %13.9f                         %13.9f lines: %5d,%5d\n", __LINE__, state.device_nvme,
			samp.dt_tot_read.insert.time ,
			samp.dt_tot_read.dispatch.time ,
			samp.dt_tot_read.complete.time,
			events->insert.line, events->dispatch.line );
	}
			

	/* D2D time can be calculated via dispatch - dispatch_first */
    }
    else if ((io->prmtyp >= IOTYP_WRITE) && (io->prmtyp != IOTYP_DISCARD))
    {
        samp.cnt_writes++;
        samp.blks_written += io->length;

        events = &io->info->events;
	STAT( ((events->insert.line         != 0)?(events->insert.time         - events->first.time):0.0), writes, insert   );   /* Q2I, last insert   */
	STAT( ((events->dispatch.line       != 0)?(events->dispatch.time       - events->first.time):0.0), writes, dispatch );   /* Q2D, last dispatch */
	STAT( ((events->complete.line       != 0)?(events->complete.time       - events->first.time):0.0), writes, complete );   /* Q2C                */
	STAT( ((events->requeue.line        != 0)?(events->requeue.time        - events->first.time):0.0), writes, requeue  );

	STAT( ((events->requeue_first.line  != 0)?(events->requeue_first.time  - events->first.time):0.0), writes, requeue_first );
	STAT( ((events->insert_first.line   != 0)?(events->insert_first.time   - events->first.time):0.0), writes,  insert_first ); /* Q2I, first insert   */
	STAT( ((events->dispatch_first.line != 0)?(events->dispatch_first.time - events->first.time):0.0), writes, dispatch_first); /* Q2d, first dispatch */

	if (events->complete.line           != 0)
        {
	STAT( ((events->dispatch.line       != 0)?(events->complete.time - events->dispatch.time      ):0.0), writes, d2c_last   ); /* D2C, last dispatch  */
	STAT( ((events->dispatch_first.line != 0)?(events->complete.time - events->dispatch_first.time):0.0), writes, d2c_first  ); /* D2C, first dispatch */
	STAT( ((events->dispatch_first.line != 0)?(events->dispatch.time - events->dispatch_first.time):0.0), writes, d2d        ); /* D2D, first to last  */
	}

	/* @@@@@@@@ */
	if ((samp.dt_tot_writes.insert.time < 0.0) ||
	    (samp.dt_tot_writes.dispatch.time < 0.0) ||
            (samp.dt_tot_writes.insert_first.time  < 0.0) ||
            (samp.dt_tot_writes.dispatch_first.time < 0.0))
        {
	fprintf( outf, "DBG[%05d]:%5d insert   %13.9f %13.9f %13.9f\n", __LINE__, 
			events->insert.line, events->insert.time,   events->first.time, (events->insert.time   - events->first.time));
	fprintf( outf, "DBG[%05d]:%5d dispatch %13.9f %13.9f %13.9f\n", __LINE__, 
			events->dispatch.line, events->dispatch.time, events->first.time, (events->dispatch.time - events->first.time));
        fprintf( outf, "DBG[%05d]: %d    d_writ  %13.9f     %13.9f                         %13.9f lines: %5d,%5d (first)\n", __LINE__, state.device_nvme,
                        samp.dt_tot_writes.insert_first.time ,
                        samp.dt_tot_writes.dispatch_first.time ,
                        samp.dt_tot_writes.complete.time,
	                events->insert_first.line, events->dispatch_first.line  );
        fprintf( outf, "DBG[%05d]: %d  tot_writ  %13.9f     %13.9f                         %13.9f lines: %5d,%5d\n", __LINE__, state.device_nvme,
			samp.dt_tot_writes.insert.time ,
			samp.dt_tot_writes.dispatch.time ,
			samp.dt_tot_writes.complete.time,
			events->insert.line, events->dispatch.line );
	}
    }
    else if (io->prmtyp == IOTYP_DISCARD)
    {
        samp.cnt_discards++;
        samp.blks_discarded += io->length;

        events = &io->info->events;
	STAT( ((events->insert.line         != 0)?(events->insert.time         - events->first.time):0.0), discards, insert   );   /* Q2I, last insert   */
	STAT( ((events->dispatch.line       != 0)?(events->dispatch.time       - events->first.time):0.0), discards, dispatch );   /* Q2D, last dispatch */
	STAT( ((events->complete.line       != 0)?(events->complete.time       - events->first.time):0.0), discards, complete );   /* Q2C                */
	STAT( ((events->requeue.line        != 0)?(events->requeue.time        - events->first.time):0.0), discards, requeue  );

	STAT( ((events->requeue_first.line  != 0)?(events->requeue_first.time  - events->first.time):0.0), discards, requeue_first );
	STAT( ((events->insert_first.line   != 0)?(events->insert_first.time   - events->first.time):0.0), discards,  insert_first ); /* Q2I, first insert   */
	STAT( ((events->dispatch_first.line != 0)?(events->dispatch_first.time - events->first.time):0.0), discards, dispatch_first); /* Q2d, first dispatch */

	if (events->complete.line           != 0)
        {
	STAT( ((events->dispatch.line       != 0)?(events->complete.time - events->dispatch.time      ):0.0), discards, d2c_last   ); /* D2C, last dispatch  */
	STAT( ((events->dispatch_first.line != 0)?(events->complete.time - events->dispatch_first.time):0.0), discards, d2c_first  ); /* D2C, first dispatch */
	STAT( ((events->dispatch_first.line != 0)?(events->dispatch.time - events->dispatch_first.time):0.0), discards, d2d        ); /* D2D, first to last  */
	}

	/* @@@@@@@@ */
	if ((samp.dt_tot_discards.insert.time < 0.0) ||
	    (samp.dt_tot_discards.dispatch.time < 0.0) ||
            (samp.dt_tot_discards.insert_first.time  < 0.0) ||
            (samp.dt_tot_discards.dispatch_first.time < 0.0))
        {
	fprintf( outf, "DBG[%05d]:%5d insert   %13.9f %13.9f %13.9f\n", __LINE__, 
			events->insert.line, events->insert.time,   events->first.time, (events->insert.time   - events->first.time));
	fprintf( outf, "DBG[%05d]:%5d dispatch %13.9f %13.9f %13.9f\n", __LINE__, 
			events->dispatch.line, events->dispatch.time, events->first.time, (events->dispatch.time - events->first.time));
        fprintf( outf, "DBG[%05d]: %d    d_writ  %13.9f     %13.9f                         %13.9f lines: %5d,%5d (first)\n", __LINE__, state.device_nvme,
                        samp.dt_tot_discards.insert_first.time ,
                        samp.dt_tot_discards.dispatch_first.time ,
                        samp.dt_tot_discards.complete.time,
	                events->insert_first.line, events->dispatch_first.line  );
        fprintf( outf, "DBG[%05d]: %d  tot_writ  %13.9f     %13.9f                         %13.9f lines: %5d,%5d\n", __LINE__, state.device_nvme,
			samp.dt_tot_discards.insert.time ,
			samp.dt_tot_discards.dispatch.time ,
			samp.dt_tot_discards.complete.time,
			events->insert.line, events->dispatch.line );
	}
    }
    else
    {
	samp.cnt_others++;
    }
    samp.avgqu_weighted;
    samp.inflight;		/* don't change this pass the start of the file */

    dprintf( "DBG[%05d]: Samples: reads  Q2I          Q2D          D2C          Q2C         writes  Q2I          Q2D          D2C          Q2C\n", __LINE__ );
    dprintf( "DBG[%05d]:          %5d %12.9f %12.9f %12.9f %12.9f  ", __LINE__, 
        samp.cnt_reads, samp.dt_tot_read.insert.time,
                        samp.dt_tot_read.dispatch.time,
                        samp.dt_tot_read.complete.time - samp.dt_tot_read.dispatch.time,
                        samp.dt_tot_read.complete.time );
    dprintf(                   "%5d %12.9f %12.9f %12.9f %12.9f\n",
        samp.cnt_writes, samp.dt_tot_writes.insert.time,
                        samp.dt_tot_writes.dispatch.time, 
                        samp.dt_tot_writes.complete.time - samp.dt_tot_writes.dispatch.time,
                        samp.dt_tot_writes.complete.time );
    if (samp.cnt_discards != 0)
    {
    dprintf( "DBG[%05d]: Samples: discs  Q2I          Q2D          D2C          Q2C         \n", __LINE__ );
    dprintf( "DBG[%05d]:          %5d %12.9f %12.9f %12.9f %12.9f  ", __LINE__, 
        samp.cnt_discards, samp.dt_tot_discards.insert.time,
                        samp.dt_tot_discards.dispatch.time,
                        samp.dt_tot_discards.complete.time - samp.dt_tot_discards.dispatch.time,
                        samp.dt_tot_discards.complete.time );
    }


    /* Ok, we need to check to see if a) is there a D event present, and b) is this a dm- device */
    /* If no D event, then set d2c = q2c.  If not b) complain, otherwise this is can be normal   */
    bin_sample((float)(io->length / 2), ((events->complete.time - events->first.time)*1000.0), io->prmtyp );
    if (events->dispatch.line != LINENUM_NONE)
    {
	/* normal/expected case */
        heatmap_disk_access_bucket( io->sector, io->length, ((events->complete.time - events->first.time   )*1000.0), 
                                                            ((events->complete.time - events->dispatch.time)*1000.0), io->info->cnt_requeues, io->prmtyp );
    }
    else
    {
	if (io->major != 253) printf( "DBG[%05d]: no D event present and this is *not* a dm- device?\n", __LINE__);
        heatmap_disk_access_bucket( io->sector, io->length, ((events->complete.time - events->first.time   )*1000.0), 
                                                            ((events->complete.time - events->first.time   )*1000.0), io->info->cnt_requeues, io->prmtyp );
    }
    _return(0);
#undef STAT
}


/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int stats_summ_accumio(typ_io *io)
{
static int first = 0;
char *ptr;
int rw = -1;
long seek;
double idle;

#define STAT( _val, _base, _field ) \
summ.dt_tot_##_base._field.time += _val;\
if (_val > summ.dt_max_##_base._field.time) summ.dt_max_##_base._field.time = _val;\
if (_val < summ.dt_min_##_base._field.time) summ.dt_min_##_base._field.time = _val

    if (first == 0)
    {
	first++;
	stats_summ_init();
	summ.boundary = trunc(io->info->events.first.time) + 1.0000;
	state.last_completed_sector    = io->sector - io->length;		/* fake out that a similar io completed to get us to the lba of the current io */
        state.last_completed_length    = io->length;
        state.last_queue_t             = io->info->events.first.time;
	state.IEvtTime                 = 0.0;
	state.idle_state               = Q_IS_IDLE;
        state.avgqu_lasttime           = 0.0;
	state.avgqu_weighted           = 0.0;
        xfprintf( outf, "DBG[%05d]: next report boundary for summ  = %12.9f seconds\n", __LINE__, samp.boundary );
    }

    /* in ascending order:
     * read       = IOTYP_READ
     * write      = IOTYP_WRITE, IOTYP_META, IOTYP_BARRIER
     * discard    = IOTYP_DISCARD, @@@TBD
     */
    rw = -1;
         if (io->prmtyp == IOTYP_READ ) rw = 0;
    else if (io->prmtyp >= IOTYP_WRITE) rw = 1;

    if (rw == -1)
    {
        /* expected to have non-READ/WRITE "completions" filtered off before accum called */
        logFprintf( "%%E[%05d]-BUG: type not read or write? event type = '%s'\n", __LINE__, io->evttyp );
        return(0);
    }

    /* idle processing is handled elsewhere */

    /* this logic is sketchy at best, typically will only work with single stream, non-overlapping io! */
    seek = (io->sector - (state.last_completed_sector + state.last_completed_length));
    summ.seek         += abs(seek);

    if (rw == 0)
    {
        summ.cnt_reads++;
        summ.blks_read   += io->length;

	STAT( ((io->info->events.insert.line   != 0)?(io->info->events.insert.time   - io->info->events.first.time):0.0), read, insert   );
	STAT( ((io->info->events.dispatch.line != 0)?(io->info->events.dispatch.time - io->info->events.first.time):0.0), read, dispatch );
	STAT( ((io->info->events.complete.line != 0)?(io->info->events.complete.time - io->info->events.first.time):0.0), read, complete );
    }
    else if (io->prmtyp != IOTYP_DISCARD)
    {
        summ.cnt_writes++;
        summ.blks_written += io->length;

	STAT( ((io->info->events.insert.line   != 0)?(io->info->events.insert.time   - io->info->events.first.time):0.0), writes, insert   );
	STAT( ((io->info->events.dispatch.line != 0)?(io->info->events.dispatch.time - io->info->events.first.time):0.0), writes, dispatch );
	STAT( ((io->info->events.complete.line != 0)?(io->info->events.complete.time - io->info->events.first.time):0.0), writes, complete );
    }
    else
    {
        summ.cnt_discards++;
        summ.blks_discarded += io->length;

	STAT( ((io->info->events.insert.line   != 0)?(io->info->events.insert.time   - io->info->events.first.time):0.0), discards, insert   );
	STAT( ((io->info->events.dispatch.line != 0)?(io->info->events.dispatch.time - io->info->events.first.time):0.0), discards, dispatch );
	STAT( ((io->info->events.complete.line != 0)?(io->info->events.complete.time - io->info->events.first.time):0.0), discards, complete );
    }
    dprintf( "DBG[%05d]: Summary: reads  Q2I          Q2D          D2C          Q2C         writes  Q2I          Q2D          D2C          Q2C\n", __LINE__ );
    dprintf( "DBG[%05d]:          %5d %12.9f %12.9f %12.9f %12.9f  ", __LINE__, 
	summ.cnt_reads, summ.dt_tot_read.insert.time,
		        summ.dt_tot_read.dispatch.time,
			summ.dt_tot_read.complete.time - summ.dt_tot_read.dispatch.time,
			summ.dt_tot_read.complete.time );
    dprintf(                   "%5d %12.9f %12.9f %12.9f %12.9f\n",
	summ.cnt_writes,summ.dt_tot_writes.insert.time,
		        summ.dt_tot_writes.dispatch.time,
			summ.dt_tot_writes.complete.time - summ.dt_tot_writes.dispatch.time,
			summ.dt_tot_writes.complete.time );
    if (summ.cnt_discards != 0)
    {
    dprintf( "DBG[%05d]: Summary: discs  Q2I          Q2D          D2C          Q2C         \n", __LINE__ );
    dprintf( "DBG[%05d]:          %5d %12.9f %12.9f %12.9f %12.9f \n", __LINE__, 
	summ.cnt_discards,summ.dt_tot_discards.insert.time,
		        summ.dt_tot_discards.dispatch.time,
			summ.dt_tot_discards.complete.time - summ.dt_tot_discards.dispatch.time,
			summ.dt_tot_discards.complete.time );
    }

    /* the following are updated elsewhere when the accum. counterpart is updated */
    /* cnt_inserts
     * cnt_dispatches
     * cnt_sleep_reads
     * cnt_sleep_writes
     * cnt_sleep_discards
     * cnt_requeues_reads
     * cnt_requeues_writes
     * cnt_requeues_discards
     */

    summ.avgqu_weighted;	/* only at A|Q and C				*//* and sample boundaries */
    summ.inflight;		/* don't change this pass the start of the file */
    return(0);
#undef STAT
}


/* SECTION: FUNCTION BLOCK ; OUTPUT FUNCTIONS */
/* ================================================================================================================= */
/* === OUTPUT FUNCTIONS ============================================================================================ */
/* ================================================================================================================= */

/**
 * ==========================================================================================
 * Function : 
 *            @Output the individual event header with field/column names
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int output_io_header(FILE *filf)
{
char salign[32];
char xalign[32];

    if (flag_alignchk == 0) {        salign[0] = 0;         xalign[0] = 0;  }
    else                    { strcpy(salign," [A]"); strcpy(xalign," ---"); }
#ifdef ORIGINAL_RECIPE
        fprintf( filf, "#Prg:Flt  Queue(t)    Q2I(dt)      Q2D(dt)      D2C(dt)      Q2C(dt)      CPU      PID Typ       Size          Sector%s", salign );
	fprintf( filf, "        Seek Description             reQ  Merges:sectors,...\n");
        fprintf( filf, "#---:--- ----------- ------------ ------------ ------------ ------------ ---- -------- --- ---------- ---------------%s", xalign );
	fprintf( filf, " ------------ ---------------------- ---- ---:--------------------------\n");
#else
/*
Normal header: (sans D2D column)

#Prg:Flt   Queue(s)     Q2I(ms)   Q2D(ms)       D2C(ms)            Q2C(ms)     CPU      PID Typ  Size         Sector         Seek  Description            reQ Merges:sectors,...
#---:--- ------------- -------- ------------- -------------+---- ------------- --- -------- ---- ---- -------------- ------------- ---------------------- --- ---:-------------------------
   0:  0  53.002403200   0.0027   0000.003700   000.1922000 % 99   000.1925700   8 13979    R    256       70778368      46949632 [(null):pid not found]   0   0
1234 123 123.56789x123 123.5678 123456.89x123 123.56789x123  123 123.56789x123 123 12345678 123 1234 123456789.1234 123456789.123 123456789.123456789.12 123 123 123456789.123456789.12345
         999.999999999 999.9999 999999.999999 999999.999999  100 999999.999999 999 99999999 123 9999 99999999999999 -999999999999 123456789.123456789.12 999 999:123456789.123456789.12345
         1ns           100ns    1ns           1ns                1ns
         <1000s        <1s      >120s         >120s              >120s

W/D2D column added: include_d2d=1 in blktrace.conf file

#Prg:Flt   Queue(s)   Q2I(ms)   Q2D(ms)   D2D(ms)   D2C(ms)          Q2C(ms)   CPU      PID Typ  Size         Sector         Seek  Description            reQ Merges:sectors,...
#---:--- ----------- -------- ----------- ------- -----------+---- ----------- --- -------- ---- ---- -------------- ------------- ---------------------- --- ---:-------------------------
   0:  0  53.0024032   0.0027   0000.0037  0.0000   0000.1922 % 99   0000.1925   8 13979    R    256       70778368      46949632 [(null):pid not found]   0   0
1234 123 123.56789x1 123.5678 123456.89x1 12.4567 123.56789x1  123 123.56789x1 123 12345678 123 1234 123456789.1234 123456789.123 123456789.123456789.12 123 123 123456789.123456789.12345
         999.9999999 999.9999 999999.9999 999.999 999999.9999  100 999999.9999 999 99999999 123 9999 99999999999999 -999999999999 123456789.123456789.12 999 999:123456789.123456789.12345
         100ns       100ns    100ns       1us     100ns            100ns
         <1000s      <1s      >120s       <1s     >120s            >120s
        (16 minutes!)
*/
    if (conf_include_d2d == 0)
    {
        fprintf( filf, "#PS|Prg :Flt   Queue(s)     Q2I(ms)   Q2D(ms)       D2C(ms)            Q2C(ms)     CPU      PID Typ  Size         Sector%s", salign ); 
	if (flag_shortform == 0) fprintf( filf, "         Seek  Description            reQ Merges:sectors,...\n");
        else                     fprintf( filf, "\n");
        fprintf( filf, "#--|----:--- ------------- -------- ------------- -------------+---- ------------- --- -------- ---- ---- --------------%s", xalign );
        if (flag_shortform == 0) fprintf( filf, " ------------- ---------------------- --- ---:-----------------\n");
        else                     fprintf( filf, "\n");
        if (field_set == 0)
        {
        field_prg = 9999;
        field_flt = 999; /*  123456789 */
        field_queue =    999.999999999;
        field_q2i   =    999.9999;
        field_q2d   = 999999.999999;
        field_d2d   =     99.9999;
        field_d2c   =    999.999999999;
        field_q2c   =    999.999999999;
        field_cpu   =    999;
        field_pid   =  99999999;
        field_size  =   9999;
        field_sector= 99999999999999;
        field_seek  =   999999999999;
        field_desc  = 22;
        field_req   = 999;
        field_merge = 999;
        field_set++;
        }
    }
    else
    {
        fprintf( filf, "#PS|Prg :Flt   Queue(s)   Q2I(ms)   Q2D(ms)   D2D(ms)   D2C(ms)          Q2C(ms)   CPU      PID Typ  Size         Sector%s", salign ); 
	if (flag_shortform == 0) fprintf( filf, "         Seek  Description            reQ Merges:sectors,...\n");
        else                     fprintf( filf, "\n");
        fprintf( filf, "#--|----:--- ----------- -------- ----------- ------- -----------+---- ----------- --- -------- ----- ---- --------------%s", xalign ); 
        if (flag_shortform == 0) fprintf( filf, " ------------- ---------------------- --- ---:------------------\n");
        else                     fprintf( filf, "\n");
	if (field_set == 0)
        {
	field_prg = 9999;
        field_flt = 999; /*  12345678 */
        field_queue =    999.9999999;
        field_q2i   =    999.9999;
        field_q2d   = 999999.9999;
        field_d2d   =     99.9999;
        field_d2c   =    999.9999999;
        field_q2c   =    999.9999999;
        field_cpu   =    999;
        field_pid   =  99999999;
        field_size  =   9999;
        field_sector= 99999999999999; 
        field_seek  =   999999999999;
        field_desc  = 22;
        field_req   = 999;
        field_merge = 999;
        field_set++;
        }
    }
#endif

	return(0);
}


/**
 * ==========================================================================================
 * Function : output_key_header
 *            @Output the main key file header to outf, once.
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int output_key_header()
{
static int key_header = 0;

    if (key_header == 0)
    {
        key_header++;
        fprintf( outf, "#Version   : %s\n", VERSION );
        show_configuration(outf, 1);
        fprintf( outf, "#NOTES     :\n");
        fprintf( outf, "# . data reported in at io 'C'omplete time, so list is in completed time order, not queued time order.\n");
	fprintf( outf, "# . PS  = pre-staged  count (within scheduler), io that has not been determined to be a M or G,I.\n");
        fprintf( outf, "# . Prg = in-progress count (within scheduler), that is 'Q'ueued io that hasn't 'C'ompleted\n");
        fprintf( outf, "# . Flt = in-flight   count (within driver/storage), that is 'D'ispatched io that hasn't 'C'ompleted.\n");
        fprintf( outf, "#                           (excludes currently completing io listed within summary line output)\n");
        fprintf( outf, "# . Typ = 'R'ead, 'W'rite, 'D'iscard, 'B'arrier, or 'N'one (!write & bytes!=0:ioctl?).\n");
        fprintf( outf, "#         'F'lush, but only if this is BEFORE the R|W|D|N letter code\n");
        fprintf( outf, "#         'F'ua,   but only if this is AFTER  the R|W|D|N letter code\n");
        fprintf( outf, "#         'S'yncronous, 'M'eta, or Read'A'head \n");
        fprintf( outf, "#         note: the above codes are set within the binary data within the kernel before data is exported.\n");
        fprintf( outf, "#         note: 'B'arrier seems to have been dropped from latest upstream blkparse utility.\n");
        fprintf( outf, "# . Name= [(null)], this means when blktrace attempted to translate the pid to a process name, the pid no\n");
        fprintf( outf, "#         longer existed within the process tree.\n");

        if (flag_alignchk != 0)
        fprintf( outf, "# . [A] = sector is ([A]) or is not ([ ]) aligned to %d sector alignment quanta\n", conf_alignquanta);

        fprintf( outf, "# . 2.6.32: io complete for merged io is reported upon first (merged) io completion whose size covers the whole merged io range\n");
        fprintf( outf, "# . 3.10.0: io complete for merged io is reported when last of the io contained within a merged io completes.\n");

        fprintf( outf, "#\n");
        fprintf( outf, "# === SPECIAL CASES  ==================================================================== \n");
        fprintf( outf, "# [GHOST]   tag appears at the end of the summary line:\n");
        fprintf( outf, "#           - one or more 'orphan' events were encountered which triggered the creations\n");
        fprintf( outf, "#             of a 'ghost' request.  For example first event for an io context is an 'I'\n");
        fprintf( outf, "#             results in a 'ghost' with synthesized 'Q' event.  Ghost events do not affect\n");
        fprintf( outf, "#             inProgress, InFlight or any other io statistics -- they are ghosts.\n");
        fprintf( outf, "# [Barrier] tag appears at the end of the summary line:\n");
        fprintf( outf, "#           - a sequence of A,Q,G,I,C for sector:length 0:0 was detected. There are several\n");
        fprintf( outf, "#             unusual attributes associated with this sequence including only the A event\n");
        fprintf( outf, "#             has a specified sector:length (0 + 0) in the event -- all others have neither.\n");
        fprintf( outf, "#             this appears to be uses as some type of io barrier.  there is no 'D'ispatch\n");
        fprintf( outf, "#             as there is no data movement due to length=0.  There is special code to detect\n");
        fprintf( outf, "#             this particular sequence and it gets flagged as Special Case.1.\n");
        fprintf( outf, "# [BARRIER] tag appears at the end of the summary line:\n");
        fprintf( outf, "#           - a non-read io with a sector:length value of 0:0 is detected, for \n");
        fprintf( outf, "#             example 'FWS 0 + 0' is a Flush/Write/Sync io of zero length to sector 0.\n");
        fprintf( outf, "#             such io will not have a 'D'ispatch event and are considered a generic \n");
        fprintf( outf, "#             io barrier and are so tagged.  The difference between this and [Barrier] above\n");
        fprintf( outf, "#             is that the above is a more specific 4.18 event stream type that requires\n");
        fprintf( outf, "#             additional 'special' handling with the code whereas a generic io barrier is\n");
        fprintf( outf, "#             otherwise the same as any normal io (with the exception of the missing\n");
        fprintf( outf, "#             'D'ispatch event because the io has a zero-length size.\n");
        fprintf( outf, "# ======================================================================================= \n");

        if (flag_negrequeue != 0)
        {
        fprintf( outf, "#\n");
        fprintf( outf, "# === ALERT  ============================================================================ \n");
        fprintf( outf, "# -R flag specified!!!\n");
        fprintf( outf, "#    When this flag is passed in, the dispatch time is not reset by 'R'equeue events.\n");
        fprintf( outf, "#    The results in the storage being charged in D2C time from the first 'D'ispatch\n");
        fprintf( outf, "#    to 'C'ompletion vs the default of charging from the last 'D'isplatch to 'C'ompletion.\n");
        fprintf( outf, "#    This allows the Q2D time to reflect what the kernel attempted (but was thwarted due \n");
        fprintf( outf, "#    to the 'R'equeue rejection from the driver/controller/storage).  The D2C times in this\n");
        fprintf( outf, "#    reflect whatever the congestion issues is within the storage portion of the system\n");
        fprintf( outf, "#    that caused the requeues in the first place.\n");
        fprintf( outf, "# ======================================================================================= \n");
        }

        if (state.device_nvme     != 0)
        {
        fprintf( outf, "#\n");
        fprintf( outf, "# . NVMe : NVMe device detected within blktrace capture log file.\n");
        fprintf( outf, "#          NVMe devices have ioscheduler <none>, which means it does not have 'I'nsert events.  Within some\n");
        fprintf( outf, "#          kernel versions there are no 'D'ispatch events, as a 'Q'ueue implies a 'D'ispatch event.\n");
        fprintf( outf, "#          For NVMe devices the 'I' and 'D' events are set to the 'Q'ueue time if they are found to be 0.0.\n");
        fprintf( outf, "#         This will result in Q2I (and in some cases Q2D) delta times to always be zero.  In those cases where\n");
        fprintf( outf, "#           there was no 'D' event, the D2C(dt) will be the same as Q2C times as a result.\n");
        }

	fprintf( outf, "#\n");
        fprintf( outf, "# === Time Descriptions ================================================================= \n");
        fprintf( outf, "#  (*)  Q2Q — time between requests sent to the block layer\n");
        fprintf( outf, "#  (*)  Q2G — how long it takes from the time a block I/O is queued to the time it gets a request allocated for it\n");
        fprintf( outf, "#  (*)  G2I — how long it takes from the time a request is allocated to the time it is Inserted into the device's queue\n");
        fprintf( outf, "#       Q2I - how long it takes from the time a block I/O is assigned to a new request and inserted into the scheduler queue[1]\n");
        fprintf( outf, "#  (*)  Q2M — how long it takes from the time a block I/O is queued to the time it gets merged with an existing request\n");
        fprintf( outf, "#       I2D — how long it takes from the time a request is inserted into the device's queue to the time it is actually issued to the device\n");
        fprintf( outf, "#  (*)  M2D — how long it takes from the time a block I/O is merged with an exiting request until the request is issued to the device\n");
        fprintf( outf, "#       D2D - how long it takes from the first time I/O is issued to the device to the last time I/O was re-issued to the device [2]\n"); 
        fprintf( outf, "#       D2C — service time of the request by the device, this time is dominated by storage latency[3]\n");
        fprintf( outf, "#       Q2C — total time spent in the block layer for a request\n");
	fprintf( outf, "# \n");
        fprintf( outf, "#  (*)  indicates this delta time value is not output within the merged one-line per request output that follows\n");
        fprintf( outf, "#       but is available in other output files from standard blktrace package utilities. Typically these times are included\n");
        fprintf( outf, "#       within combined times in other columns, for example Q2I = Q2G + Q2I. Nominally the main N2N times of interest are Q2D\n");
        fprintf( outf, "#       D2C, and Q2C.  Only when 'S'leep events or 'R'equeue events occur is breaking down Q2D time for analysis of interest.\n");
        fprintf( outf, "#  [1]  Q2I is the combination of Q2G + G2I\n");
        fprintf( outf, "#  [2]  D2D will be non-zero only if there are 'R'equeue events present for the given I/O\n");
        fprintf( outf, "#  [3]  service time includes the short code path within the driver, time spent within the HBA, transport time to the storage\n");
        fprintf( outf, "#       target (including any switches between HBA and storage target), storage controller queue time, storage controller\n");
        fprintf( outf, "#       time, storage device latency, storage controller status processing time, transport time back to the host (again through\n");
        fprintf( outf, "#       any given switches, HBA time, driver short path to process the returning io completion interrupt.  While the actual\n");
        fprintf( outf, "#       'storage latency time' itself within a storage box is reasonable, the queueing time within the storage controller can be\n");
        fprintf( outf, "#       significant when the controller is under load from this, as well as other, hosts.  From a kernel perspective the whole\n");
        fprintf( outf, "#       combination of hardware latencies are seen as a monolithic storage latency that cannot be further subdivided.\n");
        fprintf( outf, "#  --------------------------------------------------------------------------------------- \n");
        fprintf( outf, "#\n");
        fprintf( outf, "# Compact State Form:\n");
        fprintf( outf, "# ==================================================================================\n");
        fprintf( outf, "# \n");
        fprintf( outf, "# |merge|\n");
        fprintf( outf, "# Q---->M------------>D----------------------------------------------------------->C    Merge: add into an existing request\n");
        fprintf( outf, "# Q------>G->I------->D----------------------------------------------------------->C    Add  : create a new io request\n");
        fprintf( outf, "# |--insert--|--queue-|                                                                 Q2D  : total scheduler/host time\n");
        fprintf( outf, "#                     |--- driver,adapter,transport,switch,storage latency time ---|    D2C  : total storage latency (outside of OS)\n");
        fprintf( outf, "# |---- host time ----|--- hardware based time ------------------------------------|    Q2C  : await time in iostat output\n");
        fprintf( outf, "# \n");
        fprintf( outf, "# NOTE: Not to scale.  Earlie M,D|G,I,D events are spread out to allow string label descriptions.\n");
        fprintf( outf, "# \n");
        fprintf( outf, "# \n");
        fprintf( outf, "# Q---->M                                                                             Q2M, [1] 'merge' time, time to find existing request and add this I/0 to it\n");
        fprintf( outf, "# Q------>G                                                                           Q2G,     'create' time to allocate request data structure for new I/O\n");
        fprintf( outf, "#         G->I                                                                        G2I, [2] 'sort' time, how long it took sort algorithm to insert I/O request into queue\n");
        fprintf( outf, "# Q------>G->I                                                                        Q2I, [3] 'insert' time, time spent by sched on staging I/O\n");
        fprintf( outf, "# Q------>G->I------->D                                                               Q2D,     'host' time, time io request spends in scheduler, also kernel|sched time\n");
        fprintf( outf, "#            I------->D                                                               I2D, [4] 'queue' time, time spent in sched queue awaiting dispatch\n");
        fprintf( outf, "#                     D----------------------------------------------------------->C  D2C,     'storage' time, this is dominated by storage latency time\n");
        fprintf( outf, "# Q------------------------------------------------------------------------------->C  Q2C,     'await' time, time as reported via 'await' by iostat et.al.\n");
        fprintf( outf, "# \n");
        fprintf( outf, "# \n");
        fprintf( outf, "# |<-host side time-->|<-------------------- hardware side time ------------------>|                          \n");
        fprintf( outf, "# Q------------------>D                                                               Q2D,      host side time\n");
        fprintf( outf, "#                     D----------------------------------------------------------->C  D2C, [5]  hardware based time (driver/adapter/transport/switch/storage)\n");
        fprintf( outf, "# Q------------------------------------------------------------------------------->C  Q2C,      await time as reported by iostat, sar, etc.\n");
        fprintf( outf, "# |<------------------------ await time ------------------------------------------>|\n");
        fprintf( outf, "#\n");
        fprintf( outf, "#\n");
        fprintf( outf, "# Q------------------------------------------------------------------------------->Q  Q2Q, time between adajacent bio being set into io scheduler\n");
        fprintf( outf, "#                                                                          C------>Q  C2Q, idle time -- but only if no other io present (qdepth=0 post C event)\n");
        fprintf( outf, "#\n");
        fprintf( outf, "# NOTES\n");
        fprintf( outf, "# [1] : A merged request is simply added to an existing request already inserted/present within the scheduler.  As\n");
        fprintf( outf, "#       such, the 'M'erge (or 'F'ront merge) event is typically the last event specifically associated with this bio.\n");
        fprintf( outf, "#       Any M2D time is then associated with the request the I/O was merged into.  M2D times can increase both if\n");
        fprintf( outf, "#       additional I/O are merged into the request and due to sorting.\n"); 
        fprintf( outf, "# [2] : This is the time used by whatever scheduler algorithm is in use to 'sort' a request into the scheduler queue.\n");
        fprintf( outf, "#       This time will vary by which scheduler is in use.  The noop and none options have near zero 'sort' time. Things\n");
        fprintf( outf, "#       Like deadline and cfq a little more time, but in general sort time is a well behaved sort delay regardless.\n");
        fprintf( outf, "#       Typically, both because G events may not be present and due to sort time being short and well behaved, the\n");
        fprintf( outf, "#       more general Q2I time is used as the 'sort' time event though it is made up of 2 or more subcomponents.\n");
        fprintf( outf, "# [3] : Not all implementations output S|G events.  As such, the Q2I time is more typically associated with 'sort time'\n");
        fprintf( outf, "#       or queue time.  This is the total amount of time spent by the kernel staging the I/O into the scheduler.  Any \n");
        fprintf( outf, "#       delay from I2D is more driven by scheduler policy (such as idle slice time for cfq) and/or congestion within \n");
        fprintf( outf, "#       storage (such as lun queue depth being full so as to delay dispatch).  In general, Q2I time is more important\n");
        fprintf( outf, "#       than any of the sub-components therein.\n");
        fprintf( outf, "# [4] : The I2D time includes any scheduler personality delays, but is nominally any significant delays here will be\n");
        fprintf( outf, "#       dominated by device|target|driver lun queue full conditions.  That is, typically the delay witihn I2D time that\n");
        fprintf( outf, "#       is associated with kernel code is short.  Long delays here are almost always associated with lun queue depth\n");
        fprintf( outf, "#       issues. Scheduler personality delays that are common in I2D, for example, is the slice idle time within cfq which\n");
        fprintf( outf, "#       injects a short delay to allow for improved merging.  Similar delays are not present in deadline, noop, etc.\n");
        fprintf( outf, "# [5] : the hardware based time includes the driver path which is fairly short.  The driver's main job is to repackage\n");
        fprintf( outf, "#       the kernel request data structure into a form that the HBA's firmware can accept and then passing that mapped\n");
        fprintf( outf, "#       request information into the controller's firmware -- typically via a queue/mailbox function.  This driver \n");
        fprintf( outf, "#       based code path is both short in duration and nominally stable.  Therefore the driver side portion of the \n");
        fprintf( outf, "#       D2C time is considered fixed and a small fraction of total D2C time.  Internal controller functions, such as\n");
        fprintf( outf, "#       san buffer credits, can delay the HBA hardware from delaying the transmission of the io request to storage,\n");
        fprintf( outf, "#       but the kernel has no further insight into those types of hardware based issues within the HBA controller itself.\n");
        fprintf( outf, "#       Such time is counted against the hardware side of things since there is no kernel nor driver code involved in\n");
        fprintf( outf, "#       same.\n");
        fprintf( outf, "#\n");
        fprintf( outf, "# \n");
        fprintf( outf, "# Long State Form:\n");
        fprintf( outf, "# ==================================================================================\n");
        fprintf( outf, "# \n");
        fprintf( outf, "#               +----------+\n");
        fprintf( outf, "#               |          | \n");
        fprintf( outf, "#               |         {R}\n");
        fprintf( outf, "#               |          ^\n");
        fprintf( outf, "#               v          |\n");
        fprintf( outf, "# A->Q+>{S}->G->I--+---->D-+--------------------------------------------------------->C    \n");
        fprintf( outf, "#     |            ^\n");
        fprintf( outf, "#     v  +--->M----+\n");
        fprintf( outf, "#     +--+--->F----+\n");
        fprintf( outf, "# \n");
        fprintf( outf, "# Key: { }- optional or unsual events that nominally should not be present\n");
        fprintf( outf, "#       A - remAp   ; lba block mapping               M - Merge   ; merge io onto end of existing request on q\n");
        fprintf( outf, "#       Q - Queue   ; io arrival @sched               F - Front   ; merge io onto front of existing request on q\n");
        fprintf( outf, "#       S - Sleep   ; await for request               D - Dispatch; send req to driver\n");
        fprintf( outf, "#       G - Getreq  ; get request struct              R - Requeue ; io rejected, place back on queue\n");
        fprintf( outf, "#       I - Insert  ; insert req into q               C - Complete; io done \n");
	fprintf( outf, "#       X - SplitIO ; split a request in two          B - Bounce  ; bounced data page to reserved lower memory req'd\n");
        fprintf( outf, "#       -----------------------------------------------------------------------\n");
        fprintf( outf, "#       P - Plug    ; plug/stop draining io to drv    U - Unplug  ; unplug drain\n");
        fprintf( outf, "#       T - Timeout ; unplug drain due to timeout\n");
        fprintf( outf, "#\n");
        fprintf( outf, "#NOTES:\n");
        fprintf( outf, "#{....} : are events that may not happen\n");
        fprintf( outf, "#{A-->} : remAp event, for example map the LBA (sector) from partition relative number to disk absolute sector number.\n");
        fprintf( outf, "#{-->S} : Sleep; wait for availability of request data structure, typically when nr_request limit is reached, \n");
        fprintf( outf, "#{-->R} : Requeue: driver rejects the io even though its below advertised lun queue depth, typically a resource issue \n");
        fprintf( outf, "#         of some type exists within the driver and/or HBA causing this rejection of the io back to the scheduler.\n");
        fprintf( outf, "#         Requeued I/O are placed at front of the queue -- next up -- and futher dispatch to the driver is stalled\n");
        fprintf( outf, "#         until this requeued io is accepted.  It can be common to see an occassional 'R'equeue happen and is \n");
        fprintf( outf, "#         something to watch but not be overly concerned about.  However, if there are a large number of 'R'equeues\n");
        fprintf( outf, "#         happening or a large number on some io then the root cause within the hardware should be investigated. Often\n");
        fprintf( outf, "#         lowering the lun queue depth can help reduce 'R'equeues from happening.  Reducing nr_requests can have a \n");
        fprintf( outf, "#         similar affect via indirect means by slowing the number of io available at any given time for the scheduler\n");
        fprintf( outf, "#         to use to fill the underlying lun queue.\n");
        fprintf( outf, "#\n");
        fprintf( outf, "# NOTE:   option flags will control how time associated with Requeues is accumlated, that is into either Q2D or D2C time.\n");
        fprintf( outf, "#         Either accumulation is sub-optimal which is why its recommended to allow a D2D time to be added to the per event output.\n");
        fprintf( outf, "#        events    Q------------>D->R-I->D->R->I->D------------>C \n");
        fprintf( outf, "#          +--- option flag controlling where R,I,D sequence is accumulated into.\n");
        fprintf( outf, "#          v\n");
        fprintf( outf, "#        0=storage |---Q2D------>|--------D2C------------------>| this is normal output but will complain about requeues\n");
        fprintf( outf, "#        1=host    |---Q2D----------------------->|---D2C------>| if host centric output mode selected, will still complain\n");
        fprintf( outf, "#        show D2D  |---Q2D------>|---D2D--------->|---D2C------>| best, host view Q2D reflects host time, D2C reflects storage\n");
        fprintf( outf, "#                                                                 and D2D time kept separate.\n");
        fprintf( outf, "#\n");
        fprintf( outf, "# ======================================================================================= \n");
        fprintf( outf, "# \n");

/*
 * Further notes
 *

Recent Case Comments

The following comments are on the use of:

"
Q--------G----------------I----------M------------------------D------------------------------------>C
|-Q time-|----Insert time-|
|------------ merge time ------------|-----merge with other IO|
|--------------------- scheduler time----- -------------------|---------driver,adapter,storagetime--|
|----------------------- await time in iostat output -----------------------------------------------| 
"

Which appeared in several cases.  The above is incorrect in several aspects.


Merges happen essentially at 'Q' event time and most implementations show up as an M event instead of a Q event. Newer implmentations include the G event for new requests and separate M|F merge events (instead of G) for merges.

Q->G is not Q time -- although not sure really what that is
M->D time is not "merge with other io", the M event is essentially marks the end of the merging path.

A more accurate state diagram is:

                  +---------------+
                  |               |
                  |               R              
                  |               ^
                  v               |
A->Q-+-->{S}-->G--+->I---+----->D-+------------------------->C
     |                   |
     v      +----->M-----+
     +------+----->F-----+


Flow is remAp (A) event if block mapping from dm to sd or partition to base sd is required, there may be multiple A events as block lba are remapped through a couple different layers. 

The Q event is really the __make_request() event, it determines if this is a new io (needing a new 'G'etrequest event) or can be merged (resulting in a M|F event).  The post event outcome of Q is either S,G,I sequence .OR. M|F events.  Note there is no I event for M|F as will be explained.

The S,G,I in 2.6.18 and some early 7 was just I -- insert, the __make_request() determined this was new request, request structure created and the I event is post sort/insertion of that new event into the "scheduler" queue (not really a scheduler, more of just a sorter).  Anyway, later 3.10 and 4.18 will have the G,I events - Getrequest and Insert as separate events.  There is an option S event -- the Sleep event happens when there are no further request structures allowed/allocatable.  Think of the case where nr_request sort queue depth is reached, a Dispatch happens making room for another request.  While in 2.6.18 make_request() wasn't allowed to block, it does block in 2.6, 3.10,i 4.18,... versions.  So that means if we'd reach nr_requests limit and make_request() call for additional io happened they would block waiting for allowed nr_request to drop and allow new requests.  So, then make_request unblocks and behind its back, that earlier Dispatch event hits an issue and is turned back with a Requeue which immediately puts it as the next io to be dispatched taking up the nr_request slot again, and the queue is back up to its max nr_request limit in terms of requests present.  The Requeue is pretty fast, that is its a fairly short code path.  But so is the decrement count of requests queued which fires off the unblock to any threads blocked in make_request().  But the make_request() looses, and after unblock finds that when it attempts to get a request its blocked again.  So it sleeps again waiting on nr_request availability.  And this generates a S event.  It is not the only scenario that causes S events, but is far the easiest to explain.  Often R and S events go hand in hand -- but not always.  Then the G event is Getrequest being successful --  a request struct is allocated for the incoming bio.  Then that request struct is inserted into the queue and the I event generated.

Now if __make_request() determines a merge is possible with an existing request on the queue, instead of calling Getrequest it simply hands back the current existing request that the incoming bio is to be merged into.  Since it is already on the queue, there is technically no "merge time" or "insert time" -- the bio is simply added into the current request.  Sure adding the bio pointers and resizing the io length (M,back merge) or starting lba (F,front merge) takes some code path time but that is fairly deterministic.  At best, the "merge time" is Q->{M|F} in that __make_request() had to try and lookup an io on the current queue to see if one was available to merge into... however, that same time is also built into the Q->{S}->G time also.


The Q,G,I,M time you have does not happen.  And Q->G and Q->M code paths contain nearly identical processing needs -- Q->M *may* be marginally faster, but the difference will typically be in uSec or nSec range.  There is no Q,G,I,M because the merge happens directly against a request structure that is already on the queue -- so there is no insert event.  The request struct was inserted into the queue earlier for the first bio that resulted in the request struct being created.

 */

        output_io_header(outf);
    }
    _return(0);
}



/**
 * ==========================================================================================
 * Function : output_completed_io
 *            @	   
 * Args     : @io:         io being completed/output
 *            @reason:     string about the completion
 *            @qtype:	   queue the io resides on; STAGED, MAINIO, POSTIO.
 *
 * Returns :
 *
 * Description
 * Output 1-liner summary of this io request and all its attended merged individual events.
 *
 * If the IO is on the POSTIO queue, then the state inflight/inprogress info is pulled from the
 * ctracker structure vs state structure.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int output_completed_io( typ_io *io, char *reason, int qtype )
{
int ndx;
int end;
static int header = 0;
long seek;
double idle;
int device_lvm;
int D2C_percent = 0;	/* whole number percentage  */
char alignchk[8];
char smerge[80], xmerge[80];
char *name, nopidname[32]="[(null):pid not found]";
                        /* 123456789.123456789.1234 */
typ_eventdata dTime;
double dispatch;
double insert;
typ_actions *actions;
int inFlight, inProgress;
double last_queue_t;
long last_completed_sector, last_completed_length;
int bgn_tmo_line, end_tmo_line;
int noIns, noDis;
double bgn_tmo_time, end_tmo_time;
static int flag_max_once = 0;

    actions = &io->info->events;

    output_key_header(io);
    dump_io_raw(io,reason,__LINE__);

    io_sig_count(io->event_sigs);			/* Count the event signature trail/track for this io since we're pushing it to output file */

    /* Ok, compute the various dTime values that will be needed         */
    /* range settings                                                   */
    dTime.D2D = (((actions->dispatch.line != 0)|state.device_nvme)?(actions->dispatch.time - actions->dispatch_first.time):0.0);
    dTime.Q2C = (((actions->complete.line != 0)|state.device_nvme)?(actions->complete.time - actions->first.time         ):0.0);
    if ((long)actions->insert.line   != 0) noIns = 0 ; else noIns = 1;
    if ((long)actions->dispatch.line != 0) noDis = 0 ; else noDis = 1;
    if (conf_include_d2d == 0)
    {
        /* Normal accounting, include any D2D time in Q2(DDD)D ... unless flag_negrequeue is*/
        /* set. If flag_negrequeue is set, then Q2D is Q2(first)D and D2C is (first)D2C     */
	/* The negrequeue set reverts behavior so D2D time is charged against storage, vs   */
        /* being charged against the host.  Better would be to turn on include_d2d so that  */
	/* D2D is output separately, but if we're not going to do that, use negrequeue to   */
        /* control who gets changed D2D time; 0=storage, 1=host                             */
        /*                                                                                  */
        /* events    Q------------>D->R-I->D->R->I->D------------>C                         */
        /* 0=storage |---Q2D------>|--------Q2C------------------>|                         */
        /* 1=host    |---Q2D----------------------->|---Q2C------>|                         */
        if (flag_negrequeue == 0) { dispatch = actions->dispatch.time;       insert = actions->insert.time;                 } /* Normal Q2(last )I, Q2(last )D D(last )2C */
        else                      { dispatch = actions->dispatch_first.time; insert = actions->insert_first.time;           } /*        Q@(first)I, Q2(first)D D(first)2C */
        dTime.Q2I = (((actions->insert.line   != 0)|state.device_nvme)?(         insert        - actions->first.time        ):0.0);
        dTime.Q2D = (((actions->dispatch.line != 0)|state.device_nvme)?(         dispatch      - actions->first.time        ):0.0);
        dTime.D2C = (((actions->dispatch.line != 0)|state.device_nvme)?(actions->complete.time - dispatch                   ):0.0);
    }
    else
    {
        /* If the include_d2d option was specified, then D2D time will be output separately */
        /* so benchmark dispatch time is 'dispatch_first' for Q2D and 'dispatch' (last) for */
        /* D2C, with the D2D time inbetween called out separately                           */
        /*                                                                                  */
        /* events    Q------------>D->R-I->D->R->I->D------------>C                         */
        /*           |---Q2D------>|---D2D--------->|----Q2C----->|			    */
        dTime.Q2I = (((actions->insert.line         != 0)|state.device_nvme)?(actions->insert_first.time   - actions->first.time         ):0.0);
        dTime.Q2D = (((actions->dispatch_first.line != 0)|state.device_nvme)?(actions->dispatch_first.time - actions->first.time         ):0.0);
        dTime.D2C = (((actions->dispatch.line       != 0)|state.device_nvme)?(actions->complete.time       - actions->dispatch.time      ):0.0);
    }
    D2C_percent = 0;
    if ((dTime.D2C <= dTime.Q2C) && (dTime.Q2C > 0.000001)) D2C_percent = (int)((dTime.D2C*100.0)/dTime.Q2C);

    /* Only account for work against the main io or when the last subio completes */ /*@@@TBD - right now a complete = whole io */
    sprintf( alignchk, "   " );
    {
        /* Mainio completed - do the needful */
	stats_check_boundary(io,0);			/* if this io crosses a sample boundary, flush out the previous stats before continuing */
	/* Only count the io if its not a Barrier, or a */
	/* Ghost.  Neither of those should be counted.  */
	/* The Barrier because is not a real io (0:0),  */
	/* and not a Ghost because its not complete     */
        if (((io->evtflags & EVTFLG_GHOST) == 0) &&
            ((io->specials & SPCFLG_00   ) == 0))
	{
            stats_samp_accumio(io);                         /* accum this completion against the current second sample stats                        */
            stats_summ_accumio(io);			    /* accum this completion against the summary for the whole file			    */ 

            /* The total_io, aligned_io counters are only updated at 1-liner merged output */
            /* as these are not present in the 1-liner output itself (well, aligned is but */
            /* its doesn't impact any other io, just this io so safe to postpone until now */
            /* vs inflight/inprogress counters?                                            */
            state.total_io++;
            if (flag_alignchk != 0)
            {
	        sprintf( alignchk, "[ ]" );
	        if ((io->sector % conf_alignquanta) == 0) 
	        {
	            state.total_aligned++;
	            sprintf( alignchk, "[A]" );
	        }
            }
	}
    }

    /* @@@ this looks wrong.  the state.last_completed_sector */
    /* is only updated in here after we output a completed    */
    /* event, grabbing it from the io->ctracker will have the */
    /* wrong seek information (seek not even at dispatche but */
    /* something inbetween.  Always use the state. infor for  */
    /* now until proven incorrect.                            */
    if (qtype != POSTIO_QUEUE) 
    {
	/* e.g. MAIN_QUEUE */
        inFlight     = state.inFlight;
        inProgress   = state.inProgress;
    }
    else if (io->ctracker != NULL)
    {
	/* use cached inFlight, inProgess counters from when this was moved onto POSTIO_QUEUE in ctracker */
	inFlight     = io->ctracker->inFlight;
	inProgress   = io->ctracker->inProgress;
    }
    else
    {
	/* This is POSTIO_QUEUE but this io was parked here waiting for a C event that never arrived? */
	/* This really should not be happening in 3.10+					      */
	fprintf( outf, "%%E[%05d]: POSTIO_QUEUE has io that has no ctracker so no completions?!\n", __LINE__ );
	inFlight     = 999;  /* these values should stand out as made up */
        inProgress   = 999;  /* "				         */
    }
    last_queue_t = state.last_queue_t;
    last_completed_sector = state.last_completed_sector;
    last_completed_length = state.last_completed_length;

    /* very sketchy idle logic... needs work 	*/
    idle = (actions->first.time - last_queue_t);

    /* bgn: prechecks and common setups 	*/
    device_lvm = lvm_check(&io->info->events);
    /* @@@ force device_lvm off, depend on .line value instead */
    device_lvm = 0;

    seek = io->sector - (last_completed_sector + last_completed_length);
    end  = heatmap_disk_access_to_bucket( io->sector + (io->length-1L) );
    if (last_completed_sector      == -1) seek = 0;
    if ((io->specials & SPCFLG_00) !=  0) seek = 0; 	/* Force seek to zero for BARRIER special case */

    /* modify process name, if null/unknown */
    name = io->procname;
    if (strncmp(name, "[(null)]", 8) == 0) name = nopidname;

    smerge[0] = 0;
    if ((io->info->cnt_merges) > 0)
    { typ_io *subio; int cnt,tot; char sep[8];
	strcpy( smerge, ":" );
        tot = io->info->cnt_merges;
        for (subio=io->subio,cnt=1;(cnt <=5 && cnt <= io->info->cnt_merges); cnt++,subio=subio->subio)
        {
                 if              (cnt == tot         ) sprintf( sep, "."   );
            else if ((cnt==6) && (cnt <  tot        )) sprintf( sep, "..." );
            else                                       sprintf( sep, ","   );
            sprintf( xmerge, "%3d%s", subio->length, sep );
	    strcat(smerge,xmerge);
        }
    }
    if ((io->specials & SPCFLG_00)    != 0)
	sprintf( smerge, ": [barrier]");       /* [SPECIAL CASE.1] "barrier" like 0:0 AQGIC sequence */
    if ((io->evtflags & EVTFLG_GHOST) != 0)
	sprintf( smerge, ": [GHOST]  ");       /* An orphan event triggered a ghost request create   */
    if ((io->ioflags  & IS_IOBARRIER) != 0)
	sprintf( smerge, ": [BARRIER]");
    /* end: prechecks and common setups 	*/



#   ifdef FIELD_BOUNDS_CHECK
    if ((summ.inflight-1)   > field_flt) field_flt_exceeded++;
    if ( state.in_progress  > field_prg) field_prg_exceeded++;
    if ( dTime.Q2I          > field_q2i) field_q2i_exceeded++;
    /* etc. */
#   endif

    if (conf_include_d2d == 0)
    {
/*
#Prg:Flt   Queue(s)     Q2I(ms)   Q2D(ms)       D2C(ms)            Q2C(ms)     CPU      PID Typ  Size         Sector         Seek  Description            reQ Merges:sectors,...
#---:--- ------------- -------- ------------- -------------+---- ------------- --- -------- ---- ---- -------------- ------------- ---------------------- --- ---:-------------------------
   0:  0  53.002403200   0.0027   0000.003700   000.1922000 % 99   000.1925700   8 13979    R    256       70778368      46949632 [(null):pid not found]   0   0
1234 123 123.56789x123 123.5678 123456.89x123 123.56789x123  123 123.56789x123 123 12345678 123 1234 123456789.1234 123456789.123 123456789.123456789.12 123 123 123456789.123456789.12345
         999.999999999 999.9999 999999.999999 999999.999999  100 999999.999999 999 99999999 123 9999 99999999999999 -999999999999 123456789.123456789.12 999 999:123456789.123456789.12345
*/
#       ifdef MOVED_TO_POSTIO
        if ((summ.inflight-1) != state.inProgress)
	    printf( "DBG[%05d]: summ.inflight %4d vs %4d state.inProgress\n", __LINE__, (int)summ.inflight-1, state.inProgress );
#       endif
        fprintf( outf, "%3d|%4d:%3d %13.9f ",
	     (staged_on_list <= 999)?staged_on_list:999, 
	     inProgress,	        			/* add +0, the io is still on mainio_list */
	     (((inFlight+1) <= -1000)?-999:(inFlight+1)),       /* add +1 for the io just completed       *//* lun queue depth      */
             actions->first.time );
	if ((noIns == 0) && (noDis == 0))
            fprintf( outf, "%8.4f %13.6f %13.6f %%%3d ", dTime.Q2I*1000.0, dTime.Q2D*1000.0, dTime.D2C*1000.0, D2C_percent );
	else
	{
	    if (noIns == 0) fprintf( outf, "%8.4f ", dTime.Q2I*1000.0 );
	    else            fprintf( outf, "  -.---- ");
	    if (noDis == 0) fprintf( outf, "%13.6f %13.6f %%%3d ", dTime.Q2D*1000.0, dTime.D2C*1000.0, D2C_percent );
	    else            fprintf( outf, "     -.------     -.------- %% -- ");
	}
        fprintf( outf, "%13.6f %3d %8d %-4s %4d %14lu",
            dTime.Q2C * 1000.0,
            io->cpu,
            io->pid,
            io->evttyp,
            io->length,
            io->sector );
        if (flag_alignchk != 0)
            fprintf( outf," %s", alignchk );
        if (flag_shortform == 0) fprintf( outf, " %13ld %-22s %3d%c%3d%s\n", seek, name, io->info->cnt_requeues, (io->info->cnt_sleeps==0)?' ':'S', io->info->cnt_merges, smerge );
	else                     fprintf( outf, "\n");
	dbg_out_events_in_io(io,outf);
        if (io->info->cnt_sleeps > 1)
            fprintf( outf, " %%W[%05d]-event sleep count %d > 1!?\n", __LINE__, io->info->cnt_sleeps );
	if (io->ioflags & IS_SAMEIODRIVR)
	    fprintf( outf, " %%%c[%05d]-overlapping io in driver   detected %c:%08ld.%06ld @%13.9f\n", (io->prmtyp==IOTYP_WRITE)?'E':'W', __LINE__,
		_prmtyp(io->prmtyp), io->sector, io->length, actions->first.time );
	else if (io->ioflags & IS_SAMEIOSCHED)
	    fprintf( outf, " %%W[%05d]-overlapping io in scheduler detected %c:%08ld.%06ld @%13.9f\n", __LINE__,
		_prmtyp(io->prmtyp), io->sector, io->length, actions->first.time );


        if ((io->ioflags & IS_EXCEPTION) != 0)
	{
          if (conf_exceptions_inhibit == 0)
	  {
	    output_io_header(excf);
            fprintf( excf, "%4d:%3d %13.9f ",
	            inProgress,	      /* add +0, the io is still on mainio_list */
	            inFlight+1,       /* add +1 for the io just completed       *//* lun queue depth      */
                 actions->first.time );
	    if ((noIns == 0) && (noDis == 0))
                fprintf( excf, "%8.4f %13.6f %13.6f %%%3d ", dTime.Q2I*1000.0, dTime.Q2D*1000.0, dTime.D2C*1000.0, D2C_percent );
	    else
	    {
	        if (noIns == 0) fprintf( excf, "%8.4f ", dTime.Q2I*1000.0 );
	        else            fprintf( excf, "  -.---- ");
	        if (noDis == 0) fprintf( excf, "%13.6f %13.6f %%%3d ", dTime.Q2D*1000.0, dTime.D2C*1000.0, D2C_percent );
	        else            fprintf( excf, "     -.------     -.------- %% -- ");
	    }
            fprintf( excf, "%13.6f %3d %8d %-4s %4ld %14lu",
                dTime.Q2C * 1000.0,
                io->cpu,
                io->pid,
                io->evttyp,
                io->length,
                io->sector );
            if (flag_alignchk != 0)
                fprintf( excf," %s", alignchk );
            fprintf( excf, " %13ld %-22s %3d%c%3d%s\n", seek, name, io->info->cnt_requeues, (io->info->cnt_sleeps==0)?' ':'S', io->info->cnt_merges, smerge );

            if (io->ctracker == NULL)
		fprintf( excf, "    [---] ctracker ptr is null?\n");
	    else
	    {
		bgn_tmo_line = -1;
	        end_tmo_line = -1;
	        bgn_tmo_time = 0.00;
                end_tmo_time = 0.00;
	        for (ndx=0; ndx<io->ctracker->used_completions; ndx++)
		{
	 	    if (ndx==0)
		    {
			bgn_tmo_line = io->ctracker->completions[ndx].line;
			bgn_tmo_time = io->ctracker->completions[ndx].time;
		    }
		    end_tmo_line = io->ctracker->completions[ndx].line;
		    end_tmo_time = io->ctracker->completions[ndx].time;
		
		    fprintf( excf, "   [%3d] %13.9f  %*.*s       %4ld %14lu 'C'omplete event%s\n", ndx+1, 
			io->ctracker->completions[ndx].time, 66,66," ",
                        io->ctracker->completions[ndx].length,
                        io->ctracker->completions[ndx].sector,
		       (io->ctracker->completions[ndx].length>0)?"":" ; missing length in event - Nth C for (F)WFS io?" );
		}	              
		if ((bgn_tmo_line != -1) && (io->ctracker->used_completions > 1))
		{
		    fprintf( excf, "%%I[%05d]-multiple C events for request across %4d input lines, range %11d - %11d (tmo deadline %11d (%11d))\n", __LINE__, 
			end_tmo_line - bgn_tmo_line, bgn_tmo_line, end_tmo_line, io->ctracker->tmo_line, io->ctracker->tmo_line_value );
		    fprintf( excf, "%%I[%05d]-multiple C events for request across %11.6f time, range %11.6f - %11.6f (tmo deadline %11.6f (%11.6f))\n", __LINE__,
			end_tmo_time - bgn_tmo_time, bgn_tmo_time, end_tmo_time, io->ctracker->tmo_time, io->ctracker->tmo_time_value );
		}
	    }
	    if ((io->ioflags & IS_DUPE_COMPS) != 0)
		fprintf( excf, "%%W[%05d]-request has duplicate completions for same bio detected.\n", __LINE__ );
	    fprintf( excf, "\n\n");
	  }
	}
    }
    else
    {
/*
#Prg:Flt   Queue(s)   Q2I(ms)   Q2D(ms)   D2D(ms)   D2C(ms)          Q2C(ms)   CPU      PID Typ  Size         Sector         Seek  Description            reQ Merges:sectors,...
#---:--- ----------- -------- ----------- ------- -----------+---- ----------- --- -------- ---- ---- -------------- ------------- ---------------------- --- ---:-------------------------
   0:  0  53.0024032   0.0027   0000.0037  0.0000   0000.1922 % 99   0000.1925   8 13979    R    256       70778368      46949632 [(null):pid not found]   0   0
1234 123 123.56789x1 123.5678 123456.89x1 12.4567 123.56789x1  123 123.56789x1 123 12345678 123 1234 123456789.1234 123456789.123 123456789.123456789.12 123 123 123456789.123456789.12345
         999.9999999 999.9999 999999.9999 999.999 999999.9999  100 999999.9999 999 99999999 123 9999 99999999999999 -999999999999 123456789.123456789.12 999 999:123456789.123456789.12345
*/
        fprintf( outf, "%3d|%4d:%3d %11.7f ",
	     (staged_on_list <= 999)?staged_on_list:999, 
	     inProgress,	                                /* add +0, the io is still on mainio_list */
	     (((inFlight+1) <= -1000)?-999:(inFlight+1)),       /* add +1 for the io just completed       *//* lun queue depth      */
             actions->first.time );
        if ((device_lvm == 0) || (state.device_nvme != 0))
            fprintf( outf, "%8.4f %11.4f %7.3f %11.4f %%%3d ", dTime.Q2I*1000.0, dTime.Q2D*1000.0, dTime.D2D*1000.0, dTime.D2C*1000.0, D2C_percent );
        else
            fprintf( outf, "%8.4f %11.4f %7.3f %11.4f %%%3d ", 0.0, 0.0, 0.0, 0.0, 0 );
        fprintf( outf, "%11.4f %3d %8d %-4s %4ld %14lu",
            dTime.Q2C * 1000.0,
            io->cpu,
            io->pid,
            io->evttyp,
            io->length,
            io->sector ); 
        if (flag_alignchk != 0)
            fprintf( outf," %s", alignchk );
	if (flag_shortform == 0) fprintf( outf, " %13ld %-22s %3d%c%3d%s\n", seek, name, io->info->cnt_requeues, (io->info->cnt_sleeps==0)?' ':'S', io->info->cnt_merges, smerge );
	else                     fprintf( outf, "\n");
	dbg_out_events_in_io(io,outf);
        if (io->info->cnt_sleeps > 1)
            fprintf( outf, " %%W[%05d]-IO sleep count %d > 1!?\n", __LINE__, io->info->cnt_sleeps );
        if (io->ioflags & IS_SAMEIODRIVR)
            fprintf( outf, " %%%c[%05d]-overlapping io in driver   detected %c:%08ld.%06ld @%11.7f\n", (io->prmtyp==IOTYP_WRITE)?'E':'W', __LINE__,
                _prmtyp(io->prmtyp), io->sector, io->length, actions->first.time );
        else if (io->ioflags & IS_SAMEIOSCHED)
            fprintf( outf, " %%W[%05d]-overlapping io in scheduler detected %c:%08ld.%06ld @%11.7f\n", __LINE__,
                _prmtyp(io->prmtyp), io->sector, io->length, actions->first.time );



        if ((io->ioflags & IS_EXCEPTION) != 0)
	{
          if (conf_exceptions_inhibit == 0)
	  {
	    output_io_header(excf);
            fprintf( excf, "%4d:%3d %11.7f ",
	         inProgress,	        /* add +0, the io is still on mainio_list */
	         inFlight+1,                /* add +1 for the io just completed       *//* lun queue depth      */
                 actions->first.time );
            if ((device_lvm == 0) || (state.device_nvme != 0))
                fprintf( excf, "%8.4f %11.4f %7.3f %11.4f %%%3d ", dTime.Q2I*1000.0, dTime.Q2D*1000.0, dTime.D2D*1000.0, dTime.D2C*1000.0, D2C_percent );
            else
                fprintf( excf, "%8.4f %11.4f %7.3f %11.4f %%%3d ", 0.0, 0.0, 0.0, 0.0, 0 );
            fprintf( excf, "%11.4f %3d %8d %-4s %4ld %14lu",
                dTime.Q2C * 1000.0,
                io->cpu,
                io->pid,
                io->evttyp,
                io->length,
                io->sector ); 
            if (flag_alignchk != 0)
                fprintf( excf," %s", alignchk );
            fprintf( excf, " %13ld %-22s %3d%c%3d%s\n", seek, name, io->info->cnt_requeues, (io->info->cnt_sleeps==0)?' ':'S', io->info->cnt_merges, smerge );

            if (io->ctracker == NULL)
		fprintf( excf, "    [---] ctracker ptr is null?\n");
	    else
	    {
	        for (ndx=0; ndx<io->ctracker->used_completions; ndx++)
		{
                bgn_tmo_line = -1;
                end_tmo_line = -1;
                bgn_tmo_time = 0.00;
                end_tmo_time = 0.00;
                for (ndx=0; ndx<io->ctracker->used_completions; ndx++)
                {
                    if (ndx==0)
                    {
                        bgn_tmo_line = io->ctracker->completions[ndx].line;
                        bgn_tmo_time = io->ctracker->completions[ndx].time;
                    }
                    end_tmo_line = io->ctracker->completions[ndx].line;
                    end_tmo_time = io->ctracker->completions[ndx].time;

                    fprintf( excf, "   [%3d] %13.9f  %*.*s       %4ld %14lu 'C'omplete event%s\n", ndx+1,
                        io->ctracker->completions[ndx].time, 66,66," ",
                        io->ctracker->completions[ndx].length,
                        io->ctracker->completions[ndx].sector,
                       (io->ctracker->completions[ndx].length>0)?"":" ; missing length in event - possibly 2nd C for (F)WFS type io?" );
                }                     
		if ((bgn_tmo_line != -1) && (io->ctracker->used_completions > 1))
                {
		    fprintf( excf, "%%I[%05d]-multiple C events for request across %4d input lines, range %11d - %11d (tmo deadline %11d (%11d))\n", __LINE__, 
			end_tmo_line - bgn_tmo_line, bgn_tmo_line, end_tmo_line, io->ctracker->tmo_line, io->ctracker->tmo_line_value );
		    fprintf( excf, "%%I[%05d]-multiple C events for request across %11.6f time, range %11.6f - %11.6f (tmo deadline %11.6f (%11.6f))\n", __LINE__,
			end_tmo_time - bgn_tmo_time, bgn_tmo_time, end_tmo_time, io->ctracker->tmo_time, io->ctracker->tmo_time_value );
                }
		}
            }
	    if ((io->ioflags & IS_DUPE_COMPS) != 0)
		fprintf( excf, "%%W[%05d]-request has duplicate completions for same bio detected.\n", __LINE__ );
	    fprintf( excf, "\n\n");
	  }
	}
    }
    if ((io->ioflags & IS_DUPE_COMPS) != 0)
    {
	if ( state.reported_duplicate_completions++ < MAX_REPORTED_DUPLICATE_COMPLETIONS)
            fprintf( outf, " %%W[%05d]-request has duplicate completions for same bio detected, see exceptions file.\n", __LINE__ );
	else if (flag_max_once == 0)
	{
	    flag_max_once++;
            fprintf( outf, " %%W[%05d]-request has duplicate completions for same bio detected, see exceptions file.\n", __LINE__ );
            fprintf( outf, " %%I[%05d]-turning off further duplicate 'C'ompletion detection against same request/BIO\n",__LINE__);
	}
    }
	    

    /* output to 'parse.buckets' text file... */ /* This is "new", aka not ORIGINAL_RECIPE */
    fprintf( bckf, "%12ld+%d ", io->info->numb_bucket, (end - io->info->numb_bucket));
    fprintf( bckf, "%4d:%3d %11.7f ", inFlight+1 /* +1 for the io just completed */, inProgress, actions->first.time );
    if ((device_lvm == 0) || (state.device_nvme != 0))
        fprintf( bckf, "%11.7f %11.7f %11.7f %%%3d ", dTime.Q2I, dTime.Q2D, dTime.D2C, D2C_percent );
    else
        fprintf( bckf, "%11.7f %11.7f %11.7f %%%3d ", 0.0, 0.0, 0.0, 0 );
    fprintf( bckf, "%11.7f %4d %5d %-4s %8d %16lu", dTime.Q2C,
        io->cpu,
        io->pid,
        io->evttyp,
        io->length,
        io->sector );
    fprintf( bckf, " %12ld %-22s %4d%c%3d\n", seek, name, io->info->cnt_requeues, (io->info->cnt_sleeps==0)?' ':'S', io->info->cnt_merges );


    dfprintf( outf, "DBG: io queue %12.9f insert %12.9f dispatch %12.9f complete %12.9f\n", 
	actions->first.time, actions->insert.time, actions->dispatch, actions->complete );
    dfprintf( outf, "DBG: last  complete %12.9f\n", state.last_queue_t );
    fflush(outf);

    /* Do *NOT* update sector:length for a Barrier completion */
    /* Barriers are not real io so didn't affect sector loc   */
    /* on disk. These are FWS:0:0 io, zero length             */
    if (((io->evtflags & EVTFLG_GHOST) == 0) &&
        ((io->specials & SPCFLG_00   ) == 0))
    {
    state.last_completed_sector   = io->sector;
    state.last_completed_length   = io->length;
    }
    state.last_queue_t            = io->info->events.complete.time;

    /* With emc powerpath devices, a 'D'ispatch or other expected sub-event may not be present. */
    /* Prevent dTime calcs from using 0-queue time in those cases to avoid negative X2Y times   */
    /* Using 0.0001 seconds as minimum although really should be able to detect 0.0 I'm not     */
    /* sure I trust that logic at the moment with floating point math.                          */
    dprintf(       "queue        insert        Q2I          dispatch    Q2D           completed     Q2C          cpu pid     iotyp    size           sector    name/string\n");
    dprintf(       "%12.9f %12.9f/%12.9f %12.9f/%12.9f %12.9f/%12.9f %4d %5d %-4s %8d %16lu %s\n",
	actions->first.time,
	actions->insert.time,   dTime.Q2I,
	actions->dispatch.time, dTime.Q2D,
	actions->complete.time, dTime.Q2C,
	io->cpu,
	io->pid,
	io->evttyp,
	io->length,
	io->sector,
	io->procname );
    fflush(stdout);

#   ifdef DEEP_DEBUG1
    /* Debug logic to enable if we're looking to track a specific sector */
    if (event->sector < 128452096)
         return(0);
#   endif

    if (((io->evtflags & EVTFLG_GHOST) == 0) &&
        ((io->specials & SPCFLG_00   ) == 0))
    {
	/* GHOST and BARRIERS are excluded from contributing to stats info */
	/* GHOST = partial io information				   */
	/* BARRIER = non-data movement io (length:0)			   */
             if (io->length <= EVENTDATA_SUBPAGE) ndx = 0;
        else if (io->length <= EVENTDATA_SMALL  ) ndx = 1;
        else if (io->length <= EVENTDATA_MEDIUM ) ndx = 2;
        else if (io->length <= EVENTDATA_LARGE  ) ndx = 3;
        else if (io->length <= EVENTDATA_JUMBO  ) ndx = 4;
        else                                      ndx = 5;
        eventdata[ndx].count++;
        eventdata[ndx].D2D += dTime.D2D;
        eventdata[ndx].Q2C += dTime.Q2C;
    
        eventdata[ndx].Q2I += dTime.Q2I;
        eventdata[ndx].Q2D += dTime.Q2D;
        eventdata[ndx].D2C += dTime.D2C;
   }
    _return(0);
}


/**
 * ==========================================================================================
 * Function : 
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns :
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int output_remaining()
{
typ_io *io;

    fprintf( outf, "#\n#\n#====================================================================================================\n");
    fprintf( outf, "#===== Stage Queue: %6d Remaining ================================================================\n", staged_on_list );
    for (io=staged_list; io != NULL; io = io->next)
	output_completed_io(io,"",STAGED_QUEUE);
    if (staged_list != NULL) fprintf( outf, "#\n");
    fprintf( outf, "#===== ActiveQueue: %6d Remaining ================================================================\n", mainio_on_list );
    for (io=mainio_list; io != NULL; io = io->next)
	output_completed_io(io,"",MAINIO_QUEUE);
    if (mainio_list != NULL) fprintf( outf, "#\n");
    if (postio_list != NULL)
    {
        fprintf( outf, "#===== Post  Queue: %6d Remaining -===============================================================\n", postio_on_list );
        for (io=postio_list; io != NULL; io = io->next)
	    output_completed_io(io,"",POSTIO_QUEUE);
        fprintf( outf,   "#\n" );
    }
    fprintf( outf, "#====================================================================================================\n\n");

    return(0); 
} 


/* SECTION: FUNCTION BLOCK ; template|temp area */
/* ================================================================================================================= */
/* ================================================================================================================= */
/* ================================================================================================================= */

int xxxxx_event(typ_event *this)
{
typ_io *io, *temp;
int rw;
int onmain= 0;
int nonio = 0;
int valid = 0;
typ_actions *actions, temp_actions;
int    line;
double time;
static char eventname[16]="...event..";

    TRACE_FUNCTION;
    io = NULL;
    if ((rw = R_OR_W(this))                    >= 0) valid++;
    if ((this->evtflags & EVTFLG_VALID_SECTOR) != 0) valid++;
    if ((this->evtflags & EVTFLG_VALID_SIZE  ) != 0) valid++;
    if (valid == 3)
    { 
        /* Search mainio/active list for this event -- should be here      */
        io = search_mainio1(this,io,eventname,&onmain);
    }
    else
    {           
        dprintf( "DBG[%05d]: io filtered off, will not search stage queue for io\n", __LINE__ );
        /* will never be able to match this to a staging io so just build new io */
        /* Need to create and backfill a mainio ... or just move to exceptions   */
        /* and forget about it.                                                  */
        nonio = 1;
    }


    if (io != NULL) 
    {
        printf( "DBG[%05d]: looking for @%12.9f:%8lu+%6lu, found %12.9f:%8lu+%6lu on %s list\n", __LINE__, 
	    this->timeinfo.time, this->sector, this->length, 
              io->timeinfo.time,   io->sector,   io->length,
	    onmain==0?"staged":"mainio" );

	/* state.InProgress/Inflight updates, if any  */

        /* Now housekeeping, update last event        */
        /* @@@TBD review which fields other lstevt    */
        io->lstcpu =  this->cpu;
        io->lstact =  this->prmact;
        strcpy(io->lsttyp, this->evttyp);
        bcopy(this, &io->lstevt, sizeof(typ_event));

        _assert(io->info != NULL);
        if (state.isPlugged == 1) io->info->plug_state |= PLUGSTATE_Q;

        /* capture I event info in events                           */
        if (io->info != NULL) actions = &io->info->events;
        else                  actions = &temp_actions;
        line = this->timeinfo.line;
        time = this->timeinfo.time;

        if (actions->dispatch.line != 0)
        {
             /* this is first dispatch event for this io */
             actions->dispatch_first.line = line;
             actions->dispatch_first.time = time;

             /* only grab a ticket @first dispatch time  */
             /* Assigning event Q/I/D/C timestamp processing.                 */
             /* ISeqNo will be used to calc iosched reorder @dispatch time    */
             state.ISeqNo++;
             io->info->ISeqNo = state.ISeqNo;

	     /* inProgress counts are updated in move to mainio routines */
        }
        io->event_mask            |= EVTMSK_I; /* @@ */
	set_event_mask( io,          EVTNDX_I );
        actions->dispatch.line     = line;
        actions->dispatch.time     = time;
        io->info->cnt_inserts++;
        io->info->ISeqNo_Ghost     = state.ISeqNo;    /* this just reflects D ticket in state at last D event for this io, not assigned ticket, it "ghosts" ticket # */
   
        tprintf( "tDBG[%05d]: event %c:%16ld.%8ld assign insert time %13.9f\n", __LINE__, _prmtyp(this->prmtyp), this->sector, this->length, this->timeinfo.time );


        /* Merge event flags, add procname if not previously available,     */
        /* ditto for extras.                                                */
        io->evtflags |= this->evtflags;
	if ((this->procname[0] != 0) && (io->procname[0] == 0))
        {
	    /* should be there unless this is backfill */
            strcpy(io->procname, this->procname);
	}
	if ((this->extras[0] != 0) && (io->extras[0] == 0))
        {
            strcpy(io->extras  , this->extras  );
	}

        if (io->info->events.insert.time < io->info->events.first.time )
        {
            dprintf( "%%E[%05d]: insert io %10ld %6ld F:%12.9f > I:%12.9f (%12.9f)\n", __LINE__, this->sector, this->length, 
                io->info->events.first.time, 
	        io->info->events.insert.time,
                io->info->events.insert.time - io->info->events.first.time );
        }
	else
	{
            dprintf( "%%I[%05d]: insert io %10ld %6ld F:%12.9f < I:%12.9f (%12.9f)\n", __LINE__, this->sector, this->length,
                io->info->events.first.time, 
	        io->info->events.insert.time,
                io->info->events.first.time - io->info->events.insert.time );
	}

        samp.cnt_inserts++;
        summ.cnt_inserts++;
        test_sample_time_boundary(io);
    }
    else if (nonio == 0)
    {
        /* Nope, not on either list. Weird */
        /* new one: this needs to be backfilled, but for now add event to exceptions list and ignore */
        /* @@@TBD */
        printf( "%%F[%05d]-tbd, missing feature.\n", __LINE__ );
	MISS_FEATURE_FAULT(this,(int),"not implemented yet",CTL_FAULT_DEFAULT);
    }

    event_sig_add(io, this);	/* Add matched event signature to io context */

    /* last thing before returning, output annotated event           */
    annotate_event(this,3,io);
    _return(0);
}

/* SECTION: FUNCTION BLOCK ; FAULT PROCESSING FUNCTIONS */
/* ================================================================================================================= */
/* ================================================================================================================= */
/* ================================================================================================================= */

/**
 * ==========================================================================================
 * Function : runtime_fault()
 * Args     : @this	   current event being processed
 *            @funcname    function name where fault occurred
 *             lineno      source code line number where fault was detected
 *            @rsn	   reason/explanation of the fault
 *             ctl         control/override conf_terminate_onfault_*, if needed
 *
 * Returns :  exits or returns zero
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * 'ctl' should be forced (but is ignored here as all runtime errors force exit)
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/

unsigned long _runtime_fault(typ_event *event, const char funcname[], int lineno, char *rsn, int ctl )
{
    if ((rsn != NULL) && (*rsn != 0))
	printf( "%%F[%05d]-runtime fault detected in %s:%5d ; '%s'\n", __LINE__, funcname, lineno, rsn );
    else
	printf( "%%F[%05d]-runtime fault detected in %s:%5d \n",       __LINE__, funcname, lineno, rsn );

    /* runtime (program) fault exit is not controllable/configurable.  Just exit. */
    _EXIT( trace_printf( 1, funcname, lineno )?(1):(1) );
}
/**
 * ==========================================================================================
 * Function : _discard_processing_fault()   
 * Args     : @this	   current event being processed
 *            @funcname    function name where fault occurred
 *             lineno      source code line number where fault was detected
 *            @rsn	   reason/explanation of the fault
 *             ctl         control/override conf_terminate_onfault_*, if needed
 *            @
 * Args     : @q:          request queue to send scsi commands down
 *
 * Returns : exit or zero
 *
 * Description
 * A discard of an event is being done due to some reason other than notarget (no matching io found)
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * 'ctl' should be passed in as 0:DEFAULT, the normal conf_ will then continue after discard unless compiled 
 * with -DDEBUG option, and then will exit like it did previously.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
unsigned long _discard_processing_fault(typ_event *this, const char funcname[], int lineno, char *rsn, int ctl )
{
char dummy[32]="";
int slen, spad;
char *ptr;
int typ = 0; /* 0=default, 1=ignore, -1=force */
             
    FAULT_CTL(ctl,typ,nofeature);

    if ((rsn != NULL) && (*rsn != 0))
        printf( "%%%c[%05d]-discard event fault in %s:%5d ; '%s'\n", (typ!=-1)?'E':'F', __LINE__, funcname, lineno, rsn );
    else
        printf( "%%%c[%05d]-discard event fault in %s:%5d \n",       (typ!=-1)?'E':'F', __LINE__, funcname, lineno      );

    /* We should never halt on a discard? */
    if (typ == CTL_FAULT_FORCE)
    {
        if (ctl == CTL_FAULT_DEFAULT)
            logHprintf( "%%I[%05d]-changing 'conf_terminate_onfault_nofeature=%d' to 0 will allow continuing...\n", __LINE__, conf_terminate_onfault_nofeature );
        _EXIT( trace_printf( 1, funcname, lineno )?(1):(1) );
    }

    /*
     * 1) set event EXCEPTION, DISCARD, flags 
     * 2) make sure event is output into exceptions
     * 3) change state counters
     * 4) output to exceptions
     **/
    if (this != NULL)
    {
        printf( "DBG[%05d]: continuing after discard of '%c' event.\n", lineno, this->prmact );
        if ((this->evtflags & EVTFLG_NOFEATURE) == 0)
        {
            this->evtflags |= EVTFLG_NOFEATURE;
            state.events_nofeature++;
        }
        if ((this->evtflags & EVTFLG_DISCARDED) == 0)
        {
            this->evtflags |= EVTFLG_DISCARDED;
            state.events_discarded++;
	    if (this->prmact != 'C') state.events_discarded_nonC++;
        }
        if ((this->evtflags & EVTFLG_EXCEPTION) == 0)
        {
            this->evtflags |= EVTFLG_EXCEPTION;
            state.events_exceptions++;
	    if ((this->prmact == 'P') || (this->prmact == 'U'))
	        state.events_exceptplugs++;
        }
        if ((this->evtflags & EVTFLG_EXCEPTDONE) == 0)
        {
            if (conf_exceptions_inhibit == 0)
            {
                ptr = dummy;
                if ((rsn != NULL) && (*rsn != 0)) ptr = rsn;
                slen = strlen(ptr);
                spad = (80-24) - slen;
                if (spad <= 0) spad = 1;
                fprintf( excf, "%4d: [%08d] '%s' %*.*s ; discard: processing err-%s\n", state.num_exceptions,
                    this->timeinfo.line, this->event_text, spad,spad," ", ptr );
            }
            this->evtflags |= EVTFLG_EXCEPTDONE;
        }
        printf( "DBG[%05d]: continuing after discard of '%c' event.\n", lineno, '?' );
    }
    else
    {
        printf( "DBG[%05d]: continuing after discard of '%c' event.\n", lineno, '?' );
	printf( "DBG[%05d]: %s:%d missing event, this=NULL?\n", __FUNCTION__, __LINE__ );
    }
    return(0);
}

/**
 * ==========================================================================================
 * Function : _program_processing_fault()
 * Args     : @this	   current event being processed
 *            @funcname    function name where fault occurred
 *             lineno      source code line number where fault was detected
 *            @rsn	   reason/explanation of the fault
 *             ctl         control/override conf_terminate_onfault_*, if needed
 *
 * Returns :  exits or returns zero
 *
 * Description
 * Log the fault and exit as ctl will be passed in as FORCE in all nominal cases. Cannot continue from a program fault.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * 'ctl' should always be passed in a -1, force.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
unsigned long _program_processing_fault(typ_event *this, const char funcname[], int lineno, char *rsn, int ctl )
{
static char dummy[32]="";
int typ = 0;
int slen, spad;
char *ptr;

    FAULT_CTL(ctl,typ,progproc)

    if ((rsn != NULL) && (*rsn != 0))
	printf( "%%%c[%05d]-program internal logic/processing fault in %s:%5d ; '%s'\n", (typ!=-1)?'E':'F', __LINE__, funcname, lineno, rsn );
    else
	printf( "%%%c[%05d]-program internal logic/processing fault in %s:%5d \n",       (typ!=-1)?'E':'F', __LINE__, funcname, lineno      );

    /* We should never halt on a discard? */
    if (typ == CTL_FAULT_FORCE)
    {
        if (ctl == CTL_FAULT_DEFAULT)
            logHprintf( "%%I[%05d]-changing 'conf_terminate_onfault_progproc=%d' to 0 will allow continuing...\n", __LINE__, conf_terminate_onfault_progproc );
        _EXIT( trace_printf( 1, funcname, lineno )?(1):(1) );
    }


    /*
     * 1) set event EXCEPTION, DISCARD, MISSFEAT flags 
     * 2) make sure event is output into exceptions
     * 3) change state counters
     * 4) output to exceptions
     */
    if (this != NULL)
    {
	if ((this->evtflags & EVTFLG_NOFEATURE) == 0)
	{
	    this->evtflags |= EVTFLG_NOFEATURE;
	    state.events_nofeature++;
	}
	if ((this->evtflags & EVTFLG_DISCARDED) == 0)
	{
	    this->evtflags |= EVTFLG_DISCARDED;
	    state.events_discarded++;
            if (this->prmact != 'C') state.events_discarded_nonC++;
	}
	if ((this->evtflags & EVTFLG_EXCEPTION) == 0)
	{
	    this->evtflags |= EVTFLG_EXCEPTION;
	    state.events_exceptions++;
	    if ((this->prmact == 'P') || (this->prmact == 'U'))
	        state.events_exceptplugs++;
	}
        if ((this->evtflags & EVTFLG_EXCEPTDONE) == 0)
        {
	    if (conf_exceptions_inhibit == 0)
            {
		ptr = dummy;
	        if ((rsn != NULL) && (*rsn != 0)) ptr = rsn;
	        slen = strlen(ptr);
                spad = (80-24) - slen;
                if (spad <= 0) spad = 1;
	        fprintf( excf, "%4d: [%08d] '%s' %*.*s ; discard: processing err-%s\n", state.num_exceptions, 
	            this->timeinfo.line, this->event_text, spad,spad," ", ptr );
	    }
	    this->evtflags |= EVTFLG_EXCEPTDONE;
	}
        printf( "%%E[%05d]-continuing after program processing fault\n", lineno );
    }
    else
    {
        printf( "%%E[%05d]-continuing after program processing fault\n", lineno );
	printf( "DBG[%05d]: %s:%d missing event, this=NULL?\n", __FUNCTION__, __LINE__ );
    }
    return(0);
}

/**
 * ==========================================================================================
 * Function : _program_processing_fault1()
 * Args     : @this        current typ_io struct being processed (may be null)
 *            @funcname    function fault detected in
 *             lineno      source line detection
 *            @rsn         reason/explanation of the missing feature
 *             ctl         control exit via overrides
 *
 * Returns :  exits program or returns zero
 *
 * Description
 * Log the fault and exit. Cannot continue from a program fault.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * 'ctl' should always be passed in a -1, force.
 * this varient passed in typ_io and not typ_event
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
unsigned long _program_processing_fault1(typ_io *this, const char funcname[], int lineno, char *rsn, int ctl )
{
static char dummy[32]="";
char request_info[256];
int typ = 0;
int slen, spad;
char *ptr;

    FAULT_CTL(ctl,typ,progproc)

    if ((rsn != NULL) && (*rsn != 0))
	printf( "%%%c[%05d]-program internal logic/processing fault in %s:%5d ; '%s'\n", (typ!=-1)?'E':'F', __LINE__, funcname, lineno, rsn );
    else
	printf( "%%%c[%05d]-program internal logic/processing fault in %s:%5d \n",       (typ!=-1)?'E':'F', __LINE__, funcname, lineno      );

    /* We should never halt on a discard? */
    if (typ == CTL_FAULT_FORCE)
    {
        if (ctl == CTL_FAULT_DEFAULT)
            logHprintf( "%%I[%05d]-changing 'conf_terminate_onfault_progproc=%d' to 0 will allow continuing...\n", __LINE__, conf_terminate_onfault_progproc );
        _EXIT( trace_printf( 1, funcname, lineno )?(1):(1) );
    }


    /*
     * 1) set event EXCEPTION, DISCARD, MISSFEAT flags 
     * 2) make sure event is output into exceptions
     * 3) change state counters
     * 4) output to exceptions
     */
    if (this != NULL)
    {
	if ((this->evtflags & EVTFLG_NOFEATURE) == 0)
	{
	    this->evtflags |= EVTFLG_NOFEATURE;
	    state.events_nofeature++;
	}
	if ((this->evtflags & EVTFLG_DISCARDED) == 0)
	{
	    this->evtflags |= EVTFLG_DISCARDED;
	    state.events_discarded++;
            if (this->prmact != 'C') state.events_discarded_nonC++;
	}
	if ((this->evtflags & EVTFLG_EXCEPTION) == 0)
	{
	    this->evtflags |= EVTFLG_EXCEPTION;
	    state.events_exceptions++;
	    if ((this->prmact == 'P') || (this->prmact == 'U'))
	        state.events_exceptplugs++;
	}
        if ((this->evtflags & EVTFLG_EXCEPTDONE) == 0)
        {
	    if (conf_exceptions_inhibit == 0)
            {
		ptr = dummy;
	        if ((rsn != NULL) && (*rsn != 0)) ptr = rsn;
	        slen = strlen(ptr);
                spad = (80-24) - slen;
                if (spad <= 0) spad = 1;

		/** #Maj,Mn CPU   SeqNo     Seconds     PID  Evt Typ Sector   +Len Description
                    #------ --- ------- --------------- -----|--|---|---------+--- -------------------------------------
                       8,0    0       17     0.000733061 126042  Q  WS 7924051944 + 8 [db2sysc]
                **/
	        sprintf( request_info, "%4d,%-3d %3d %6d %15.9 %6d %2s %3s %d + %d %s %s\n",
	            this->major, this->minor, this->cpu, this->seqnum, this->timeinfo.time, this->pid, 
	            this->evtact, this->evttyp, this->length, this->sector, this->procname, this->extras );

	        fprintf( excf, "%4d: [%08d] '%s' %*.*s ; discard: processing err-%s\n", state.num_exceptions, 
	            this->timeinfo.line, request_info, spad,spad," ", ptr );
	    }
	    this->evtflags |= EVTFLG_EXCEPTDONE;
	}
        printf( "DBG[%05d]: continuing after program processing fault\n", lineno );
    }
    else
    {
        printf( "DBG[%05d]: continuing after program processing fault\n", lineno );
	printf( "DBG[%05d]: %s:%d missing event, this=NULL?\n", __FUNCTION__, __LINE__ );
    }
    return(0);
}


/**
 * ==========================================================================================
 * Function : _missing_feature_fault()
 * Args     : @this        current event
 *            @funcname    function fault detected in
 *             lineno      source line detection
 *            @rsn         reason/explanation of the missing feature
 *             ctl         control exit via overrides
 *
 * Returns :  typ_io *null nominally unless compiled with -DDEBUG, then exit
 *
 * Description
 * Log the fault and exit, or attempt to continue depending on policy setting.  
 *
 * If continuing, the current event is flagged as exception, et.al. and state 
 * counters are so updated to reflect this fault.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
unsigned long _missing_feature_fault(typ_event *this, const char funcname[], int lineno, char *rsn, int ctl )
{
static char dummy[32]="";
int typ = 0;
int slen, spad;
char *ptr;

    FAULT_CTL(ctl,typ,nofeature);

    if ((rsn != NULL) && (*rsn != 0))
	printf( "%%%c[%05d]-missing feature fault in %s:%5d ; '%s'\n", (typ!=-1)?'E':'F', __LINE__, funcname, lineno, rsn );
    else
	printf( "%%%c[%05d]-missing feature fault in %s:%5d \n",       (typ!=-1)?'E':'F', __LINE__, funcname, lineno      );

    if (typ == CTL_FAULT_FORCE)
    {
        if (ctl == CTL_FAULT_DEFAULT)
            logHprintf( "%%I[%05d]-changing 'conf_terminate_onfault_nofeature=%d' to 0 will allow continuing...\n", __LINE__, conf_terminate_onfault_nofeature );
        _EXIT( trace_printf( 1, funcname, lineno )?(1):(1) );
    }

    /*
     * 1) set event EXCEPTION, DISCARD, MISSFEAT flags 
     * 2) make sure event is output into exceptions
     * 3) change state counters
     * 4) output to exceptions
     */
    if (this != NULL)
    {
	if ((this->evtflags & EVTFLG_NOFEATURE) == 0)
	{
	    this->evtflags |= EVTFLG_NOFEATURE;
	    state.events_nofeature++;
	}
	if ((this->evtflags & EVTFLG_DISCARDED) == 0)
	{
	    this->evtflags |= EVTFLG_DISCARDED;
	    state.events_discarded++;
            if (this->prmact != 'C') state.events_discarded_nonC++;
	}
	if ((this->evtflags & EVTFLG_EXCEPTION) == 0)
	{
	    this->evtflags |= EVTFLG_EXCEPTION;
	    state.events_exceptions++;
	    if ((this->prmact == 'P') || (this->prmact == 'U'))
	        state.events_exceptplugs++;
	}
        if ((this->evtflags & EVTFLG_EXCEPTDONE) == 0)
        {
	    if (conf_exceptions_inhibit == 0)
            {
		ptr = dummy;
	        if ((rsn != NULL) && (*rsn != 0)) ptr = rsn;
	        slen = strlen(ptr);
                spad = (80-24) - slen;
                if (spad <= 0) spad = 1;
	        fprintf( excf, "%4d: [%08d] '%s' %*.*s ; discard:missing feature-%s\n", state.num_exceptions, 
	            this->timeinfo.line, this->event_text, spad,spad," ", ptr );
	    }
	    this->evtflags |= EVTFLG_EXCEPTDONE;
	}
        printf( "DBG[%05d]: continuing after nofeature fault\n", lineno );
    }
    else
    {
        printf( "DBG[%05d]: continuing after nofeature fault\n", lineno );
        printf( "DBG[%05d]: %s:%d missing event, this=NULL?\n", __FUNCTION__, __LINE__ );
    }
    return(0UL);
}
/**
 * ==========================================================================================
 * Function : _data_processing_fault()
 * Args     : @this        current event
 *            @funcname    function fault detected in
 *             lineno      source line detection
 *            @rsn         reason/explanation of the missing feature
 *             ctl         control exit via overrides
 *
 * Returns :  zero which is cast to typ_io * or int depending on caller
 *
 * Description
 * Log the fault and exit, or attempt to continue depending on policy setting.  
 * If continuing, set exception, discard, notarget flags.
 *
 * If continuing, the current event is flagged as exception, et.al. and state 
 * counters are so updated to reflect this fault.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
unsigned long _data_processing_fault(typ_event *this, const char funcname[], int lineno, char *rsn, int ctl )
{
static char dummy[32]="";
int typ = 0;
int slen, spad;
char *ptr;

    FAULT_CTL(ctl,typ,dataproc);

    if ((rsn != NULL) && (*rsn != 0))
	printf( "%%%c[%05d]-event processing fault in %s:%5d ; '%s'\n",(typ!=-1)?'E':'F',  __LINE__, funcname, lineno, rsn );
    else
	printf( "%%%c[%05d]-event processing fault in %s:%5d \n",      (typ!=-1)?'E':'F', __LINE__, funcname, lineno      );

    if (typ == CTL_FAULT_FORCE)
    {
        if (ctl == CTL_FAULT_DEFAULT)
            logHprintf( "%%I[%05d]-changing 'conf_terminate_onfault_dataproc=%d' to 0 will allow continuing...\n", __LINE__, conf_terminate_onfault_dataproc );
        _EXIT( trace_printf( 1, funcname, lineno )?(1):(1) );
    }

    /*
     * 1) set event EXCEPTION, DISCARD, NOTARGET flags 
     * 2) make sure event is output into exceptions
     * 3) change state counters
     * 4) output to exceptions
     */
    if (this != NULL)
    {
	if ((this->evtflags & EVTFLG_NOFEATURE) == 0)
	{
	    this->evtflags |= EVTFLG_NOTARGET;
	    state.events_notarget++;
	}
	if ((this->evtflags & EVTFLG_DISCARDED) == 0)
	{
	    this->evtflags |= EVTFLG_DISCARDED;
	    state.events_discarded++;
            if (this->prmact != 'C') state.events_discarded_nonC++;
	}
	if ((this->evtflags & EVTFLG_EXCEPTION) == 0)
	{
	    this->evtflags |= EVTFLG_EXCEPTION;
	    state.events_exceptions++;
	    if ((this->prmact == 'P') || (this->prmact == 'U'))
	        state.events_exceptplugs++;
	}
        if ((this->evtflags & EVTFLG_EXCEPTDONE) == 0)
        {
	    if (conf_exceptions_inhibit == 0)
            {
		ptr = dummy;
	        if ((rsn != NULL) && (*rsn != 0)) ptr = rsn;
	        slen = strlen(ptr);
                spad = (80-24) - slen;
                if (spad <= 0) spad = 1;
	        fprintf( excf, "%4d: [%08d] '%s' %*.*s ; discard:no target found-%s\n", state.num_exceptions, 
	            this->timeinfo.line, this->event_text, spad,spad," ", ptr );
	    }
	    this->evtflags |= EVTFLG_EXCEPTDONE;
	}
        logHprintf( "%%I[%05d]-continuing after data processing fault (%05d)\n", lineno, __LINE__ );
    }
    else
    {
        logHprintf( "%%I[%05d]-continuing after data processing fault (%05d)\n", lineno, __LINE__ );
        logHprintf( "%%I[%05d]- %s:%d missing event, this=NULL?\n", lineno, __FUNCTION__, __LINE__ );
    }
    return(0UL);
}

/**
 * ==========================================================================================
 * Function : _notarget_fault()
 * Args     : @this        current event
 *            @funcname    function fault detected in
 *             lineno      source line detection
 *            @rsn         reason/explanation of the missing feature
 *             ctl         control exit via overrides
 *
 * Returns :  zero which is cast to typ_io * or int depending on caller
 *
 * Description
 * Log the fault and exit, or attempt to continue depending on policy setting.  
 * If continuing, set exception, discard, notarget flags.
 *
 * If continuing, the current event is flagged as exception, et.al. and state 
 * counters are so updated to reflect this fault.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
unsigned long _notarget_fault(typ_event *this, const char funcname[], int lineno, char *rsn, int ctl )
{
static char dummy[32]="";
int typ = 0;
int slen, spad;
char *ptr;

    FAULT_CTL(ctl,typ,dataproc);

    if ((rsn != NULL) && (*rsn != 0))
	printf( "%%%c[%05d]-event processing fault in %s:%5d ; '%s'\n",(typ!=-1)?'E':'F',  __LINE__, funcname, lineno, rsn );
    else
	printf( "%%%c[%05d]-event processing fault in %s:%5d \n",      (typ!=-1)?'E':'F', __LINE__, funcname, lineno      );

    if (typ == CTL_FAULT_FORCE)
    {
	if (ctl == CTL_FAULT_DEFAULT)
	    logHprintf( "%%I[%05d]-changing 'conf_terminate_onfault_dataproc=%d' to 0 will allow continuing...\n", __LINE__, conf_terminate_onfault_dataproc );
        _EXIT( trace_printf( 1, funcname, lineno )?(1):(1) );
    }

    /*
     * 1) set event EXCEPTION, DISCARD, NOTARGET flags 
     * 2) make sure event is output into exceptions
     * 3) change state counters
     * 4) output to exceptions
     */
    if (this != NULL)
    {
	if ((this->evtflags & EVTFLG_NOFEATURE) == 0)
	{
	    this->evtflags |= EVTFLG_NOTARGET;
	    state.events_notarget++;
	}
	if ((this->evtflags & EVTFLG_DISCARDED) == 0)
	{
	    this->evtflags |= EVTFLG_DISCARDED;
	    state.events_discarded++;
            if (this->prmact != 'C') state.events_discarded_nonC++;
	}
	if ((this->evtflags & EVTFLG_EXCEPTION) == 0)
	{
	    this->evtflags |= EVTFLG_EXCEPTION;
	    state.events_exceptions++;
	    if ((this->prmact == 'P') || (this->prmact == 'U'))
	        state.events_exceptplugs++;
	}
        if ((this->evtflags & EVTFLG_EXCEPTDONE) == 0)
        {
	    if (conf_exceptions_inhibit == 0)
            {
		ptr = dummy;
	        if ((rsn != NULL) && (*rsn != 0)) ptr = rsn;
	        slen = strlen(ptr);
                spad = (80-24) - slen;
                if (spad <= 0) spad = 1;
	        fprintf( excf, "%4d: [%08d] '%s' %*.*s ; discard:no target found-%s\n", state.num_exceptions, 
	            this->timeinfo.line, this->event_text, spad,spad," ", ptr );
	    }
	    this->evtflags |= EVTFLG_EXCEPTDONE;
	}
        logHprintf( "%%I[%05d]-continuing after data processing fault (%05d)\n", lineno, __LINE__ );
    }
    else
    {
        logHprintf( "%%I[%05d]-continuing after data processing fault (%05d)\n", lineno );
        logHprintf( "%%I[%05d]- %s:%d missing event, this=NULL?\n", lineno, __FUNCTION__, __LINE__ );
    }
    return(0UL);
}

/**
 * ==========================================================================================
 * Function : find_remaps()
 * Args     :  to_major    device major number being remapped into
 *             to_minor    device minor number being remapped into
 *             from_major  device major number being remapped from
 *             from_minor  device minor number being remapped from
 *
 * Returns :  
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
typ_remaps *find_remaps( int to_major, int to_minor, int from_major, int from_minor )
{
int ndx;
    for (ndx=0; ndx<remaps_used; ndx++)
    {
	if (remaps[ndx].to_minor   !=   to_minor) continue;
	if (remaps[ndx].from_minor != from_minor) continue;
	if (remaps[ndx].from_major != from_major) continue;
	if (remaps[ndx].to_major   !=   to_major) continue;
	return(&remaps[ndx]);
    }
    if (remaps_used < (MAX_ARRAY_REMAPS-2))
    {
	ndx = remaps_used++;
	remaps[ndx].from_major = from_major;
        remaps[ndx].from_minor = from_minor;
        remaps[ndx].to_major   =   to_major;
        remaps[ndx].to_minor   =   to_minor;
	return(&remaps[ndx]);
    }
    printf( "%E[%05d]-remaps[%d] array exhausted, need to increase array size.\n", __LINE__, MAX_ARRAY_REMAPS );
    return((typ_remaps *)NULL);
}
int dump_remaps()
{
int ndx;

    if (remaps_used != 0)
    {
        fprintf( outf, "#SUM: \n");
        fprintf( outf, "#SUM:|--------|---------|-----------------------|----------------------|\n");
        fprintf( outf, "#SUM:|   REMAP COUNTS   |  ______ Reads _______ |______ Writes _______ |\n");
        fprintf( outf, "#SUM:|   From |   To    |    Count      Sectors |   Count      Sectors |\n");
        fprintf( outf, "#SUM:|--------|---------|---------+-------------|---------+------------|\n");
        /*                    xxx,xxx  xxx,xxx    xxxxxxxx xxxxxxxxxxxx  xxxxxxxx xxxxxxxxxxxx */
  	for (ndx=0; ndx<remaps_used; ndx++)
	{
            fprintf( outf, "#SUM: %3d,%3d  %3d,%3d    %8ld %12ld  %8ld %12ld\n", 
		remaps[ndx].from_major, remaps[ndx].from_minor,
		remaps[ndx].to_major,   remaps[ndx].to_minor,
		remaps[ndx].read_count, remaps[ndx].read_sectors,
		remaps[ndx].write_count,remaps[ndx].write_sectors);
	}
    }

    return(0);
}





/* SECTION: APPENDIX BLOCK */
/* ================================================================================================================= */
/* ================================================================================================================= */
/* ================================================================================================================= */

/*
2) why is seqno not tracking completions events?
3) why does inprog/inflight show large numbers but 9254/9257 sane numbers? (drained queue)?
4) tottime/maxawait, avgawait stats not filled in.
*/

/*

DBG[09148]: state
DBG[09149]: ===================================================================================
DBG[09150]:   5333::'CPU0 (sda):'
DBG[09151]:   5332::'CPU0 (sda):'
DBG[09152]: Plug   P:00000086            U:00000086 (isPlugged=0)
DBG[09154]: SeqNo  x:00005330 Q:00000902 S:00000000 G:00000000 M:........ F:........ I:00000000 D:00000514 R:00000000 C:00000000 (inProgress=00000902, inFlight=00000514)
DBG[09157]: Events A:00001804 Q:00000902 S:00000000 G:00000514 M:00000388 F:00000000 I:00000514 D:00000514 R:00000000 C:00000514 x:00000000
DBG[09176]: inProgress: 0000000 - R:       0 W:       0 ok
DBG[09179]: inFlight  : 0000000 - R:       0 W:       0 ok
DBG[09182]: started   : 0000514 - R:       0 W:     514
DBG[09185]: completed : 0000514 - R:       0 W:     514
DBG[09188]: inprogress: 0000000 - R:       0 W:       0
DBG[09193]: TotTime   :           R:  0.0000 W:  0.0000
DBG[09195]: MaxAwait  :           R:  0.0000 W:  0.0000 (  0.0000)
DBG[09197]: AvgAwait  :           R:  0.0000 W:  0.0000 (  0.0000)
DBG[09201]: oddIO     : conflicted:     0 overlapped:     0 (active=     0)
DBG[09203]: orphans   :   0.00000000 =      0, next check in 1000 io (current time=116.26790878)
DBG[09205]: --------------------------------------------------------------------

%I-successful completion

[ ] summary blocks at 1 second interval
[ ] summary file      1 second interval output to separate file so blktrace_parse doesn;t have to
[ ] make sure summary line includes %time for D2C from overall Q2C!

*/


/*
 * Broke following case
 *

253,2    6       46     3.965716479 14317  A   R 264140032 + 512 <- (253,3) 264131840
253,2    6       47     3.965716970 14317  Q   R 264140032 + 512 [FwgThread read ]
253,2    6       48     3.965718587 14317  G   R 264140032 + 512 [FwgThread read ]
253,2    6       49     3.965719473 14317  P   N [FwgThread read ]
253,2    6       50     3.965753180 14317  A   R 264140544 + 512 <- (253,3) 264132352
253,2    6       51     3.965753400 14317  Q   R 264140544 + 512 [FwgThread read ]
253,2    6       52     3.965755390 14317  M   R 264140544 + 512 [FwgThread read ]
253,2    6       53     3.965775310 14317  A   R 264141056 + 512 <- (253,3) 264132864
253,2    6       54     3.965775528 14317  Q   R 264141056 + 512 [FwgThread read ]
253,2    6       55     3.965776198 14317  M   R 264141056 + 512 [FwgThread read ]
253,2    6       56     3.965797421 14317  A   R 264141568 + 512 <- (253,3) 264133376
253,2    6       57     3.965797643 14317  Q   R 264141568 + 512 [FwgThread read ]
253,2    6       58     3.965798284 14317  M   R 264141568 + 512 [FwgThread read ]
253,2    6       59     3.965819630 14317  A   R 264142080 + 512 <- (253,3) 264133888
253,2    6       60     3.965819856 14317  Q   R 264142080 + 512 [FwgThread read ]
253,2    6       61     3.965820676 14317  M   R 264142080 + 512 [FwgThread read ]
253,2    6       62     3.965841376 14317  A   R 264142592 + 512 <- (253,3) 264134400
253,2    6       63     3.965841587 14317  Q   R 264142592 + 512 [FwgThread read ]
253,2    6       64     3.965842224 14317  M   R 264142592 + 512 [FwgThread read ]
253,2    6       65     3.965842758 14317  I   R 264140032 + 3072 [FwgThread read ]

1st merge cannot find its baseio to merge into.

--bgn:004494-----------------------------------------      1:       1
253,2    6       51     3.965753400 14317  Q   R 264140544 + 512 [FwgThread read ]
DBG[10223]: looking for @ 3.965753400:264140544+   512, found  3.965753180:264140544+   512
253,2    6       51     3.965753400 14317  Q   R 264140544 + 512 [FwgThread read ]             ;#P1          610          0          0|   1|   1:   1,   0|   0:   0,   0|         
--end------------------------------------------------


--bgn:004495-----------------------------------------      1:       1
253,2    6       52     3.965755390 14317  M   R 264140544 + 512 [FwgThread read ]
%F[10570]-tbd, missing feature.

DBG[10495]: mainio list  0xf91060 264140032:   512;264140543v264140544...
DBG[10528]: check staged list for match 264140544:   512... <= looking for base/mainio to merge into that end sector

DBG[10495]: mainio list  0xf91060 264140032:   512;264140543v264140544...
                                       +512
                                        544    << end+1, so this should be start of M and it is
                                       1055    ends on this sector.

this.  off by 1 issue.  
        tgt_sector = temp->sector + temp->length - (this->length>0?1:0);  << this is the problem we backed up 1 but tgt is end+1 so it was
        fine as is!

*/
/*
 *

Failing to find mainio for merge:  No A|Q for G|I of 016 which results in no mainio for 024.

1213:  8,0   10       82     0.160774276 27645  G  WS 101174016 + 8 [TaniumClient]
1214:  8,0   10       83     0.160775526 27645  I  WS 101174016 + 8 [TaniumClient]
1216:  8,0   10       85     0.160784560 27645  A  WS 101174024 + 8 <- (8,2) 100147976
1217:  8,0   10       86     0.160785594 27645  Q  WS 101174024 + 8 [TaniumClient]
1218:  8,0   10       87     0.160787053 27645  M  WS 101174024 + 8 [TaniumClient]
1559:  8,0    7      334     0.164541924     0  D  WS 101174016 + 24 [swapper]
1564:  8,0    7      335     0.164544368     0  R  WS 101174016 + 24 [0]
1565:  8,0    7      336     0.164544570     0  I  WS 101174016 + 24 [swapper]
1566:  8,0    7      337     0.164545098     0  D  WS 101174016 + 24 [swapper]
1567:  8,0    7      338     0.164545381     0  R  WS 101174016 + 24 [0]
1568:  8,0    7      339     0.164545550     0  I  WS 101174016 + 24 [swapper]
2807:  8,0    3       50     0.165223527 15558  D  WS 101174016 + 24 [java]

So this:
%W[11274]-could not find 'main' io request to getrequest        101174016:       8 into @  8,0   10       82     0.160774276 27645  G  WS 101174016 + 8 [TaniumClient], line=1213 (limit=400), Qevents=116 (limit=200)
  8,0   10       82     0.160774276 27645  G  WS 101174016 + 8 [TaniumClient]                  ;#P1

results in no mainio... but this is pretty far into sda.blktrace.txt to be missing a A|Q event!?

Looked in verify, no errors, this event is just flat out missing from the event list.  And while CPU 10 has
handled D and C events, this is the first time an io ia originating on CPU 10's processes.  It just not there. full stop.

Before we changed the logic to either top of file .or. qevent count is under limit, issue warning -- the G event would
have generated an error and stopped processing. Even now if an %E is created for missing events therefore missing requests,
it will no longer stop/fail.  So we're at a juncture where "missing" requests where we expect one need to be created
and dummied up, and in some cases dummy up the time values but in a way we know they are dummied up so on output these
get flagged .AND. the whole request is not counted towards iostat type statistics.

The S|G|I events are pretty straight forward, the missing Q time should should be set to the current time.  For M|F
its more complicated if mainio request context is missing -- we've no idea how long ago this context should have been
created.  Still, dummy up Q|I times to make the A|Q|M time in the merge context.  If we just hit a M|F first, then we
have to dummy up a staged A|Q for this M|F first, and then might have to dummy up a request structure to merge into
if that too is missing (likely, but if not then the M|F dummy need is suspect and should generate a warning).

Hitting D|R|C events without a context -- we don't want to simply ignore them, especially on D events because a C 
will at least get us a D2C number to display.  So with extra trepedation create a dummy request target for D|R events
if no main io is present.  Just be aware that such requests don't have a real BIO list -- it could be a merged request --
so we could end getting multiple C events that we flat out cannot process/validate.  So add that to C processing, if
the dummy event is triggerted by D event, then the first matching C event declares a whole io complete, issues warning
that it is doing so, and any follow-on C events just get absorbed with a knowing head nod -- nothing else can be done
as we don't really know the makeup of the BIOs under the request in terms of number.  All we have via D|R time is a sector
and length for the request.

GHOST Requests
======================================================================================================================
If we need to create a target request structure due to missing prior events, this request will be flagged as a "GHOST"
request.  A ghost request also has an assigned shade of gradiant.  For example, creating a ghost due to a S event, the
ghost is pretty "visible", that is the missing A|Q time is likely very very close to the S time.  So a ghost gradiant
set to G vs D has implications of how trustworthy the manufactured time stamps are.  

While ghosts should always be output as part of C processing, they are different from normal requests.
    1) stats from ghosts are not counted against "iostat" type accumulations, 
    2) they should not be considered inflight/inprogress -- we just don't know enough about ghosts to guarantee
       they will complete as normal.
    3) there may be other stuff about ghosts, but not using them for stats in any manner should side step those 
       issues.
    4) the number of ghosts created (and the number of ghosts completing) should be tracked and output at the
       end of processing.
    5) if there are ghost requests created second hand (an M event cannot find the main request to merge into
       is cause for creating a second hand ghost), then such a request is so marked with a zero gradiant -- its
       nearly transparent.  Creating a second hand ghost opens up the possibility the a C event over covers
       a ghost or even covers multiple second hand ghosts.  So tracking the number of such 2nd hand ghosts as
       a separate subclass of ghosts is important.

Assigning Event Time Values in Ghosts
---------------------------------------------------------------------------------------------------------------------
Assigning a event time value for missing events helps prevent specialized code at output time but also can result in
misleading values.  For the latter we need to flag merged output lines that are the result of ghosting.  For the former
we need a means to flag a action:line pair to indicate that this is not a natural time value assignment but a ghost'ed
assignment.  Rather than pick a number like -1 or 1 as these should not happen and are not 0 (lines 0 & 1 should be 
the added header lines starting with '#' -- but we can't guarantee that the *.blktrace.txt line was created using our
blktrace_parse.bsh script (which puts those two header lines in the output).  So instead we're going to be a huge
end of range type number.  The state.line is unsigned long so lets choose 0xFFFFFFFF.FFFFFFFF.  So if we create a
ghost time value within a request, tag it with GHOST_LINENUM.


Also, first and foremost -- EVERY *blktrace.txt for results in ghost requests being created should be carefully
manually analyzed to verify that ghost creation is warranted.

A|Q S|G|I  M|F D|R C -- I *think* that is all the cases.

A|Q   - no dummy needed as these trigger request to be created on staged
S|G|I - create a dummy, flag dummy, set dummy "gradiate" at S|G|I, and set request start time at current event time
        + the problem with I is we can't know if this is {A|Q|S|G|I|D|R}...I -- that is the I we're seeing is insert
          post requeue.  So I gradiates are much more suspect than S or G.  However, the number of I due to R should
          be a corner case so while possible, it is much lower probability.  But we should flag all ghosts forced by
          I events to include a warning to this affect (could be corner case post-R).
M|F   - create a dummy, flag dummy, set dummy "gradiate" at M|F which is near equivalent to S|G|I, ditto setup of dummy
        + however, M|F is the one case that it not only has to find its staged request structure, it then has to find
          a 2nd mainio request structure that it will be merged into and *THAT* request might not exist.  So how to 
          dummy that up and flag it.  Especially then we can have a C event that more than covers this BIO within the
          request.  Also, this logic can end up fracturing via creation of multiple requests when really only 1 exists.
          So a C comes along and it really only applies to one request, but the program has dummied up several mainio
          requests with disjointed BIO that in truth are all under this other request -- we just don't know it because
          we never saw the original BIO that all later BIO were glommed onto.  For example Q and then Q2|M2 but primary
          Q not seen so create request for Q2M2 to merge into, results req2 only has this BIO.  Then Q3|F3 happen. Again
          no primary exists a new request created/dummied and now we have two dummied requests which really should only
          be 1.  Then a C event comes along covering req3, missing request, req2.  This becomes a very complicated case
          to deal with -- we'd need to not only allow 1 C to cover multiple requests if those requests were dummied up,
          but actively encourage doing so.  For efficiency purposes we should keep a count of the number of ghost requests
          created, and number that have been completed and output.  That way if the diff between the two is zero, no
          ghosts exist and the code *may* be able to not have to check on corner cases as much.  This type of complication
          only exists for M|F and only where the original request the merge is trying to target does not exist.  In this
          particular example above it won't happen because we'll have created a request ghost at the G event for that request
          that is missing A|Q.
D|R    - create a ghost/dummy request, flag dummy, set dummy gradiate to D|R 


*/

/*
 *

Case data: ./blktrace.testdata/SF02710169/blktrace.02710169-capture/run-202000815-02251/sda.blktrace.txt

Hit a first case where merging of active io (requests) was done as seen below.
The program got to the point where it was detecting an I event matching multiple
active requests.  But the issue is that we didn't detect multiple active io being
merged as a result of a M|F event.  In this case io 1, 3, 2 submitted.  2 is merged
onto 1, and then 3 ... which is sitting on the active list, is merged into 1,2 and
that request is gone.  This really clouds kernel iostats, like weighted queue depth,
as up to this point in the sample its based upon requests x dtime.  But the requests
count was "false", this just reduced it.  Worse case? submit io as 1,3,5,7 ... delay
as long as possible and then start submitting random even ones so slowly the whole
thing coelesces into 1 io.  Meanwhile the req x dtime is ticking away and in the end
that accumulator / active-sample-time will yeild an average queue depth.  Ultimately
we know the queue depth will be 1, but the above will generate a kinda of whacky
number.

DBG[04224]: active            0x5e600c0[ 250] ->    0x5e5fba0    8,  0  24.72054817 'A'     WS AQ.GM..I...,01 3:        33128752,      16 000004 merges=   2 requeues=   0 sleeps=   0
DBG[04224]: active            0x5e5fba0[ 251] ->        (nil)    8,  0  24.72053931 'A'     WS AQ.G...I...,01 3:        33128768,       8 000004 merges=   0 requeues=   0 sleeps=   0

DBG[00411926] 33128744:33128776 '  8,0    6    14239    24.720539741  1794  A  WS 33128768 + 8 <- (8,2) 32102720'  << io [251] in the above list.
DBG[00411927] 33128744:33128776 '  8,0    6    14240    24.720540496  1794  Q  WS 33128768 + 8 [jbd2/dm-0-8]'
DBG[00411928] 33128744:33128776 '  8,0    6    14241    24.720542340  1794  G  WS 33128768 + 8 [jbd2/dm-0-8]'
DBG[00411929] 33128744:33128776 '  8,0    6    14242    24.720542707  1794  I  WS 33128768 + 8 [jbd2/dm-0-8]'

DBG[00411931] 33128744:33128776 '  8,0    6    14244    24.720548384  1794  A  WS 33128752 + 8 <- (8,2) 32102704'
DBG[00411932] 33128744:33128776 '  8,0    6    14245    24.720548583  1794  Q  WS 33128752 + 8 [jbd2/dm-0-8]'
DBG[00411933] 33128744:33128776 '  8,0    6    14246    24.720549114  1794  G  WS 33128752 + 8 [jbd2/dm-0-8]'
DBG[00411934] 33128744:33128776 '  8,0    6    14247    24.720549730  1794  I  WS 33128752 + 8 [jbd2/dm-0-8]'

DBG[00411936] 33128744:33128776 '  8,0    6    14249    24.720555365  1794  A  WS 33128760 + 8 <- (8,2) 32102712'
DBG[00411937] 33128744:33128776 '  8,0    6    14250    24.720555536  1794  Q  WS 33128760 + 8 [jbd2/dm-0-8]'
DBG[00411938] 33128744:33128776 '  8,0    6    14251    24.720556225  1794  M  WS 33128760 + 8 [jbd2/dm-0-8]'
>> ok, this was merged on one above as this is back merge. new length = 16.

DBG[00431710] 33128744:33128776 '  8,0    7    50202    26.096735324     0  D  WS 33128752 + 24 [swapper]'  << how is this 24 sectors long?
>> oh, crapola! I see what happened. we had io 1, 3, 2: 2 merged onto end of 1, then 3 was merged onto end of 1,2!  Does it always work
>> that way or only in this version? This dispatch likely created a ghost when it should not have and made things worse.  Should we allow
>> multiple merge pases to suck in existing io up to some max length? This is going to crap all over iostats as the weighted average
>> is number of requests x delta and the request count just dropped ... but didn't really, its artificial.
DBG[00431711] 33128744:33128776 '  8,0    7    50203    26.096736299     0  R  WS 33128752 + 24 [0]'
DBG[00431712] 33128744:33128776 '  8,0    7    50204    26.096736414     0  I  WS 33128752 + 24 [swapper]'
DBG[00431713] 33128744:33128776 '  8,0    7    50205    26.096736768     0  D  WS 33128752 + 24 [swapper]'
DBG[00431714] 33128744:33128776 '  8,0    7    50206    26.096737020     0  R  WS 33128752 + 24 [0]'
DBG[00431715] 33128744:33128776 '  8,0    7    50207    26.096737155     0  I  WS 33128752 + 24 [swapper]'
DBG[00431717] 33128744:33128776 '  8,0    4    80150    26.104138556     0  D  WS 33128752 + 24 [swapper]'
DBG[00435513] 33128744:33128776 '  8,0    7    50800    26.479185995     0  C  WS 33128752 + 24 [0]'

So the question is how to deal with this.  Waiting until D time seems the most reasonable, if we have 
a sector match but not a length match, then go looking for other active io without a D event that could
be added to this io to increase the length up to but not exceeding the specified lenght.  If a full pass
yeilds result, do the merge and deal with the ticket consequences/stats as best can.  The big one is 
that inProgress count is going to retreat for no apparent reason.  One way of forstalling that is to give
an io an inProgress weight - which is typically 1 - but in the case were we merge on the queue itself,
due to 2nd hand affects, then can bump that weight in the io and deal with it at inProgress change time.

First lets see what the program did at the above 'D' time for length of 24 vs expected 16.

--bgn:431710-----------------------------------------      0:     252
  8,0    7    50202    26.096735324     0  D  WS 33128752 + 24 [swapper]
DBG[02237]: verify_staged_list(ok)
DBG[02238]: verify_mainio_list(ok)
DBG[06810]: check mainio list for match 33128752:    24...

DBG[06813]: mainio list  0x524b0c0      33128752:    16...  << this didn't work because the 2nd hange merge didn't happen.
DBG[06813]: mainio list  0x524aba0      33128768:     8...  << this didn't get sucked into/merged up to length of 24

Annnnndddd, yes we create a ghost for 24 leaving two requests stranded on the active queue.
So need a "corner" case @D time.  Give it one more go to see if we can find enough adjacent active
io to the above sector to merge up to cover the 24 lenght.  We don't have to look fore of the specified
starting sector of D as this is definitive anchor sector that starts the io.  Only interested in finding
io immediately after this one.  It might take several passes to find all the ones needed.  And event then
this is kind of a "hold you breath" and hope its finding the correct related requests.

%E[05092]-could not find 'main' io request to dispatch           33128752:      24 into @  8,0    7    50202    26.096735324     0  D  WS 33128752 + 24 [swapper], discarding; line=431710 (limit=400), QEvents=56986 (limit=200)
DBG[05253]: create ghost, trigger is 'D' event: '  8,0    7    50202    26.096735324     0  D  WS 33128752 + 24 [swapper]'
DBG[08168]:                create_io(D WS     33128752+24 '[swapper]')
DBG[08454]:              mov_mainio (0x54b06c0 D WS     33128752+24 '[swapper]') <= move ghost io mainio list

Additions needed:

If at D time we cant find a match, relook to see if we can find a partial match starting at specified sector.
 - relook again to see if we can find another request that matches starting at the ending sector.  Since this
   is a 2nd hand merge, that io could be before or after the base one found above hence the need for a complete
   respin.  Find the "oldest" one would be my guess, so go through the whole list and save the last one found?
   add this to length.  Does this satisfy the D event length? if so, stop/exit search loop and evaluate what
   was found.  If not, reset end sector and reloop again looking for another request, latter in fifo is best,
   to further extend the io.  Rinse/Repeat.  

Lets see if the above helps or hurts.  This is a odd case I'm not expecting to see too often (fingers crossed)
where multiple io/requests are created separately then a merge request on one io allows a 2nd hand merge onto
an other pre-existing io/request on the active queue (like in the example above).  The first time we'll actually
notice is at D time.


*/


/*
 * Notes 10/30/2020 2nd hand merging 
 *

DBG[05335]: 2nd Hand Merging detected.  Merge the following requests on mainio into 1!
DBG[05336]:  2 io on list,        0 of       24 length left uncovered
DBG[05344]:  0. 33128752:      16 -> 33128768 (remaining:        8)
DBG[05346]:  -- list of events in this io:
   1: [00411931] '  8,0    6    14244    24.720548384  1794  A  WS 33128752 + 8 <- (8,2) 32102704'             ; [06116]
   2: [00411932] '  8,0    6    14245    24.720548583  1794  Q  WS 33128752 + 8 [jbd2/dm-0-8]'                 ; [06294]
   3: [00411933] '  8,0    6    14246    24.720549114  1794  G  WS 33128752 + 8 [jbd2/dm-0-8]'                 ; [07040]
   4: [00411934] '  8,0    6    14247    24.720549730  1794  I  WS 33128752 + 8 [jbd2/dm-0-8]'                 ; [07171]
   5: [00411938] '  8,0    6    14251    24.720556225  1794  M  WS 33128760 + 8 [jbd2/dm-0-8]'                 ; [06551]

DBG[05348]:  -- list of subio  in this io:
DBG[05350]:  1.0xf29ba20 33128752:00000008
DBG[05350]:  2.0xf29af40 33128760:00000008
DBG[05351]:  -- end subio --

DBG[05344]:  1. 33128768:       8 -> 33128776 (remaining:        0)
DBG[05346]:  -- list of events in this io:
   1: [00411926] '  8,0    6    14239    24.720539741  1794  A  WS 33128768 + 8 <- (8,2) 32102720'             ; [06116]
   2: [00411927] '  8,0    6    14240    24.720540496  1794  Q  WS 33128768 + 8 [jbd2/dm-0-8]'                 ; [06294]
   3: [00411928] '  8,0    6    14241    24.720542340  1794  G  WS 33128768 + 8 [jbd2/dm-0-8]'                 ; [07040]
   4: [00411929] '  8,0    6    14242    24.720542707  1794  I  WS 33128768 + 8 [jbd2/dm-0-8]'                 ; [07171]

DBG[05348]:  -- list of subio  in this io:
DBG[05351]:  -- end subio --

>> Note that in this case the 2nd request is being merged into the base request... but that 2nd request is
>> actually from a earlier time and we're not pulling the A/Q/I times from this earlier request, but
>> probably should.  We should even pull the line numbers when we do this so that the new merged requests
>> reflect the real time this request started... which is that 2nd request we're going to free/discard
>> after merging.

*/



/*
 * 10/30/2020 notes
 *
#Prg:Flt   Queue(s)     Q2I(ms)   Q2D(ms)       D2C(ms)            Q2C(ms)     CPU      PID Typ  Size         Sector         Seek  Description            reQ Merges:sectors,...
#---:--- ------------- -------- ------------- -------------+---- ------------- --- -------- ---- ---- -------------- ------------- ---------------------- --- ---:---------------------
 238:168   0.057470302   0.0033      0.015832    253.666832 % 99    253.682664   7     3474 WS      8     2174603008             0 [java]                   0   0: [GHOST]
   1: [00000015] '  8,0    7        5     0.057470302  3474  G  WS 2174603008 + 8 [java]'                      ; [07083]
   2: [00000017] '  8,0    7        7     0.057473598  3474  I  WS 2174603008 + 8 [java]'                      ; [07214]
   3: [00000019] '  8,0    2        2     0.057486134  2824  D  WS 2174603008 + 8 [flush-253:2]'               ; [07369]
   4: [00006736] '  8,0    4      174     0.311152966     0  C  WS 2174603008 + 8 [0]'                         ; [07986]


This is an example of a ghost that was created.  The first event seen is a 'G' (no A|Q|S) - that triggers
the creation of a ghost request.  Ghosts do not participate in statistics as it is incomplete data (program
synthesizes some of the times and line numbers so output happens... but its not fully accurate.

*/




/* 11/02/2020
 *

Getting a *ton* of these in one of the datasets.  Note the sector:length of 0:0 only appears in the A
request.  The Q|G|I|C (no D?!) all have no sector:length or just a sector (length?) in the C event.

  8,6    0       10     0.000619252 126042  A FWS 0 + 0 <- (253,2) 0  << note this is against device 4.18++ (dm-2 -> sda5, but its really dm-2 -> sda...)
  8,0    0       11     0.000619652 126042  Q FWS [db2sysc]           << but this is against device  4.18!! (sda, not sda5 as expected per above)
  8,0    0       12     0.000620552 126042  G FWS [db2sysc]           << so there was a change whereby 2 events of 253,2 -> sda5 (8,6) -> sda (8,0) were 
  8,0    0       13     0.000621052 126042  I FWS [db2sysc]           << collapsed into one single 253-> sda event, but the intermediate target of 8,6 still output.
  8,0    0       14     0.000920178 108767  C  WS 0 [0]               << events are matched on sector .AND. target device and there is no such match here.

  8,6    0       24     0.001427820 126042  A FWS 0 + 0 <- (253,2) 0
  8,0    0       25     0.001428220 126042  Q FWS [db2sysc]
  8,0    0       26     0.001429121 126042  G FWS [db2sysc]
  8,0    0       27     0.001429621 126042  I FWS [db2sysc]
  8,0    0       28     0.001757148     0  C  WS 0 [0]


The result was we accumulated some 20,000 io in the staged queue due to the A events, but never advanced
further as there was no follow-on events for 0:0 context.  It *may* be the the blkparse package utility
fixed this in later versions so that 0+0 was output.  Will need to check on 4.18.  Checked, same output.
So either the sector/length isn't there or its zero and not validated as being needed for output or
was excluded in the original binary stream.  Given the numbe of these present, and no D events!??!!,
we need to create a target and allow these as a special case and set the D time value to either I or 
C time.  Inclined to set them to I time as there is non-trivial amounts of time between I and C, but
need to mark them so that on the right hand margin these are called out as unusual sector 0:0 event
type.  It also means we cannot simply throw away events that don't contain a sector:length as we're
doing here -- although the message implies its being tossed, its not explicit enough and that should
also be fixed... until we decide these are corner case of 0:0.

Meanwhile all these Q|G|I|C events get flagged as exceptoins due to insufficient format information

   0: [00000013] '  8,0    0       11     0.000619652 126042  Q FWS [db2sysc]'                                 ; [02831] event evtflags has EXCEPTION set
   0: [00000014] '  8,0    0       12     0.000620552 126042  G FWS [db2sysc]'                                 ; [02831] event evtflags has EXCEPTION set
   0: [00000015] '  8,0    0       13     0.000621052 126042  I FWS [db2sysc]'                                 ; [02831] event evtflags has EXCEPTION set
   0: [00000016] '  8,0    0       14     0.000920178 108767  C  WS 0 [0]'                                     ; [02831] event evtflags has EXCEPTION set
   0: [00000027] '  8,0    0       25     0.001428220 126042  Q FWS [db2sysc]'                                 ; [02831] event evtflags has EXCEPTION set
   0: [00000028] '  8,0    0       26     0.001429121 126042  G FWS [db2sysc]'                                 ; [02831] event evtflags has EXCEPTION set
   0: [00000029] '  8,0    0       27     0.001429621 126042  I FWS [db2sysc]'                                 ; [02831] event evtflags has EXCEPTION set
   0: [00000030] '  8,0    0       28     0.001757148     0  C  WS 0 [0]'                                      ; [02831] event evtflags has EXCEPTION set
   0: [00000041] '  8,0    1        2     0.001992868 126042  Q FWS [db2sysc]'                                 ; [02831] event evtflags has EXCEPTION set
   0: [00000042] '  8,0    1        3     0.001994068 126042  G FWS [db2sysc]'                                 ; [02831] event evtflags has EXCEPTION set
   0: [00000043] '  8,0    1        4     0.001994568 126042  I FWS [db2sysc]'                                 ; [02831] event evtflags has EXCEPTION set
   0: [00000044] '  8,0    0       38     0.002291693     0  C  WS 0 [0]'                                      ; [02831] event evtflags has EXCEPTION set


*/


/*
 * 11/02/2020
 *

--bgn:361048-----------------------------------------  14479:       5
  8,0    1    37182    52.456478154 87008  I   R 1577473594 + 2 [db2sysc]
DBG[05852]: staged list  0xb9e2540 1577473594:     2... <= 1st hit
DBG[05853]: staged list  0xb9e0800 1577473594:     2... <= Nth hit
>>
>> thousands of lines of list output -- expecation was these would be short!
>>
%F[05856]-tbd, resolve conflicting insert io in mainio queue with same lba+length  << this is unclear on the the event type in question.  add this to the message!


Program thinks it has detected two active io to same sector:length of 1577473594:2.

DBG[04271]: dump_mainio_list(5)
DBG[04272]: ===================================================================================
DBG[04274]: current_mainio        (nil)[    ]
DBG[04304]: active            0xb9e2540[   0] ->    0xb9e16a0    8,  0  52.45647475 'A'      R AQ.G.......,00 3:      1577473594,     2 000004 merges=   0 requeues=   0 sleeps=   0
DBG[04304]: active            0xb9e16a0[   1] ->    0xb9e0800    8,  0  52.45616123 'A'      R AQ.G...ID..,00 3:      1577685914,     2 000004 merges=   0 requeues=   0 sleeps=   0
DBG[04304]: active            0xb9e0800[   2] ->    0xb9df960    8,  0  52.45612042 'A'      R AQ.G...ID..,00 3:      1577473594,     2 000004 merges=   0 requeues=   0 sleeps=   0
DBG[04304]: active            0xb9df960[   3] ->    0xb9deac0    8,  0  52.45351690 'A'      R AQ.G...ID..,00 3:      1589219420,     4 000004 merges=   0 requeues=   0 sleeps=   0
DBG[04304]: active            0xb9deac0[   4] ->        (nil)    8,  0  52.44995771 'A'     WS AQ.G...ID..,01 3:      7923489744,     8 000004 merges=   0 requeues=   0 sleeps=   0
DBG[04281]: --------------------------------------------------------------------

The 0 and 2 indices in the list above.

Think its this sequence? No?! huh?

  8,0    1    37170    52.456120624 84573  A   R 1577473594 + 2 <- (8,3) 1575370298
  8,0    1    37171    52.456121224 84573  Q   R 1577473594 + 2 [db2sysc]
  8,0    1    37172    52.456122824 84573  G   R 1577473594 + 2 [db2sysc]
  8,0    1    37174    52.456123924 84573  I   R 1577473594 + 2 [db2sysc]
  8,0    1    37176    52.456125024 84573  D   R 1577473594 + 2 [db2sysc]
                                            <--------------------------------------------+
                       52.45647475                                                       | << original timestamp
  8,3    1    37177    52.456474754 87008  A   R 1575370298 + 2 <- (253,4) 1575368250    | << double remap nesting
  8,0    1    37178    52.456474954 87008  A   R 1577473594 + 2 <- (8,3) 1575370298      |
  8,0    1    37179    52.456475454 87008  Q   R 1577473594 + 2 [db2sysc]                |
  8,0    1    37180    52.456477154 87008  G   R 1577473594 + 2 [db2sysc]                |
  8,0    1    37182    52.456478154 87008  I   R 1577473594 + 2 [db2sysc]                | << tripped on this [1]
  8,0    1    37184    52.456479254 87008  D   R 1577473594 + 2 [db2sysc]                |
  8,0    0   237066    52.456587363 30586  C   R 1577473594 + 2 [0]           -----------+
  8,0    0   237067    52.456589363 30586  C   R 1577473594 + 2 [0]

[1] tripped here because prior events would only be looking at staged list and this
    would be the only io of sector:len on staged lists - the other prior one had
    been moved off to the mainio/active list already.  Then Insert comes along and
    it finds both active on the mainio list and is like huh?  This particular insert
    is easy to match, match the io that doesn't have an I event already.  Each event
    type will become increasingly difficult.  For example D is same, first one without
    a D event.  But both those become infinitly more difficult if there was a R event!!!
    Ditto for C, while I and D would match the latest io as that didn't have those 
    events, the same applies to C which would then match to the prior/earlier event that
    had already dispatched.  There is nothing that prevents a more chaotic event stream
    so that both io are still on staged list -- but the first pass logic for resolving
    these conflicts still seems to be earliest io without this event type.  While above
    there is only 1 io that matches that criteria, that won't always be the case.  But
    if it is the case, then confidence is high that its done the correct identification
    matching.  Less so if there are multiple hits (but still its *exact* type match to
    discriminate between W and WS for example, earliest, doesnt have this event and has
    pre-requisite events present.  So those four stages:
        . doesn't have this event
        . has the pre-requisite expected events present
        . is exact same full io type, and
        . is earliest timestamp of the above matching.
        . confidence = high if only 1 event matches all but time, and reasonable
          guess if there are multiple matches with earliest timestamp used as the
          tie breaker.



This is first overlapping active io case seen by this program.  It needs to discriminate
and choose "best match" which should be "first match" since the queue is FIFO based...
except in the case of where 2nd hand merging upsets the the time ordering in the list.
But best match is typically earliest active io that has the right pre-requisite events:
so for a C that is a D and for a D that is an I, etc.
 
*/

/* 
 * 11/02/2020
 *


DBG[04324]: dump_mainio_list(2)
DBG[04325]: ===================================================================================
                              Address   ndx         Next         _Dev_  Timestamp   Act Type_  EventMask__,nn x _____Sector_____, Len_  flags  counts
DBG[04328]: current_mainio        (nil)[    ]
DBG[04358]: active            0x1508280[   0] ->    0x1506e30    8,  0   0.37668844 'A'    FWS AQ.G.......,01 3:               0,     0 000004 merges=   0 requeues=   0 sleeps=   0
DBG[04358]: active            0x1506e30[   1] ->        (nil)    8,  0   0.37652233 'A'    FWS AQ.G...I...,01 3:               0,     0 000004 merges=   0 requeues=   0 sleeps=   0
DBG[04335]: --------------------------------------------------------------------

%F[06011]-tbd, resolve conflict insert     in mainio queue, multiple matches for lba+length; [    0.376690] I FWS          0:     0


Looks like this is a compound special case of "barrier" type event sequence without sector:length and overlapping io at 
the same time(?) 

  8,6    0     1682     0.376522330 126042  A FWS 0 + 0 <- (253,2) 0
  8,0    0     1683     0.376522630 126042  Q FWS [db2sysc]
  8,0    0     1684     0.376523130 126042  G FWS [db2sysc]
  8,0    0     1685     0.376523430 126042  I FWS [db2sysc]
  8,0    0     1686     0.376666742     0  C  WS 1576952800 + 6 [0] << this isn't for this barrier io!`

  8,3    1      581     0.376688444 53242  A FWS 0 + 0 <- (253,4) 0
  8,0    1      582     0.376688644 53242  Q FWS [db2sysc]
  8,0    1      583     0.376689444 53242  G FWS [db2sysc]                         ^ 1st special.1 (barrier like io)
  8,0    1      584     0.376689744 53242  I FWS [db2sysc]                         |
  8,0    0     1687     0.376879360     0  C  WS 0 [0]   --------------------------+

  8,0    0     1697     0.377212188 126042  C  WS 0 [0]  >> 2nd io.

So yes, the insert happens in the 2nd io and it finds the two io present.  The normal and special search loops
need to deal with same/same active io.  This still isn't the overlapping io case though... (where there is partial
but not complete overlap).



*/

/* 11/01/2020
 * TODO: 
 * 	 add SEC and SUM sections at end of input.  Those are currently missing completed vs
 * 	 old model output. Should look at a force "drain" of the postio queue before doing the
 * 	 above, which boundary checks after each -- but those are called in output_completed_io
 * 	 anyway, so drain should be just repeated calls to that routine as done at top of 
 * 	 complete_event() -- maybe refactor to its own routine with flag to control how it flushes
 * 	 either use tmo or force flush.
 *
 * 	 fix seek distance for BARRIERs to be 0, since there is no seek for zero length io		- done 11/09/2020
 *
 *       add message to *.merged if event is actually discarded, unless its a C event.			- tbd
 *
 *       add message to *.exceptions if event is actually discarded (not used), event C events.		- done but may need cleanup/de-dupe
 *
 *       add/tag selected io into event so @annotation time it can output "discarded" io info		- done 11/04/2020
 *
 *       verify that "barrier" io isn't counted in read/write stats as these are zero length		. io of 0:0 should be ignored in read/write counts?
 *       and aren't real io being zero length.  Check annotated output for clues.			. yes. because 0 length will skew avg request length etc.
 *       												. done, fixed in output_completed_io(), skips stats update
 *       												. if io is either BARRIER or GHOST as neither participate
 *       												. in stats.
 *
 *       Ditto for seek as I can easily tell that these zero length io are affecting last		. done, fixed in output_completed_io() where
 *       completed sector which affects calculated seek difference.					. state.last_completed_sector is updated.
 *
 *       add G|I processing to still check mainio for matches even if we find one on staged
 *       queue. We don't have to do it for S as its earlies promoter, no other event will come
 *       before it that would promote staged->main.  Ditto for G *if* state.cnt_sleeps = 0.
 *       So in normal data set this double look is only required for I and only if we find
 *       a match on staged. [The normal case is A|Q|G, promote to active.  And then at that
 *       point no typ:sector:length match is present on staged -- because normally we don't
 *       have duplicate typ:sector:length matches for active/outstanding io being tracked.]
 *
 *       Change how returned "best" interacts with "io".  Allow best_match() to return null
 *       if both io get disqualified.  This happens if there are 3 or more io present on the
 *       active queue, for example. The qualified io will typically be the latest (farthest
 *       down) within the queue.  So return into "best" instead of "io" and only if best is
 *       non-null then update io so that next iteration through best_match() continues to
 *       use valid in play io context (otherwise we might overwrite io with null).
 *
 *       add code to resolve multiple matches.  The best way to do this is at each Nth
 *       match, keep counters of n way matching.  Then validate doesn't have the current
 *       event already in either 1st (best tracker) or nth, that it has pre-requisiste 
 *       events, and is same full io type.  At that point with have a fully qualified
 *       match using more stringent checking, and hopefully only have 1 match.  But
 *       if we get to the point that 1st (best) is marked stringent qualified and the
 *       nth one is to, then we select the one with earliest timestamp and note all this
 *       in exceptions.
 *       :
 *       Add function best_match(this,io,temp,eventname) that takes the "best" choice
 *       between the current "best" (io, the pointer to 1st match) and temp (match to
 *       newest io context).  The "best" is chosen via the following filter:
 *       1) check that each do not have current event type in context already
 *       2) check that pre-requisite events are present
 *       3) check is *exact* full io type, FWS and not just a write.
 *       4) chose earliest timestamp if get here and both still "qualified"
 *       track confidence of choice:
 *           - high: if only 1 of io or temp matches 1-3
 *           - good: if multiple matches and had to use tie breaker of earliest
 *                   time stamp
 *
 *       keep stats on:
 *       1) number of io context where best_match() was called against the context, 
 *       2) number of total calls
 *       3) number of high or good confidence matching
 *       4) fatal error if both events are disqualified, that's a logic error.
 *
 *       There are two best_match; best_match() and best_match_special1().  The
 *       special1 is for special case.1 of the 0 length "barrier" like event 
 *       stream.  While generally, a dispatch could already exist *if* requeue
 *       had happened, but in special that is not allowed.  In special1 there
 *       are very restrictive allowances for other previous events since we
 *       know the exact sequence will be A,Q,G,I,C and anything else should get
 *       flagged as a fatal internal logic issue (for example, could a S occassionally
 *       happen in that sequence and still be this "barrier" signature?
 *
 *       Add output to indicate that best_match() was used (EVTFLG_BESTMATCH flag set)
 *       if io is non-null in the *_event() routines to counter act this:
 *
 *       --bgn:000014-----------------------------------------      1:       0
 *         8,0    0       12     0.000620552 126042  G FWS [db2sysc]
 *       DBG[02753]: set EXCEPTION flag on event:  [02752]: new (standard) format, but lba+len .or. procname not found/parsed
 *       >> need discard or not confirmation and if not, why event was "saved" and matched for use.
 *         8,0    0       12     0.000620552 126042  G FWS [db2sysc]                                    ; U0            2          0          0|   0|   1:   0,   1|   0:   0,   0|         
 *       --end------------------------------------------------
 *
 *       although in the above is search_special1() prevented the discard.  Just need to counteract
 *       that it wasn't discarded due to search_special() and or best_match() was applied to "save"
 *       the event from being discarded due to non-match to a context.
 *
 *       for search_special1() also output # events on the queue searched, a lot of the time it will
 *       be just 1! or more accurately the number in list and number that matched 0;0 criterial 1:1 or n:x
 *
 *       Add a DBG[] for when a 2nd hand merge is applied in the event logging stream (stdout).
 *
 * 	 Add notes for [GHOST] and [SPECIAL CASE.1] -- change that to "[BARRIER.1]" to the *.merged header?
 *
 * 	 add seekwatcher -t <trace> -o <trace>.png to blktrace_parse.bsh if seekwatcher present, and if not
 * 	 recommend installing the package for same, but this does not appear to be present in 4.18?!
 *
 */

/* 11/04/2020
 *

371612   8,3    0   242915    53.324136672 10317  A  WS 1575370340 + 2 <- (253,4) 1575368292
371613   8,0    0   242916    53.324136872 10317  A  WS 1577473636 + 2 <- (8,3) 1575370340
371614   8,0    0   242917    53.324137172 10317  Q  WS 1577473636 + 2 [db2sysc]
371615   8,0    0   242918    53.324138172 10317  G  WS 1577473636 + 2 [db2sysc]
371616   8,0    0   242919    53.324138573 10317  P   N [db2sysc]
371617   8,0    0   242920    53.324139173 10317  I  WS 1577473636 + 2 [db2sysc]
371618   8,0    0   242921    53.324139473 10317  U   N [db2sysc] 1
371619   8,0    0   242922    53.324139873 10317  D  WS 1577473636 + 2 [db2sysc]
371620   8,0    0   242923    53.324204678 86986  C  WS 7923490824 + 8 [0]

Normal sequence handled no problem... but then get A overlapping...

Two reads of sector 1575370340 from two different processes but at the exact same time, so we cannot
use timecode as differentiator in this case.  Add differentiator of using assigned remap ticket number?

371752   8,3    3    32894    53.330236986 126285  A   R 1575370340 + 2 <- (253,4) 1575368292  < instance #1
371753   8,3    2    56439    53.330236986 86260  A   R 1575370340 + 2 <- (253,4) 1575368292   < instance #2 -- same freakin' timestamp!!!
371754   8,0    2    56440    53.330237286 86260  A   R 1577473636 + 2 <- (8,3) 1575370340     < instance #1 -- hits 2 matching events and freaks
371755   8,0    3    32895    53.330237286 126285  A   R 1577473636 + 2 <- (8,3) 1575370340    <          #2
371756   8,0    2    56441    53.330237786 86260  Q   R 1577473636 + 2 [db2sysc]
371757   8,0    3    32896    53.330237886 126285  Q   R 1577473636 + 2 [db2sysc]
371758   8,0    3    32897    53.330239587 126285  G   R 1577473636 + 2 [db2sysc]
371759   8,0    2    56442    53.330239687 86260  G   R 1577473636 + 2 [db2sysc]
371760   8,0    2    56443    53.330240087 86260  P   N [db2sysc]
371761   8,0    3    32898    53.330240087 126285  P   N [db2sysc]
371762   8,0    3    32899    53.330240887 126285  I   R 1577473636 + 2 [db2sysc]
371763   8,0    3    32900    53.330241287 126285  U   N [db2sysc] 1
371764   8,0    3    32901    53.330241787 126285  D   R 1577473636 + 2 [db2sysc]
371765   8,0    2    56444    53.330244487 86260  I   R 1577473636 + 2 [db2sysc]
371766   8,0    2    56445    53.330244787 86260  U   N [db2sysc] 1
371767   8,0    2    56446    53.330244987 86260  D   R 1577473636 + 2 [db2sysc]
371768   8,0    0   242995    53.330373898 86724  C   R 1577473636 + 2 [0]
371769   8,0    0   242996    53.330380298 86724  C   R 1577473636 + 2 [0]


*/


/* 11/04/2020
 *

Another logic fault.

--bgn:781331-----------------------------------------      0:       5
  8,0    1    85040   112.890399574 87012  D   R 1577473598 + 2 [db2sysc]
DBG[05977]: mainio list  0x22214650 1577473598:     2... <= 1st hit
DBG[05978]: mainio list  0x22213020 1577473598:     2... <= Nth hit

DBG[04315]: dump_staged_list(0)
DBG[04316]: ===================================================================================
                              Address   ndx         Next         _Dev_  Timestamp   Act Type_  EventMask__,nn x _____Sector_____, Len_  flags  counts
DBG[04326]: --------------------------------------------------------------------


DBG[04379]: dump_mainio_list(5)
DBG[04380]: ===================================================================================
                              Address   ndx         Next         _Dev_  Timestamp   Act Type_  EventMask__,nn x _____Sector_____, Len_  flags  counts
DBG[04383]: current_mainio        (nil)[    ]
DBG[04413]: active           0x22214650[   0] ->   0x22213020    8,  0 112.89039727 'A'      R AQ.G.......,00 3:      1577473598,     2 000004 merges=   0 requeues=   0 sleeps=   0
DBG[04413]: active           0x22213020[   1] ->   0x22212530    8,  0 112.89038547 'A'      R AQ.G...ID..,00 3:      1577473598,     2 000004 merges=   0 requeues=   0 sleeps=   0
DBG[04413]: active           0x22212530[   2] ->   0x222110e0    8,  0 112.89038427 'A'      R AQ.G...I...,00 3:      1577473598,     2 000004 merges=   0 requeues=   0 sleeps=   0
DBG[04413]: active           0x222110e0[   3] ->   0x2220f9e0    8,  0 112.89037047 'A'    FWS AQ.G...I...,01 3:               0,     0 000004 merges=   0 requeues=   0 sleeps=   0
DBG[04413]: active           0x2220f9e0[   4] ->        (nil)    8,  0 112.87765730 'A'    FWS AQ.G...I...,01 3:               0,     0 000004 merges=   0 requeues=   0 sleeps=   0
DBG[04390]: --------------------------------------------------------------------

DBG[12862]: best_match(D,io=0x22214650,temp=0x22213020)
DBG[12982]: [112.890399574] D R ; io 01 0023: temp 00 0623; debug_mask 0400 (event not present)
DBG[12999]: io mask 0023
DBG[13000]: options FFFFFFCE (remove optional)
DBG[13001]: remains 0002
DBG[13002]: require 0202
DBG[13003]: results 0200 (must be zero)
DBG[13015]: [112.890399574] D R ; io 01 0023: temp 00 0623; event_mask 0233 0233 (pre-reqs present )
DBG[13036]: [112.890399574] D R ; io 05    R: temp 04    R
%F[13100]-internal logic fault: best_match() found neither qualified: [112.890399574] D R :: [112.890397274] A R , [112.890385473] A R

There are multiple errors.  There should be 4 instances on the queue for this sector:lenght but there is only 3.
Also 3 of the 

781308-  8,3    1    85025   112.890384273 11431  A   R 1575370302 + 2 <- (253,4) 1575368254   << instance #1
781309:  8,0    1    85026   112.890384573 11431  A   R 1577473598 + 2 <- (8,3) 1575370302
781310:  8,0    1    85027   112.890384973 11431  Q   R 1577473598 + 2 [db2sysc]

781311-  8,3    0   504165   112.890385473 10322  A   R 1575370302 + 2 <- (253,4) 1575368254   << instance #2
781312:  8,0    0   504166   112.890385673 10322  A   R 1577473598 + 2 <- (8,3) 1575370302
781313:  8,0    0   504167   112.890385873 10322  Q   R 1577473598 + 2 [db2sysc]

781314:  8,0    1    85028   112.890386773 11431  G   R 1577473598 + 2 [db2sysc]                << instance #1 A,A,Q,G
781315-  8,0    1    85029   112.890387173 11431  P   N [db2sysc]
781316:  8,0    0   504168   112.890387273 10322  G   R 1577473598 + 2 [db2sysc]                << instance #2 A,A,Q,G
781317-  8,0    0   504169   112.890387473 10322  P   N [db2sysc]
781318:  8,0    1    85030   112.890387673 11431  I   R 1577473598 + 2 [db2sysc]                << instance #1 A,A,Q,G,I
781319-  8,0    1    85031   112.890388073 11431  U   N [db2sysc] 1
781320:  8,0    1    85032   112.890388373 11431  D   R 1577473598 + 2 [db2sysc]                << instance #1 A,A,Q,G,I,D!
781321:  8,0    0   504170   112.890390273 10322  I   R 1577473598 + 2 [db2sysc]                << instance #2 A,A,Q,G,I
781322-  8,0    0   504171   112.890390473 10322  U   N [db2sysc] 1
781323:  8,0    0   504172   112.890390773 10322  D   R 1577473598 + 2 [db2sysc]                << instance #2 A,A,Q,G,I,D!
781324-  8,3    1    85033   112.890397274 87012  A   R 1575370302 + 2 <- (253,4) 1575368254    << instance #3
781325:  8,0    1    85034   112.890397474 87012  A   R 1577473598 + 2 <- (8,3) 1575370302      <<          #3
781326:  8,0    1    85035   112.890397674 87012  Q   R 1577473598 + 2 [db2sysc]                <<          #3 A,A,Q
781327:  8,0    1    85036   112.890398574 87012  G   R 1577473598 + 2 [db2sysc]                <<          #3 A,A,Q,G
781328-  8,0    1    85037   112.890398774 87012  P   N [db2sysc]
781329:  8,0    1    85038   112.890399074 87012  I   R 1577473598 + 2 [db2sysc]                <<          #3 A,A,Q,G,I
781330-  8,0    1    85039   112.890399174 87012  U   N [db2sysc] 1
781331:  8,0    1    85040   112.890399574 87012  D   R 1577473598 + 2 [db2sysc]                <<          #3 A,A,Q,G,I,D!
781332-  8,3    1    85041   112.890404074 84573  A   R 1575370300 + 2 <- (253,4) 1575368252    << instance #4
781333-  8,0    1    85042   112.890404174 84573  A   R 1577473596 + 2 <- (8,3) 1575370300      << fails here. but it shows just 3 instances, not 4!?
781334-  8,0    1    85043   112.890404274 84573  Q   R 1577473596 + 2 [db2sysc]
781335-  8,0    1    85044   112.890405975 84573  G   R 1577473596 + 2 [db2sysc]
781336-  8,0    1    85045   112.890406075 84573  P   N [db2sysc]
781337-  8,0    1    85046   112.890406175 84573  I   R 1577473596 + 2 [db2sysc]
781338-  8,0    1    85047   112.890406375 84573  U   N [db2sysc] 1
781339-  8,0    1    85048   112.890406475 84573  D   R 1577473596 + 2 [db2sysc]
781340:  8,0    0   504173   112.890481481     0  C   R 1577473598 + 2 [0]                     << here are the 4 C events for above 4 instances so logic fault!!!
781341:  8,0    0   504174   112.890493382     0  C   R 1577473598 + 2 [0]
781342:  8,0    0   504175   112.890495282     0  C   R 1577473598 + 2 [0]
781343-  8,0    0   504176   112.890497282     0  C   R 1577473596 + 2 [0]


So what we have is intermixed commands and the assumption was that best_match() would *always* be fed at least
one good match.  But in this case the "good" match is the 3rd choice, but we never get there.  Feed [0] and [1] 
entries, fails as neither is good match - fatal internal logic exit.  

We need to change the logic that *if* best_match() is called, then its ok to fail and not find anything.  But
that means we can't just used local variable io in search of list as tracker... we need *another* variable,
lets say 'best' that tracks the chosen io, if any.  Normally io/best is the same right up to the point that
we have to call best_match().  We can't assume that the best match will always be one of the io,temp pointers
the search loop has, and we can't let best_match() die internally if it can't choose a "best match" between the
given choices.  Really don't want to go down this road as there could be a "good enough choice", but will have
to see if we get to that point with any of the current test data sets.  Meanwhile, change the logic to track
best,io,temp when searching and we hit multiple matches.  And add check outside of the search loop so that is
best=null but io doesn't then that means we had to use best_match() at some point and it wrote over best.
This is tricky because if we get a valid best back, we want to make sure we feed that back into the next 
iteration, aka we want to overwrite 'io'.  But if we don't, we don't want to change 'io' to null to match
the returned 'best' value... Alright, going to go code me a minivan.

*/

/* 11/05/2020
 *
Another issue has come up with multiple active sector:length io.  The current case is there were two
io on the staged queue, a G promotes one to the mainio/active list.  Then an I happens, which checks
staged, finds just the 1 match and declares success.  Except that I should have been applied to the
one just promoted to the mainio list.  This is a split brain type issue in that qualifying io is
spread over the two queues.  So we need to change fundamental search strategy for S|G|I events as 
these are the ones that promote io from staged to mainio lists.  Don't have to do it for S, but that
is a minority anyway.  But S could have happened so at G have to check both (special case: state.cnt_sleeps=0
then don't have to check both queues for G event). That's good news because then we're just down to 
I events in nominal data sets as Sleeps are very unusual.  So, come up with a better state flow to 
track "best", "io", and "temp" pointers.  Namely change io to point to best after call only if a 
non-null best is returned.  This is to address the issue that best_match() may be fed two disqualified
io a number of times as it walks down the queue getting hits/matches on the data.  The qualified io
can be buried down near the bottom of the list.  This would be unusual circumstance (I think) except
in the case where events are woven in unusual pattern.  That is because the oldest (longest in existence)
is on the bottom of the mainio active list queue.  New io are added to the top/front of the list.
So qualifying io is much more likely to be later in the queue vs near the top.  We only saw that happen
when there were 3-4 or more same io typ:sector:length active on the scheduler.  Which in itself is unusual.

 */

/* 11/07/2020
 *

Well, I managed to do it. Again.  The program is boken again.  I added special case code for duplicate
io (same typ:sector:length have multiple active io at the same time).  The last tweak was to force the
duplicate checks across both staged and mainio/active lists for the case where one typ:sector:length
is on the staged queue and one or more on the mainio/active list.  A new I event gets a hit on a 
staged io that doesn't have an I yet... but there are io on mainio/active list which have a G event
and are older.  That makes those io better matches than the one on the staged list.  This is only 
a potential problem for S|G|I as Q|A|M|F only apply to requests on the staged queue and D|R|C only
apply to io on the mainio list (unless events were dropped and not available on the input list --
a whole different corner case issue).  That leaves S|G|I as potentially applying to both.  The S
can only be applied to staged as that is the earlies/first event that could trigger a staged 
io to migrate to the active/mainio list as a request.  And G should only apply to staged if there
have been no sleeps otherwise only duplicate io on staged should be missing G events since to 
be on the mainio/active list before a G would require and S.  That leaves G as conditional search
on both, and finally I must search both.  Could make I conditional on no S and no G events... but
that just isn't worth it as G events are pretty common/normal/expected.

But, something added broke the special case barrier code detection and matching.  That matches
io that does not have sector:length specified but a 0+0 FWS io is pending.  These AQGIC sequences
for 0:0 io typically had been matching well within the code with neither extraneous matches or 
unable-to-match cases.  The whole purpose of the special case barrier detection/matching code was
to prevent a) discarding of events because they couldn't me matched via normal/direct means, and b)
to prevent large amounts of accumulation of "deadhead" io on the staged queue.  Without this special
matching code, A events with 0:0 created io on staged queueu.... and there it sits.  We were ending
up with 10,000s of these events on the staging queue which slowed down processing as code had to
go through each and every one when attempting to match a new incoming event... but they would never
match.

So, back into the code flow to try and figure out a way to either directly fix the issue or to prevent
best_match() from discarding barrier detection matchups previously created.  The barrier corner case
code has its own best_match_special1() code to deal with duplicate issues.  I suspect the added
best_match() code does an undo on the match -- so need to exclude barrier and any other special cases
from the more general best_match() code path.

*/

static typ_io *_choose_oldest(typ_io *io, typ_io *temp)
{
    /* Choose earliest io context of the two, one with smallest timestamp 		*/
    if (io->info->events.dispatch.time <  temp->info->events.dispatch.time) return(  io);
    else                                                                    return(temp);
}
static typ_io *_choose_newest(typ_io *io, typ_io *temp)
{
    if (io->info->events.dispatch.time >=  temp->info->events.dispatch.time) return(  io);
    else                                                                     return(temp);
}
/*
 * This is the more complicated case vs special1.  special1 had strict limitation
 * on the sequence of events allowed.  Whereas the general case is more complicated.
 * For example, if event is I while we're looking for an event with no previous I
 * event in nominal case, we could already have an I if there was also a previous
 * R.  So to "qualify" (or the inverse, disqualify) and io context based upon event
 * type becomes a multi-step process for some specific event action types.
 */
/* note that there is bias in the program and io is newer in time than temp because io was 
 * nearer the top of the queue (1st match detection).  That may not always be the case
 * that the staged and mainio queue are ordered new->old in both... especially if there
 * is 2ndhand merging happening
 * staged is newest(top) -> oldest : short queue so dont care, its easier this way and typ follow on up to S|G|M|F|I are to newest io.
 * mainio is most recent(top) -> oldest : we want to bias attaching events like D,C to oldest io
 */
typ_io *best_match(typ_event *this, typ_io *io, typ_io *temp)
{
typ_io *best = NULL;
typ_io *_best= NULL;
int io_qualified = 0;
int temp_qualified = 0;
int _logic_fault;
int len;
int debug_mask=0;
int io_event_mask, temp_event_mask;
int io_optionmask, temp_optionmask;
int io_optioncare, temp_optioncare;	/* Some optional events we actually care about */
int required_mask, option_mask;
int temp_mask;
int evt_count;
int evt_flags;
int evt_mask;
unsigned long   ioSeqNo=0UL;
unsigned long tempSeqNo=0UL;
char string[64];

    TRACE_FUNCTION;
    io_event_mask = temp_event_mask = io_optionmask = temp_optionmask = io_optioncare = temp_optioncare = 0;
    dprintf( "DBG[%05d]: best_match(%c,io=%p,temp=%p)\n", __LINE__, this->prmact, io, temp );
    /* Check 1: the current primary event cannot be already present in the io context */
    /*          qualified if the current event type is not present                    */
    /*          event types that can occur (or at least ones currently programmed) are*/
    /*          Q,S,G,I,M,F,D,R,C -- any others will result in fatal logic fault      */ /* No 'A' event is allowed */
    /* NOTE:    event specific code may need to be added to allow changes the to full */
    /*          event type, for example if context has FWFS, might need to allow check*/
    /*          using WFS for later S,G,I, ... events as leading 'F' is often dropped */
    /* NOTE:    because some events can have optional events like R and the other not */
    /*          need to track different event and option masks for io & temp separate */
    switch(this->prmact)
    {
	case 'A': /* Originally A events were not included because, hey, we're not going to see em*/
		  /* But, yes we did... immediately. The cause was two A read events for same lba */
		  /* at exactly same time from two different processes.  Then a second A to       */
		  /* resovle nesting of dm -> partition -> base disk.  That 2nd A event matched 2 */
		  /* different io with same R:sector:length signatures and promptly fatal'd.  So  */
		  /* added call to here to resolve differences.  And since time between the two is*/
		  /* exactly the same, need to include assigned SeqNo ticket numbers for the event*/
		  /* type so can differentiate to earlier ticket as tie breaker.                  */
		  /* Since there is no way we should arrive here in non-nesting cases, set qual   */
		  io_qualified    |= 0x01;
		  temp_qualified  |= 0x01;
		       debug_mask =  EVTMSK_A;
		    io_event_mask = (EVTMSK_A);   /* events that should be in the context to be qual'd */
		  temp_event_mask = (EVTMSK_A);   /* events that should be in the context to be qual'd */
	            io_optionmask =         0;    /* there are no optional events, that can be ignored */
	          temp_optionmask =         0;    /* there are no optional events, that can be ignored */
		    io_optioncare =         0;    /* there are no optional events that are important   */
	          temp_optioncare =         0;
		  break; 

        case 'Q': /* Event can only have 1 Q event and will only arrive here if A happened before */
		  if (  io->info->events.queue.line == LINENUM_NONE)   io_qualified |= 0x01;
	          if (temp->info->events.queue.line == LINENUM_NONE) temp_qualified |= 0x01;
                       debug_mask =  EVTMSK_Q;
		    io_event_mask = (EVTMSK_A);   /* events that should be in the context to be qual'd */
		  temp_event_mask = (EVTMSK_A);   /* events that should be in the context to be qual'd */
	            io_optionmask =         0;    /* there are no optional events, that can be ignored */
	          temp_optionmask =         0;    /* there are no optional events, that can be ignored */
		    io_optioncare =         0;    /* there are no optional events that are important   */
	          temp_optioncare =         0;
		  break;

	case 'S': /* Sleep events can happen multiple times, so having or not having one  */
                  /* doesn't change whether the io is qualified or not, so set qual'd both*/
		    io_qualified |= 0x01;
	          temp_qualified |= 0x01;
		  temp_event_mask = io_event_mask = (EVTMSK_A|EVTMSK_Q);
		  temp_optionmask = io_optionmask = (EVTMSK_A);
	          temp_optioncare = io_optioncare = 0;
		  break;
                  
        case 'G': /* There can only be 1 G event per context!                            */
	          if (  io->info->events.getrq.line == LINENUM_NONE)   io_qualified |= 0x01;
	          if (temp->info->events.getrq.line == LINENUM_NONE) temp_qualified |= 0x01;
                  debug_mask =  EVTMSK_G;
	          temp_event_mask = io_event_mask = (EVTMSK_A | EVTMSK_Q | EVTMSK_S);  /* any/all of these are allowed                  */
		  temp_optionmask = io_optionmask = (EVTMSK_A |            EVTMSK_S);  /* but these are optional and may not be present */
	          temp_optioncare = io_optioncare = 0;
		  break;

        case 'I': /* There can only be 1 I event per context if requeue count is zero     */
		  /* If there are requeues, then number of inserts must be 1 less than    */
		  /* number of requeues. Add 'I' as required event if requeue != 0        */
		  debug_mask =  EVTMSK_I;
	          temp_event_mask = io_event_mask = (EVTMSK_A | EVTMSK_Q | EVTMSK_S | EVTMSK_G);  /* Allowed  events , includes optional ones */
		  temp_optionmask = io_optionmask = (EVTMSK_A |            EVTMSK_S | EVTMSK_G);  /* Optional events */
		  temp_optioncare = io_optioncare =                                   EVTMSK_G;	  /* Optional events, that if present tie-breaker */
		  if (  io->info->cnt_requeues == 0)
		  {
		      if (  io->info->events.insert.line == LINENUM_NONE                )   io_qualified |= 0x01;
		  }
		  else
		  {
		      if (  io->info->cnt_inserts        == (  io->info->cnt_requeues+1)){  io_qualified |= 0x01;   io_event_mask |= EVTMSK_I; set_event_mask(io,EVTNDX_I);}
		  }
		  if (temp->info->cnt_requeues == 0)
		  {
		      if (temp->info->events.insert.line == LINENUM_NONE                ) temp_qualified |= 0x01;
		  }
		  else
		  {
		      if (temp->info->cnt_inserts        == (temp->info->cnt_requeues+1)){temp_qualified |= 0x01; temp_event_mask |= EVTMSK_I; set_event_mask(io,EVTNDX_I);}
		  }
		  break;

 	case 'M': printf( "%%F[%05d]-fatal internal logic error, tbd 'M' on best_match()\n", __LINE__);
		  MISS_FEATURE_FAULT(this,(typ_io *),"no merge processing in best match yet",CTL_FAULT_DEFAULT);
		  break;
 	case 'F': printf( "%%F[%05d]-fatal internal logic error, tbd 'F' on best_match()\n", __LINE__);
		  MISS_FEATURE_FAULT(this,(typ_io *),"no merge processing in best match yet",CTL_FAULT_DEFAULT);
		  break;

        case 'D': /* Similar to I, only one if requeue count is zero, otherwise allow inserts-1 */
		  debug_mask =  EVTMSK_D;
	          temp_event_mask = io_event_mask = (EVTMSK_A | EVTMSK_Q | EVTMSK_S | EVTMSK_G | EVTMSK_I);
		  temp_optionmask = io_optionmask = (EVTMSK_A |            EVTMSK_S | EVTMSK_G);
	          temp_optioncare = io_optioncare =                                 ( EVTMSK_G | EVTMSK_I);
		  if (  io->info->cnt_requeues == 0)
		  {
		      if (  io->info->events.dispatch.line == LINENUM_NONE               )   io_qualified |= 0x01;
		  }
		  else
		  {
		      if (  io->info->cnt_dispatches       == (  io->info->cnt_inserts-1)){  io_qualified |= 0x01;   io_event_mask |= EVTMSK_D; set_event_mask(io,EVTNDX_D);}
		  }
		  if (temp->info->cnt_requeues == 0)
		  {
		      if (temp->info->events.dispatch.line == LINENUM_NONE               ) temp_qualified |= 0x01;
		  }
		  else
		  {
		      if (temp->info->cnt_dispatches       == (temp->info->cnt_inserts-1)){temp_qualified |= 0x01; temp_event_mask |= EVTMSK_D; set_event_mask(io,EVTNDX_D);}
		  }
		  break;

	case 'R': /* Similar multi-optional event                                              */
		  debug_mask =  EVTMSK_R;
	          temp_event_mask = io_event_mask = (EVTMSK_A | EVTMSK_Q | EVTMSK_S | EVTMSK_G | EVTMSK_I | EVTMSK_D);
		  temp_optionmask = io_optionmask = (EVTMSK_A |            EVTMSK_S | EVTMSK_G);
	          temp_optioncare = io_optioncare = 0;	/* byt this time, there are none */
		  if (  io->info->cnt_requeues == 0)
	          {
		      if (  io->info->events.requeue.line == LINENUM_NONE               )   io_qualified |= 0x01;
		  }
		  else
	          {
		      if (  io->info->cnt_requeues        == (  io->info->cnt_dispatches-1)){  io_qualified |= 0x01;   io_event_mask |= EVTMSK_R; set_event_mask(io,EVTNDX_R);}
		  }
		  if (temp->info->cnt_requeues == 0)
		  {
		      if (temp->info->events.requeue.line == LINENUM_NONE               ) temp_qualified |= 0x01;
 		  }
		  else
		  {
		      if (temp->info->cnt_requeues        == (temp->info->cnt_dispatches-1)){temp_qualified |= 0x01; temp_event_mask |= EVTMSK_R; set_event_mask(io,EVTNDX_R);}
		  }
		  break;


        case 'C': /* IO can have multiple completions, but not on the mainio/active list and */
		  /* this is called from search mainio code.                                 */
		  debug_mask =  EVTMSK_C;
	          temp_event_mask = io_event_mask = (EVTMSK_A | EVTMSK_Q | EVTMSK_S | EVTMSK_G | EVTMSK_I | EVTMSK_D | EVTMSK_R);
		  temp_optionmask = io_optionmask = (EVTMSK_A |            EVTMSK_S | EVTMSK_G |                       EVTMSK_R);
	          temp_optioncare = io_optioncare = 0;	/* byt this time, there are none */
                  if (  io->info->events.complete.line == LINENUM_NONE)   io_qualified |= 0x01;
	          if (temp->info->events.complete.line == LINENUM_NONE) temp_qualified |= 0x01;
		  break;

        default : /* We could just let this fall through, the event masking will trigger a no match case... but really? */
 	          printf( "%%F[%05d]-fatal internal logic error, tbd '%c' on best_match()\n", __LINE__, this->prmact );
		  MISS_FEATURE_FAULT(this,(typ_io *),"no case for this event type yet",CTL_FAULT_DEFAULT);
		  break;

    }
    /* Detect overlapping io in the scheduler and/or driver (storage)                 */
    /* ------------------------------------------------------------------------------ */
    /* Any time this code is executed it means that there are two typ:sector+length   */
    /* io that are the same.  They exist within the io scheduler queues simultaneously*/
    /* So, if neither flag is set, set SAMEIOSCHED on each io                         */
    /* EXCEPTION: do not do this if this io is a barrier io, it can be perfectly      */
    /*            normal for multiple barriers to be outstanding at the same time     */
    /*            where in this case a barrier is a 0,0 sect:len (non-data move) io   */
    if ((io->sector != 0) && (io->length != 0))
    {
	/* Not a barrier, although technically any zero-length io could be labeled a  */
        /* barrier as there is no data movement possible, default is to also set the  */
        /* sector to zero -- hope this convention holds.                              */
        if ((io->ioflags & (IS_SAMEIOSCHED | IS_SAMEIODRIVR)) == 0)
        {
	    io->ioflags |= IS_SAMEIOSCHED;
	    logWprintf( "%%W[%05d]- io %c:%12ld.%06ld has been marked SAMEIOSCHED\n", __LINE__, _prmtyp(io->prmtyp),     io->sector,   io->length );
        }
        if ((temp->ioflags & (IS_SAMEIOSCHED | IS_SAMEIODRIVR)) == 0)
        {
	    temp->ioflags |= IS_SAMEIOSCHED;
	    logWprintf( "%%W[%05d]- io %c:%12ld.%06ld has been marked SAMEIOSCHED\n", __LINE__, _prmtyp(temp->prmtyp), temp->sector, temp->length );
        }
    }
    else
    {
	/* Barrier io, force clear the flags if needed - complain if you do as this   */
	/* should not happen, but we just want to make sure.			      */
        if ((io->ioflags & (IS_SAMEIOSCHED | IS_SAMEIODRIVR)) != 0)
        {
	    printf( "%%E[%05d]-force clearing SAMEIOSCHED|SAMEIODRIVR from io: %c:%12ld.%06ld (%016lX)\n", __LINE__, _prmtyp(io->prmtyp), io->sector, io->length, io->ioflags);
	    io->ioflags &= ~(IS_SAMEIOSCHED | IS_SAMEIODRIVR);
        }
        if ((temp->ioflags & (IS_SAMEIOSCHED | IS_SAMEIODRIVR)) != 0)
        {
	    printf( "%%E[%05d]-force clearing SAMEIOSCHED|SAMEIODRIVR from io: %c:%12ld.%06ld (%016lX)\n", __LINE__, _prmtyp(temp->prmtyp), temp->sector, temp->length, temp->ioflags);
	    temp->ioflags &= ~(IS_SAMEIOSCHED | IS_SAMEIODRIVR);
        }
    }

    /* === Special logic for D events =============================================== */
    /* If the current event is 'D' and one of the two already have a 'D' event, then  */
    /* this means post this call both are likely to have 'D'. {ed: corner case is     */
    /* whereby there are 'R'equeue involved, then this 'D' might get reapplied to the */
    /* one that already has the 'D'... in fact it should as long as requeue count is  */
    /* less than 'D' count because a requeue results in that io being retried first   */
    /* above any/all other io until the 'D' isn't rejected by yet another requeue     */
    /* Dont apply this to zero length io which involve no data movement, those will   */
    /* typically be barrier type io manifestations.                                   */
    if ((this->prmact == 'D') && (io->length != 0) && (temp->length != 0))
    {
	/* The following might trigger because the one of the matches is to an io with*/
	/* C event, but really this should never happen, 'C'ompleted io are moved out */
	/* of the mainio queue immediately, so again these next two fprints should    */
	/* never ever occur. But are here simply for sanity at this point, no suprises*/
	if ((io->event_mask   & EVTMSK_C) != 0) fprintf( outf, "%%E[%05d]-in %s() io   %p detected already having C event during D processing.\n", __LINE__, __func__, io );
	if ((temp->event_mask & EVTMSK_C) != 0) fprintf( outf, "%%E[%05d]-in %s() temp %p detected already having C event during D processing.\n", __LINE__, __func__, temp);

        evt_count = 0;				
        if ((io->event_mask   & EVTMSK_D) != 0) evt_count++;
        if ((temp->event_mask & EVTMSK_D) != 0) evt_count++;

	if (evt_count != 0)
	{
	    /* So lets take a look at building a state mask for each of io | temp     */
	    /* Rcnt Dcnt   Status   						      */
	    /* 0    0      eligable, normal priority				      */
	    /* 1    1      eligable, high   priority (unbalanced requeue)             */
	    /* n == n      "         "      "        (if Rcnt != 0)                   */
	    /* 1    0      fault, can't have R w/o D (internal logic failure B4)      */
	    /* 0    1      ineligable                (outstanding D event	      */
	    /* n+1==n      ineligable                (n>=1, normal outstanding D event*/
            /* n-1>=n      fault, can't have more R than D!                           */

	    /* So we need to know if io | temp is in fault, ineligable, elig+norm|high*/
	    /* 1xxb = fault state, something is wrong with the logic that got us here  */
	    /* 001b = ineligable , outstanding D event                                 */
	    /* 010b =   eligable , normal (Rcnt==0)                                    */
            /* 011b =   eligable , high   (Rcnt!=0, and unbalanced implying this is at */
            /*                            at the top of the sched q awaiting re-D     */
	
	    /* XYxxyy mask of xx=io, yy=temp so there are 16 combos for a switch      */
	    /* X      mask of    io fault                                             */
	    /* Y      mask of  temp fault                                             */
	    /* Also build into the switch the fact that evt_count==1 so only one of   */
	    /* io | temp can have a missing D event altogether, aka only 1 can be norm*/

	    /* Ok, this should be the normal case, but normal only if neither io have */
            /* cnt_requeues > 0 (no EVTMSK_R set).  If EVTMSK_R set, then that io is  */
            /* eligable -- nay, destined -- to end up as owner of the D event.  Any io*/
            /* with requeue status will be top of the queue and repeatedly dispatched */
            /* until no Requeue is returned.  That means the one io with D events     */
            /* already **must** be the one with requeues and therefore there no need  */
            /* to flag the two io as SAMEIODRIVER -- that 2nd io without D will not   */
	    /* get this D event.                                                      */

	    /* Reset counters							      */
	    evt_count= 0;	/* How many io | temp have Requeues present?	      */
	    evt_flags= 0;	/* How many io | temp are ineligable for more Ds?     */

	    evt_mask = 0x00;

            if ((io->event_mask   & EVTMSK_R) != 0)
	    {
		dprintf( "DBG[%05d]:   io Rcnt %d  Dcnt %d\n", __LINE__, io->info->cnt_requeues, io->info->cnt_dispatches );
		evt_count++;
	             if ((io->info != NULL) && ((io->info->cnt_requeues  ) == (io->info->cnt_dispatches  )))
			evt_mask |= 0x0C;  /* 11b - Unbalanaced Requeues (>0) present 		D->R->{D}	*/
	        else if ((io->info != NULL) && ((io->info->cnt_requeues  ) == (io->info->cnt_dispatches-1)))
		{       evt_mask |= 0x04;  /* 01b - Ineligable                                  D->R->D		*/
		        evt_flags++;
	        }
	        else
		{
	            if ((io->info != NULL) && ((io->info->cnt_requeues-1) >= (io->info->cnt_dispatches  )))
			evt_mask |= 0x20;  /* Too few Requeues for Dispatch event count 	   R->  R,D,R...*/
	            if ((io->info != NULL) && ((io->info->cnt_requeues  ) == (io->info->cnt_dispatches-1)))
			evt_mask |= 0x20;  /* Too Many Dispatches for Requeue event count       D->R->D->D      */
			                   /* This is a special case of D->R->D R->  R,D,R...*/
		}
	    }
	    else
	    {
		/* No Requeues? then either D is present/outstanding (01b ineligable case) or no D and elig.norm*/
                if ((io->event_mask   & EVTMSK_D) != 0)
	        {
		    evt_mask |= 0x04; /* 01b - ineligable case 							*/
		    evt_flags++;
		}
		else
		    evt_mask |= 0x08; /* 10b -   eligable, normal priority 					*/
	        if ((io->info != NULL) && ((io->info->cnt_dispatches > 1)))
		    evt_mask |= 0x20; /* 1xxb-   fault, can only have 1 D event if no requeues!			*/
	    }
		
            if ((temp->event_mask   & EVTMSK_R) != 0)
            {
		dprintf( "DBG[%05d]: temp Rcnt %d  Dcnt %d\n", __LINE__, temp->info->cnt_requeues, temp->info->cnt_dispatches );
		evt_count++;
                     if ((temp->info != NULL) && ((temp->info->cnt_requeues  ) == (temp->info->cnt_dispatches  )))
                        evt_mask |= 0x03;  /* 11b - Unbalanaced Requeues (>0) present           D->R->{D}       */
                else if ((temp->info != NULL) && ((temp->info->cnt_requeues  ) == (temp->info->cnt_dispatches-1)))
                {       evt_mask |= 0x01;  /* 01b - Ineligable                                  D->R->D         */
			evt_flags++;
		}
                else
                {
                    if ((temp->info != NULL) && ((temp->info->cnt_requeues-1) >= (temp->info->cnt_dispatches  )))
                        evt_mask |= 0x10;  /* Too few Requeues for Dispatch event count            R->  R,D,R...*/
                    if ((temp->info != NULL) && ((temp->info->cnt_requeues  ) == (temp->info->cnt_dispatches-1)))
                        evt_mask |= 0x10;  /* Too Many Dispatches for Requeue event count       D->R->D->D      */
                                           /* This is a special case of D->R->D R->  R,D,R...*/
                }
            }
            else
            {
                /* No Requeues? then either D is present/outstanding (01b ineligable case) or no D and elig.norm*/
                if ((temp->event_mask   & EVTMSK_D) != 0)
		{
                    evt_mask |= 0x01; /* 01b - ineligable case                                                  */
		    evt_flags++;
		}
                else
                    evt_mask |= 0x02; /* 10b -   eligable, normal priority                                      */
                if ((temp->info != NULL) && ((temp->info->cnt_dispatches > 1)))
                    evt_mask |= 0x10; /* 1xxb-   fault, can only have 1 D event if no requeues!                 */
            }

	    if ((evt_mask & 0x10) != 0)
	    {
                { int _dflag=flag_debug; int _qflag=flag_quiet;
                        /* We're going to tank anyway                                 */
                        flag_debug = 1; flag_quiet = 0;
                        dump_io_dbg(io  );
                        dump_io_raw(io, "",__LINE__);
                        dump_io_dbg(temp);
                        dump_io_raw(temp,"",__LINE__);
                        flag_debug=_dflag; flag_quiet=_qflag;
                }
	        printf( "DBG[%05d]: fault evt_mask=%X\n", __LINE__, evt_mask ); fflush(stdout); 
                printf( "DBG[%05d]: FAIL FAIL FAIL\n\n", __LINE__); fflush(stdout); 
		assert(evt_mask != 0);
	    }
	    if ((evt_mask & 0x20) != 0)
	    {
                { int _dflag=flag_debug; int _qflag=flag_quiet;
                        /* We're going to tank anyway                                 */
                        flag_debug = 1; flag_quiet = 0;
                        dump_io_dbg(io  );
                        dump_io_raw(io, "",__LINE__);
                        dump_io_dbg(temp);
                        dump_io_raw(temp,"",__LINE__);
                        flag_debug=_dflag; flag_quiet=_qflag;
                }
	        printf( "DBG[%05d]: fault evt_mask=%X\n", __LINE__, evt_mask ); fflush(stdout); 
                printf( "DBG[%05d]: FAIL FAIL FAIL\n\n", __LINE__); fflush(stdout); 
		assert(evt_mask != 0);
	    }

	}

	if (evt_count == 0)
	{
	    ; /* do nothing, both events are eligable/missing D events ... until one  */
              /* context has a D and is ineligable for another (not in requeue state) */
	      /* then and only then can we flag with any certainty that there are 2   */
	      /* identical typ:sector+len that were dispatched simultaneously to      */
	      /* storage, with this D event being that 2nd dispatch                   */
	      /* So 'best' is just 1st (oldest) as a w.a.g.			      */
	}
        else if (evt_count == 1)
        {
	    /* One of the two io is missing a D event.  This should be easy, find the */
            /* which one, io | temp, is missing its D event and that's the one...     */
	    /* The wrinkle is the one with the D event -- which normally would mean   */
            /* the one without the D event is "best match" -- might be in unbalanced  */
	    /* Requeue state (D->R is unbalanced requeue by which I mean its back on  */
	    /* the top of the sched queue awaiting dispatch and has a higher priority */
	    /* than the one without any D event.  Yeah, a special corner case, but we */
	    /* deep into corner cases to even be here in the first place.             */

	    assert(_best == NULL);
            _logic_fault = -1;
	    dprintf( "DBG[%05d]; evt_mask=%02X\n", __LINE__, evt_mask );
	    switch (evt_mask & 0x0F)
	    {
		case  0 /* 00.00b */ :               _logic_fault= 0;   /* logic fault */ break; /* cannot have a 00b state for either io | temp */
		case  1 /* 00.01b */ : 		     _logic_fault= 1;	/* logic fault */ break; /* cannot have a 00b state for either io | temp */
		case  2 /* 00.10b */ : _best = temp; _logic_fault= 2;	/* logic fault */ break; /* cannot have a 00b state for either io | temp */
		case  3 /* 00.11b */ : _best = temp; _logic_fault= 3;  	/* logic fault */ break; /* cannot have a 00b state for either io | temp */
		case  4 /* 01.00b */ :               _logic_fault= 4;	/* logic fault */ break; /* cannot have a 00b state for either io | temp */
		case  5 /* 01.01b */ :               _logic_fault= 5;   /* logic fault */ break; /* cannot have both with D events, evt_count=1!		*/
		case  6 /* 01.10b */ : _best = temp;                                      break; /* io.D  temp.-  :: normal prior 				*/
		case  7 /* 01.11b */ : _best = temp; _logic_fault= 7;   /* logic fault */ break; /* cannot have both with D events, evt_count=1!		*/
		case  8 /* 10.00b */ : _best =   io; _logic_fault= 8;	/* logic fault */ break; /* cannot have a 00b state for either io | temp 		*/
		case  9 /* 10.01b */ : _best =   io;			                  break; /* io.-  temp.D  :: normal prior 				*/
		case 10 /* 10.10b */ : _best =_best; _logic_fault=10;   /* logic fault */ break; /* cannot have both w/o  D events, evt_count=1!		*/
		case 11 /* 10.11b */ : _best = temp;                                      break; /* io.-  temp.RD :: high   prior				*/
		case 12 /* 11.00b */ : _best =   io; _logic_fault=12;	/* logic fault */ break; /* cannot have a 00b state for either io | temp 		*/
		case 13 /* 11.01b */ : _best =   io; _logic_fault=13;	/* logic fault */ break; /* cannot have both with D events, evt_count=1!		*/
		case 14 /* 11.10b */ : _best =   io; 					  break; /* io.RD temp.- :: high   prior 				*/
		case 15 /* 11.11b */ : _best =_best; _logic_fault=15;   /* logic fault */ break; /* cannot have both with D events, evt_count=1!		*/
		default              : _best =_best; _logic_fault=16;                     break;
	    }
            if (_logic_fault != -1)
	    {
	        printf( "DBG[%05d]: logic fault %d on evt_mask=%X\n", __LINE__, _logic_fault, evt_mask ); fflush(stdout); 
		assert(_logic_fault != -1);
	    }
	    dprintf( "DBG[%05d]: %s( io.%p temp.%p ) _best = %p\n", __LINE__, __func__, io, temp, _best ); fflush(stdout); fflush(stdout);
	    assert(_best != NULL);

	    /* Sanity checks on our understanding of things */
            if (evt_count >= 2) fprintf( outf, "%%E[%05d]-%s() found both 1st and Nth io context to be in D->R->I... requeue loop?\n", __LINE__, __func__ );
            if (evt_flags >= 2) fprintf( outf, "%%E[%05d]-%s() found both 1st and Nth io context found to be ineligable for D event?\n", __LINE__, __func__ );
	    dprintf( "DBG[%05d]: evt (requeue) count %d (ineligable) flags %d\n", __LINE__, evt_count, evt_flags );
	    assert( evt_flags <= evt_count ); /* flags must be <= count                  *//* @@@TBD - not even sure this makes sense with the latest code. */
    
	    /* Okay, what we're expecting now is that only 1 of the io context blocks */
	    /* is eligable for getting a D event and that context is NOT the one with */
	    /* D event already present.  If evt_flags==0, then the above is a given,  */
	    /* neither io context are in requeue/D loop, so from a requeue state      */
	    /* perspective neither is ineligable for a D.  But that means in turn that*/
	    /* the io context without the D must be the target here and so post this  */
	    /* event there will be two io, post 'D' that are same typ:sector+len and  */
	    /* are simultaneously out to storage.  Minus the corner case where len==0 */
	    /* which is a signature of an io barrier and those can be nested as there */
	    /* is no data movement involved with a barrier.  If evt_flags==1, that    */
	    /* means there is one io with D already, but its max'd out its D count, so*/
	    /* again we're back to only the io context without the D event is the only*/
	    /* one eligable to recv it/be associated with it.  And that leaves the    */
	    /* final evt_count==2, which means neither of these io are eligable for   */
	    /* more D events... but also means we missed a chance to set SAMEIODRIVR  */
	    /* as both are out to storage simultaneously already.                     */
    
	    /* SAMEIO evt
            /* DRIVR  count flags						      */
	    /*   1     0         0 ; neither in requeue state			      */
	    /*   -     0         1 ; not possible				      *//* evt_flags must be <= evt_count */
	    /*   -     0         2 ; --- ditto					      */
	    /*   0     1         0 ; 1 in requeue state, needs another D              *//* dont set SAMEIODRIVR flag, this D should go to context in requeue */
	    /*   1     1         1 ; 1 was in requeue, but is now satisfied	      *//* requeue io:treat as in D state only, which means other context needs D */
	    /*   -     1         2 ; ---					      */
	    /*   E,0   2         0 ; both in requeue state, both need Ds              *//* We should complain about this with %Error, only possible in MQ? maybe? */
	    /*   E,1   2         1 ; 1 in requeue, needs D, 1 was in requeue but ok   *//* and on top of that we shouldn't find 2 with requeues but only count 1  */
	    /*   E     2         2						      *//* with D events to get into the code block!?                             */
	    /* SAMEIODRIVR set if there is 
            /*   + 1 io context with D, not in requeue awaiting another D,            *//* so cannot be in active R->I (awaiting D) state  currently */
            /*   + 1 io context has no D, so should get this one as best match        */
            /*   and so after this D, there will be two identical typ:sector+len io   */
	    /*   sitting out in storage. Asserts and %E[] above have taken care of the*/
	    /*   "-" rows, the the E,0-2 cases.  So...                                */

	    /* The only time we shouldn't set the SAMEIODRIVR in the case of only 1   */
            /* context having a D event is when that context is also in an active     */
	    /* requeue state. So if evt_count == 1, evt_flags == 0, this means that   */
	    /* the 1 io context with D events already, is in requeue and is eligable  */
	    /* for another D event (open R->I, but still awaiting ->D).  In that one  */
	    /* case we cannot set SAMEIODRIVR, but only in that event                 */
	    if ((evt_count == 1) && (evt_flags == 0))
	    {
		/* do nothing */;
	    }
	    else if (evt_count < 2)
	    {
	        /* Clear the two SAMEIO flags, set SAMEIODRIVR 				  */
	        /* EXCEPTION: skip if 0,0 sect:len barrier io				  */
	        if ((io->sector != 0) && (io->length != 0))
	        {
	            io->ioflags   &= ~(IS_SAMEIOSCHED | IS_SAMEIODRIVR);
	            io->ioflags   |=                    IS_SAMEIODRIVR;
	            temp->ioflags &= ~(IS_SAMEIOSCHED | IS_SAMEIODRIVR);
	            temp->ioflags |=                    IS_SAMEIODRIVR;
		    logWprintf( "%%W[%05d]- io %c:%12ld.%06ld has been marked SAMEIODRIVR\n", __LINE__, _prmtyp(io->prmtyp),     io->sector,   io->length );
		    logWprintf( "%%W[%05d]- io %c:%12ld.%06ld has been marked SAMEIODRIVR\n", __LINE__, _prmtyp(temp->prmtyp), temp->sector, temp->length );
		}
                else
                {
	            /* Barrier io, force clear the flags if needed - complain if you do as this   */
	            /* should not happen, but we just want to make sure.			      */
                    if ((io->ioflags & (IS_SAMEIOSCHED | IS_SAMEIODRIVR)) != 0)
                    {
	                printf( "%%E[%05d]-force clearing SAMEIOSCHED|SAMEIODRIVR from io: %c:%12ld.%06ld (%016lX)\n", __LINE__, 
			    _prmtyp(io->prmtyp), io->sector, io->length, io->ioflags);
	                io->ioflags &= ~(IS_SAMEIOSCHED | IS_SAMEIODRIVR);
                    }
                    if ((temp->ioflags & (IS_SAMEIOSCHED | IS_SAMEIODRIVR)) != 0)
                    {
	                printf( "%%E[%05d]-force clearing SAMEIOSCHED|SAMEIODRIVR from io: %c:%12ld.%06ld (%016lX)\n", __LINE__, 
			    _prmtyp(temp->prmtyp), temp->sector, temp->length, temp->ioflags);
	                temp->ioflags &= ~(IS_SAMEIOSCHED | IS_SAMEIODRIVR);
                    }
		}
	    }
	    else
	    {
		fprintf( outf, "%%W[%05d]-in %s(), evt count,flags=%d,%d which is unrecognized|unhandled combination.\n", __LINE__, evt_count, evt_flags);
	    }
        }
        else if (evt_count == 2)
        {
	    /* This at first blush is wrong, we should never be looking at two io     */
            /* that already both have D events present and trying to figure out which */
	    /* one gets this D event.  Except in the case where one of those (and only*/
	    /* one) is still in requeue state and needs one more D to push the io on  */

            assert(_best == NULL);
            _logic_fault = -1;
	    dprintf( "DBG[%05d]; evt_mask=%02X\n", __LINE__, evt_mask );
            switch (evt_mask & 0x0F)
            {
                case  0 /* 00.00b */ :               _logic_fault= 0;   /* logic fault */ break; /* cannot have a 00b state for either io | temp */
                case  1 /* 00.01b */ :               _logic_fault= 1;   /* logic fault */ break; /* cannot have a 00b state for either io | temp */
                case  2 /* 00.10b */ : _best = temp; _logic_fault= 2;   /* logic fault */ break; /* cannot have a 00b state for either io | temp */
                case  3 /* 00.11b */ : _best = temp; _logic_fault= 3;   /* logic fault */ break; /* cannot have a 00b state for either io | temp */
                case  4 /* 01.00b */ :               _logic_fault= 4;   /* logic fault */ break; /* cannot have a 00b state for either io | temp */
                case  5 /* 01.01b */ : _best =_best;                                      break; /* this is count evt_count=2 means in this case		*/
                case  6 /* 01.10b */ : _best = temp; _logic_fault= 6;   /* logic fault */ break; /* both should have D events!					*/
                case  7 /* 01.11b */ : _best = temp;                                      break; /* io.D  temp.RD :: high   prior				*/
                case  8 /* 10.00b */ : _best =   io; _logic_fault= 8;   /* logic fault */ break; /* cannot have a 00b state for either io | temp                */
                case  9 /* 10.01b */ : _best =   io; _logic_fault= 9;   /* logic fault */ break; /* both should have D events!					*/
                case 10 /* 10.10b */ : _best = best; _logic_fault=10;   /* logic fault */ break; /* cannot have both w/o  D events, evt_count=1!                */
                case 11 /* 10.11b */ : _best = temp; _logic_fault=11;   /* logic fault */ break; /* both should have D events!					*/
                case 12 /* 11.00b */ : _best =   io; _logic_fault=12;   /* logic fault */ break; /* cannot have a 00b state for either io | temp                */
                case 13 /* 11.01b */ : _best =   io; 					  break; /* io.RD temp.D  :: high   prior				*/
                case 14 /* 11.10b */ : _best =   io; _logic_fault=13;   /* logic fault */ break; /* both should have D events!					*/
                case 15 /* 11.11b */ : _best =   io;                                      break; /* @@@TBD, both are high priority io at this point!		*/
                default              : _best = best; _logic_fault=16;                     break;
            }
            if (_logic_fault != -1)
            {
	        printf( "DBG[%05d]: logic fault %d on evt_mask=%X\n", __LINE__, _logic_fault, evt_mask ); fflush(stdout); 
                assert(_logic_fault != -1);
            }
	    dprintf( "DBG[%05d]: %s( io.%p temp.%p ) _best = %p evt_mask=%02X evt_count=%d\n", __LINE__, __func__, io, temp, _best, evt_mask, evt_count ); 
	    if (_best == NULL)
	    {
		printf( "DBG[%05d]: FAIL FAIL FAIL - failed to choose best io for this event\n", __LINE__ );
		fflush(stdout); sleep(1); fflush(stdout);
                /*assert(_best != NULL);*/
	    }


	    if ( ((evt_count == 1) && (evt_flags == 1)) || 
	         ((evt_count == 2) && (evt_flags == 1)) )
	    {
		/* Clear the two SAMEIO flags, set SAMEIODRIVR 				  */
	        /* EXCEPTION: skip if 0,0 sect:len barrier io				  */
	        if ((io->sector != 0) && (io->length != 0))
		{
	            io->ioflags   &= ~(IS_SAMEIOSCHED | IS_SAMEIODRIVR);
	            io->ioflags   |=                    IS_SAMEIODRIVR;
	            temp->ioflags &= ~(IS_SAMEIOSCHED | IS_SAMEIODRIVR);
	            temp->ioflags |=                    IS_SAMEIODRIVR;
	            printf( "DBG[%05d]: io %c:%12ld.%06ld has been marked SAMEIODRIVR\n", __LINE__, _prmtyp(io->prmtyp), io->sector, io->length );
	            printf( "DBG[%05d]: io %c:%12ld.%06ld has been marked SAMEIODRIVR\n", __LINE__, _prmtyp(temp->prmtyp), temp->sector, temp->length );
		}
                else
                {
	            /* Barrier io, force clear the flags if needed - complain if you do as this   */
	            /* should not happen, but we just want to make sure.			      */
                    if ((io->ioflags & (IS_SAMEIOSCHED | IS_SAMEIODRIVR)) != 0)
                    {
	                printf( "%%E[%05d]-force clearing SAMEIOSCHED|SAMEIODRIVR from io: %c:%12ld.%06ld (%016lX)\n", __LINE__, 
			    _prmtyp(io->prmtyp), io->sector, io->length, io->ioflags);
	                io->ioflags &= ~(IS_SAMEIOSCHED | IS_SAMEIODRIVR);
                    }
                    if ((temp->ioflags & (IS_SAMEIOSCHED | IS_SAMEIODRIVR)) != 0)
                    {
	                printf( "%%E[%05d]-force clearing SAMEIOSCHED|SAMEIODRIVR from io: %c:%12ld.%06ld (%016lX)\n", __LINE__, 
			    _prmtyp(temp->prmtyp), temp->sector, temp->length, temp->ioflags);
	                temp->ioflags &= ~(IS_SAMEIOSCHED | IS_SAMEIODRIVR);
                    }
		}
	    }
	    switch (evt_count)
	    {
	      case 0: 
		switch (evt_flags)
		{
		  case 0:
		  case 1:
		  case 2: printf( "%%W[%05d]-in %s() both 1st and Nth have D events already, evt count,flags=%d,%d. Review. Learn. Fix.\n", __LINE__,__func__,evt_count,evt_flags);
			  break;
		}
		break;
	      case 1: 
		switch (evt_flags)
		{
		  case 0:  /* expect both to be disqualified in this case */ break;
                  case 1:  /* handled above                               */ break;
		  case 2: _EXIT(printf("%%F[%05d]-in %s() both 1st and Nth have D events already, evt count,flags=%d,%d. Fatal logic fault.\n", __LINE__,__func__,evt_count,evt_flags));
			  break;
		}
		break;
	      case 2: 
		switch (evt_flags)
		{
                  case 0: /* expect both to be disqualified in this case */ break;
		  case 1: /* handled above                               */ break;
		  case 2: _EXIT(printf("%%E[%05d]-in %s() both 1st and Nth have D events already, evt count,flags=%d,%d. Review. Learn. Fix.\n",__LINE__,__func__,evt_count,evt_flags));
			  break;
		}
		break;
	    }
        }
    }
    /* ---end: Special 'D' code ------------------------------------------------- */

    /* === Special logic for R events =============================================== */
    /* If the current event is 'R' choose the newest io with an unbalanced D event... */
    /* which should simply be the newest io (based on D timestamp).  A 'R' only will  */
    /* happen immediately after a D event. Normally an event is assigned to the oldest*/
    /* io context that is eligable, but that is not true for Requeues.                */
    /* Exception for the exception.  If neither io or temp is eligable for a R, aka   */
    /* no outstanding D, then we known the we can have QIDRRRR type event streams. In */
    /* the non-overlapping io case we just create a ghost D and continue.  Here we    */
    /* need to do the same.                                                           */
    if ((this->prmact == 'R') && (io->length != 0) && (temp->length != 0))
    { int needs_ghost_d = 0;

        /* R events are turning out to be tricky.  If neither io has a D or R present */
        /* then its an unpaired R and we choose the oldest io, create a ghost D and   */
	/* assign the R there.  The tricky part is the next R blows through that case */
	/* as now the oldest io has a ghost.D+R present and the logic seems to assign */
	/* the R to the blank io context with neither.  That logic needs to change.   */
	/* Unless there is an actual dangling D present, at which point the R does go */
	/* there, then further unpaired Rs should have an affinity the the ghost.D/R  */
	/* io context... until it hits dangling D (and then the middle case applies   */
	/*                                                                            */
	/* So cases:								      */
        /*   a) one and only one has a dangling D, choose that one                    */
	/*   b) both            have   dandling Ds, choose most recent one            */
	/*   c) neither has  Ds or  Rs present, choose oldest                         */
        /*   d) one     has  Ds and Rs present, and this includes ghosts, choose this */
	/*      one to keep the affinity to the io context that has unpaired Rs       */
        /*   e) both   have  Ds and Rs present, and both includes ghosts, then choose */
	/*      one with latest D ... even it that was a ghost.                       */
	/*                                                                            */
        /* 00b - no  D or R present						      */
        /* 01b - has dangling D present						      */
        /* 10b - has D and R present, no ghosts					      */
	/* 11b - has D and R present, w/ ghosts for D added			      */
	/* w/ ghosts we'll never have an io context with just Rs even if the event    */
	/* stream is that way.							      */

	/* Corner case: Requeue							      */
	_best = NULL;

	_logic_fault = -1;
	evt_count = 0;
	evt_mask  = 0;
        if ((io->event_mask & EVTMSK_D) != 0) 
	{
	    evt_count++;
	    if (io->info != NULL) 
	    {
		if (((io->info->cnt_requeues + io->info->cnt_dispatches) & 0x1) != 0)            evt_mask |= 0x1<<2; /* 01b dangling D, is most eligable */
                else if ((io->info->cnt_requeues > 0) && (io->info->cnt_dispatches_ghosts == 0)) evt_mask |= 0x2<<2; /* 10b has Ds, not ghosts w/Rs      */
		else if ((io->info->cnt_requeues > 0) && (io->info->cnt_dispatches_ghosts != 0)) evt_mask |= 0x3<<2; /* 11b has Ds, some ghosts w/Rs     */
		else assert(0==1);
	    }
	}
        if ((temp->event_mask & EVTMSK_D) != 0) 
	{
	    evt_count++;
	    if (temp->info != NULL) 
	    {
		if (((temp->info->cnt_requeues + temp->info->cnt_dispatches) & 0x1) != 0)            evt_mask |= 0x1<<0; /* 01b dangling D, is most eligable */
                else if ((temp->info->cnt_requeues > 0) && (temp->info->cnt_dispatches_ghosts == 0)) evt_mask |= 0x2<<0; /* 10b has Ds, not ghosts w/Rs      */
		else if ((temp->info->cnt_requeues > 0) && (temp->info->cnt_dispatches_ghosts != 0)) evt_mask |= 0x3<<0; /* 11b has Ds, some ghosts w/Rs     */
		else assert(0==1);
	    }
	}
	dprintf( "DBG[%05d]: 'R' event evt_count=%d evt_mask=%02X\n", __LINE__, evt_count, evt_mask );

	/* If evt_count == 0, then just pick the oldest to hang this unpaired R onto */
	if (evt_count == 0)
	{
	    needs_ghost_d=1;
	    _best = _choose_oldest(io,temp);
	}
	else
	{
	    /* One of more events had a past D event... sort it out			*/
	    switch (evt_mask)
	    {
                /* 00b - no  D or R present						      */
                /* 01b - has dangling D present						      */
                /* 10b - has D and R present, no ghosts					      */
	        /* 11b - has D and R present, w/ ghosts for D added			      */
		case  0: /* 00.00b *//* neither has any D or Rs, so (c) oldest	      */ _best = _choose_oldest(io,temp); needs_ghost_d=1; break;
		case  1: /* 00.01b *//* temp has dangling D!                          */ _best = temp;                    needs_ghost_d=0; break;
		case  2: /* 00.10b *//* temp has D/Rs, no ghosts, still choose this   */ _best = temp;                    needs_ghost_d=1; break; /* this is after all an unpaired R! */
		case  3: /* 00.11b *//* temp has D/Rs, w/ ghosts,       choose this   */ _best = temp;                    needs_ghost_d=1; break; /* another unpaired R!              */
		case  4: /* 01.00b *//*   io has dangling D!                          */ _best =   io;                    needs_ghost_d=0; break;
		case  5: /* 01.01b *//* both has     "                                */ _best = _choose_newest(io,temp); needs_ghost_d=0; break;
		case  6: /* 01.10b *//*   io         "                                */ _best =   io;                    needs_ghost_d=0; break;
		case  7: /* 01.11b *//*   "          "                                */ _best =   io;                    needs_ghost_d=0; break;
		case  8: /* 10.00b *//*   io has D/Rs, no ghosts, still choose this   */ _best =   io;			  needs_ghost_d=1; break; /* this is after all an unpaired R! */
		case  9: /* 10.01b *//* temp has dangling D!                          */ _best = temp;                    needs_ghost_d=0; break;
		case 10: /* 10.10b *//* both has D/Rs, no  ghosts, choose newest      */ _best = _choose_newest(io,temp); needs_ghost_d=1; break;
		case 11: /* 10.11b *//* both has D/Rs, mix ghosts, choose newest      */ _best = _choose_newest(io,temp); needs_ghost_d=1; break;
		case 12: /* 11.00b *//*   io has D/Rs, w/  ghosts                     */ _best =   io;                    needs_ghost_d=1; break;
		case 13: /* 11.01b *//* temp has dangling D!                          */ _best = temp;                    needs_ghost_d=0; break;
		case 14: /* 11.10b *//* both has D/Rs, mix ghosts, choose newest      */ _best = _choose_newest(io,temp); needs_ghost_d=1; break;
		case 15: /* 11.11b *//* both has D/Rs, w/  ghosts, choose oldest?     */ _best = _choose_oldest(io,temp); needs_ghost_d=1; break;
		default: assert(0==1);
	    }
	}
	assert(_best != NULL);
	if (needs_ghost_d != 0)
	{
            printf( "%%W[%05d]-selecting ineligable io context %p for unpaired R event.\n", __LINE__, _best ); fflush(stdout);
	    assert(_best != NULL);
	    printf( "%%I[%05d]-%s() create_ghost_dispatch(%p) for unpaired R event\n", __LINE__, __func__, _best );
           _create_ghost_dispatch(this, _best );
	}
    }
    /* ---end: Special 'R' Code ------------------------------------------------- */


    dprintf( "DBG[%05d]: [%13.9f] %c %s ; io %02X %04X: temp %02X %04X; debug_mask %04X (event not present)\n", __LINE__,
	this->timeinfo.time, this->prmact, this->evttyp, io_qualified, io->event_mask, temp_qualified, temp->event_mask, debug_mask );

    /* Check 2: the pre-requisites for the current event are present                  */
    /*          if all pre-requsistes events are set and only those events = qualify  */
    /*          steps: 1 - create required mask = allowed & ~optional                 */
    /*                 2 - check that only allowed events present                     */
    /*                 3 - remove optional from event                                 */
    /*                 4 - check that required events are all present                 */
    /*                 4 - detected any important optional events                     */
    dprintf( "DBG[%05d]:   io event_mask: %04X %10.10s   opt_care: %04X %10.10s\n", __LINE__, io->event_mask, _showmask(io->event_mask), io_optioncare, _showmask(io_optioncare));
    dprintf( "DBG[%05d]: temp event_mask: %04X %10.10s   opt_care: %04X %10.10s\n", __LINE__, temp->event_mask,_showmask(temp->event_mask),temp_optioncare,_showmask(temp_optioncare));
      option_mask = (io->event_mask & io_optioncare);
    required_mask = (io_event_mask & ~io_optionmask);   /* Step 1 */
    if ((  io->event_mask & ~io_event_mask) == 0)	/* Step 2 */
    {
	temp_mask = io->event_mask & ~io_optionmask;	/* Step 3 */
	if ((temp_mask ^ required_mask) == 0)           /* Step 4 */
	    io_qualified |= 0x02;
	else
	{
	    dprintf( "DBG[%05d]: io %p is missing required events\n", __LINE__, io );
	}
	{
	    dprintf( "DBG[%05d]: io      %p (requeues=%d)\n", __LINE__, io, (io->info!=NULL)?io->info->cnt_requeues:-1 );
	    dprintf( "DBG[%05d]: io mask %04X %10.10s ->event_mask\n", __LINE__, io->event_mask, _showmask(io->event_mask));
	    dprintf( "DBG[%05d]: allowed %04X %10.10s   event_mask\n", __LINE__, io_event_mask,  _showmask( io_event_mask));
	    dprintf( "DBG[%05d]: options %04X %10.10s   optional (removal mask)\n", __LINE__, (~io_optionmask) & 0xFFFF, _showmask(io_optionmask) );
	    dprintf( "DBG[%05d]: remains %04X %10.10s   after removing optional\n", __LINE__, temp_mask, _showmask(temp_mask));
	    dprintf( "DBG[%05d]: require %04X %10.10s   required mask\n",  __LINE__, required_mask, _showmask(required_mask));
	    dprintf( "DBG[%05d]: results %04x %10.10s   (must be zero)\n", __LINE__, (temp_mask ^ required_mask), " " );
	    dprintf( "DBG[%05d]: optcare %04x %10.10s   (better !zero)\n", __LINE__, io_optioncare, _showmask(option_mask) );
	}
    }
    else
    {
	dprintf( "DBG[%05d]:   io %p contains non-allowed event(s)!\n", __LINE__, io );
	{
	    dprintf( "DBG[%05d]: io      %p (requeues=%d)\n", __LINE__, io, (io->info!=NULL)?io->info->cnt_requeues:-1 );
	    dprintf( "DBG[%05d]: io mask %04X %10.10s ->event_mask\n", __LINE__, io->event_mask, _showmask(io->event_mask));
	    dprintf( "DBG[%05d]: allowed %04X %10.10s   event_mask\n", __LINE__, io_event_mask,  _showmask( io_event_mask));
	    dprintf( "DBG[%05d]: options %04X %10.10s   optional (removal mask)\n", __LINE__, (~io_optionmask) & 0xFFFF, _showmask(io_optionmask) );
	    dprintf( "DBG[%05d]: remains %04X %10.10s   after removing optional\n", __LINE__, temp_mask, _showmask(temp_mask));
	    dprintf( "DBG[%05d]: require %04X %10.10s   required mask\n",  __LINE__, required_mask, _showmask(required_mask));
	    dprintf( "DBG[%05d]: results %04x %10.10s   (must be zero)\n", __LINE__, (temp_mask ^ required_mask), " " );
	    dprintf( "DBG[%05d]: optcare %04x %10.10s   (better !zero)\n", __LINE__, io_optioncare, _showmask(option_mask) );
	}
    }
      option_mask = (temp->event_mask &  temp_optioncare);
    required_mask = (temp_event_mask  & ~temp_optionmask);   
    if ((temp->event_mask & ~temp_event_mask) == 0)
    {
	temp_mask = temp->event_mask & ~temp_optionmask;
	if ((temp_mask ^ required_mask) == 0)
	    temp_qualified |= 0x02;
	else
	{
	    dprintf( "DBG[%05d]: temp %p is missing required events\n", __LINE__, temp );
	}
	{
	    dprintf( "DBG[%05d]: temp    %p\n", __LINE__, temp );
	    dprintf( "DBG[%05d]: temp    %p (requeues=%d)\n", __LINE__, temp, (temp->info!=NULL)?temp->info->cnt_requeues:-1 );
	    dprintf( "DBG[%05d]: io mask %04X %10.10s ->event_mask\n", __LINE__, temp->event_mask, _showmask(temp->event_mask));
	    dprintf( "DBG[%05d]: allowed %04X %10.10s   event_mask\n", __LINE__, temp_event_mask,  _showmask(temp_event_mask));
	    dprintf( "DBG[%05d]: options %04X %10.10s   optional (removal mask)\n", __LINE__, (~temp_optionmask) & 0xFFFF, _showmask(temp_optionmask) );
	    dprintf( "DBG[%05d]: remains %04X %10.10s   after removing optional\n", __LINE__, temp_mask, _showmask(temp_mask));
	    dprintf( "DBG[%05d]: require %04X %10.10s   required mask\n",  __LINE__, required_mask, _showmask(required_mask));
	    dprintf( "DBG[%05d]: results %04x %10.10s   (must be zero)\n", __LINE__, (temp_mask ^ required_mask), " " );
	    dprintf( "DBG[%05d]: optcare %04x %10.10s   (better !zero)\n", __LINE__, temp_optioncare, _showmask(option_mask) );
	}
    }
    else
    {
	dprintf( "DBG[%05d]: temp %p contains non-allowed event(s)!\n", __LINE__, temp );
	{
	    dprintf( "DBG[%05d]: temp    %p\n", __LINE__, temp );
	    dprintf( "DBG[%05d]: temp    %p (requeues=%d)\n", __LINE__, temp, (temp->info!=NULL)?temp->info->cnt_requeues:-1 );
	    dprintf( "DBG[%05d]: io mask %04X %10.10s ->event_mask\n", __LINE__, temp->event_mask, _showmask(temp->event_mask));
	    dprintf( "DBG[%05d]: allowed %04X %10.10s   event_mask\n", __LINE__, temp_event_mask,  _showmask(temp_event_mask));
	    dprintf( "DBG[%05d]: options %04X %10.10s   optional (removal mask)\n", __LINE__, (~temp_optionmask) & 0xFFFF, _showmask(temp_optionmask) );
	    dprintf( "DBG[%05d]: remains %04X %10.10s   after removing optional\n", __LINE__, temp_mask, _showmask(temp_mask));
	    dprintf( "DBG[%05d]: require %04X %10.10s   required mask\n",  __LINE__, required_mask, _showmask(required_mask));
	    dprintf( "DBG[%05d]: results %04x %10.10s   (must be zero)\n", __LINE__, (temp_mask ^ required_mask), " " );
	    dprintf( "DBG[%05d]: optcare %04x %10.10s   (better !zero)\n", __LINE__, temp_optioncare, _showmask(option_mask) );
	}
    }
      io_optioncare =   io->event_mask &   io_optioncare; /* Step 5 */
    temp_optioncare = temp->event_mask & temp_optioncare; /* Step 5 */

    dprintf( "DBG[%05d]: [%13.9f] %c %s ; io %02X %04X: temp %02X %04X; event_mask %04X %04X (pre-reqs present )\n", __LINE__,
	this->timeinfo.time, this->prmact, this->evttyp, 
	  io_qualified,   io->event_mask, 
	temp_qualified, temp->event_mask, io_event_mask, temp_event_mask );

    /* Check 3: check full io type is *exactly* the same (with some notable excepts)  */ /* FWFS => WFS later events, for example */
    /*          special in special1: if this is C and evtyp is WS, change this to FWS */
    strcpy(string,this->evttyp);
    len = strlen(string);
    /* this should be moved to each event type or to a common routine 
    if (this->prmact == 'C')
    {
	if ((strlen(io->evttyp) == 3) && (strncmp(io->evttyp,"FWS",3) == 0))	
	{
	    if ((len == 2) && (strncmp(string,"WS",2)==0))
	    {
		strcpy(string,"FWS");
		len = 3;
	    }
	}
    }*/
    /* We shouldn't have gotten here if the io type wasn't a match. but... */
    if ((strlen(  io->evttyp) == len) && (strncmp(  io->evttyp,string,len)==0))   io_qualified |= 0x04;
    if ((strlen(temp->evttyp) == len) && (strncmp(temp->evttyp,string,len)==0)) temp_qualified |= 0x04;
    if ((io_qualified & 0x04) == 0)
    {
	/* 2nd chance */
	if ((strlen(string)==2) && (strncmp(string,"WS",2)==0))
	{
	    /* Allow this to match FWS or FWFS */
	    if ( ((strlen(io->evttyp) == 3) && (strncmp(io->evttyp,"FWS",3)==0)) ||
		 ((strlen(io->evttyp) == 4) && (strncmp(io->evttyp,"FWFS",4)==0)))
		io_qualified |= 0x04;
	}
    }
    if ((temp_qualified & 0x04) == 0)
    {
	/* 2nd chance */
	if ((strlen(string)==2) && (strncmp(string,"WS",2)==0))
	{
	    /* Allow this to match FWS or FWFS */
	    if ( ((strlen(temp->evttyp) == 3) && (strncmp(temp->evttyp,"FWS",3)==0)) ||
		 ((strlen(temp->evttyp) == 4) && (strncmp(temp->evttyp,"FWFS",4)==0)))
		temp_qualified |= 0x04;
	}
    }
    dprintf( "DBG[%05d]: [%13.9f] %c %s ; io %02X %4s: temp %02X %4s (expecting 07 xxxx for qualification)\n", __LINE__,
	this->timeinfo.time, this->prmact, this->evttyp, io_qualified, io->evttyp, temp_qualified, temp->evttyp );

    /* Ok, both, 1, or none typ_io context passed in qualified at this point? */
    /* Check 4: use timestamp to discriminate which to use only if both qual'd*/
    best = NULL;
    if ((io_qualified == 0x07) && (temp_qualified == 0x07))
    {
	/* both qualified.  Use optionmask as 1st tie breaker */
	dprintf( "DBG[%05d]: best_match() both context fully qualified, choosing one with best option mask\n", __LINE__ );
	if ((io_optioncare != 0) && (temp_optioncare == 0))
        {
	    best = io;
	    dprintf( "DBG[%05d]: best_match(), choose   'io' (iscare) %p [%13.9f] %c %s\n", __LINE__, best, best->timeinfo.time, best->prmact, best->evttyp );
	    dprintf( "DBG[%05d]:                      'temp' (nocare) %p [%13.9f] %c %s\n", __LINE__, temp, temp->timeinfo.time, temp->prmact, temp->evttyp );
	}
	else if ((io_optioncare == 0) && (temp_optioncare != 0))
	{
	    best = temp;
	    dprintf( "DBG[%05d]: best_match(), choose 'temp' (iscare) %p [%13.9f] %c %s\n", __LINE__, temp, temp->timeinfo.time, temp->prmact, temp->evttyp );
	    dprintf( "DBG[%05d]:                        'io' (nocare) %p [%13.9f] %c %s\n", __LINE__, best, best->timeinfo.time, best->prmact, best->evttyp );
	}
	if (best == NULL)
	{
	/* both qualified.  Use timestamp  as 2nd tie breaker */
	dprintf( "DBG[%05d]: best_match() both context fully qualified, choosing oldest by time (or SeqNo if tied)\n", __LINE__ );
	if (io->timeinfo.time < temp->timeinfo.time)
	{
	    best = io;
	    dprintf( "DBG[%05d]: best_match(), choose   'io' (oldest) %p [%13.9f] %c %s\n", __LINE__, best, best->timeinfo.time, best->prmact, best->evttyp );
	    dprintf( "DBG[%05d]:                      'temp' (newest) %p [%13.9f] %c %s\n", __LINE__, temp, temp->timeinfo.time, temp->prmact, temp->evttyp );
	}
	else if (io->timeinfo.time == temp->timeinfo.time)
	{
	    /* simultaneous io? use event type SeqNo ticket as tie breaker */
	         if (io->info->ASeqNo != 0) { ioSeqNo = io->info->ASeqNo; tempSeqNo = temp->info->ASeqNo; }
	    else if (io->info->QSeqNo != 0) { ioSeqNo = io->info->QSeqNo; tempSeqNo = temp->info->QSeqNo; }
	    else
	    {
		PROG_FEATURE_FAULT(this,(typ_io *),"fatal internal logic, neither ASeqNo nor QSeqNo is available?",CTL_FAULT_FORCE);
	    }
	    assert(   ioSeqNo != 0 );
	    assert( tempSeqNo != 0 );

	    if (ioSeqNo < tempSeqNo)
	    {
		 best = io;
	         dprintf( "DBG[%05d]: best_match(), choose   'io' (oldest) %p [%13.9f] %c %s (time tied, using %lu<%lu SeqNo)\n", __LINE__, 
			best, best->timeinfo.time, best->prmact, best->evttyp, ioSeqNo, tempSeqNo );
	         dprintf( "DBG[%05d]:                      'temp' (newest) %p [%13.9f] %c %s\n", __LINE__, temp, temp->timeinfo.time, temp->prmact, temp->evttyp );
	    }
	    else
	    {
	         best = temp;
	         dprintf( "DBG[%05d]: best_match(), choose 'temp' (oldest) %p [%13.9f] %c %s (time tied, using %lu<%lu SeqNo)\n", __LINE__, 
			best, best->timeinfo.time, best->prmact, best->evttyp, tempSeqNo, ioSeqNo );
	         dprintf( "DBG[%05d]:                        'io' (newest) %p [%13.9f] %c %s\n", __LINE__, io, io->timeinfo.time, io->prmact, io->evttyp );
	    }
	}
        else
	{
	    best = temp;
	    dprintf( "DBG[%05d]: best_match(), choose 'temp' (oldest) %p [%13.9f] %c %s\n", __LINE__, best, best->timeinfo.time, best->prmact, best->evttyp );
	    dprintf( "DBG[%05d]:                        'io' (newest) %p [%13.9f] %c %s\n", __LINE__, io, io->timeinfo.time, io->prmact, io->evttyp );
	}
	}
	state.best_match_good++;
    }
    else if ((io_qualified == 0x07) && (temp_qualified != 0x07))
    {
	best = io;
	dprintf( "DBG[%05d]: best_match(), 1st   'io'    qualified (      ) %p [%13.9f] %c %s\n", __LINE__, best, best->timeinfo.time, best->prmact, best->evttyp );
	dprintf( "DBG[%05d]; best_match(), Nth 'temp' disqualified (      ) %p [%13.9f] %c %s\n", __LINE__, temp, temp->timeinfo.time, temp->prmact, temp->evttyp );
	state.best_match_high++;
    }
    else if ((io_qualified != 0x07) && (temp_qualified == 0x07))
    {
	best = temp;
	dprintf( "DBG[%05d]; best_match(), 1st   'io' disqualified (      ) %p [%13.9f] %c %s\n", __LINE__, io, io->timeinfo.time, io->prmact, io->evttyp );
	dprintf( "DBG[%05d]: best_match(), Nth 'temp'    qualified (      ) %p [%13.9f] %c %s\n", __LINE__, best, best->timeinfo.time, best->prmact, best->evttyp );
	state.best_match_high++;
    }
    else if ((io_qualified != 0x07) && (temp_qualified != 0x07))
    {
	/* neither matched? Huh? Need to call a manager for assistance */
        state.best_match_checks++;
	dprintf( "DBG[%05d]; best_match(), 1st   'io' disqualified (      ) %p [%13.9f] %c %s\n", __LINE__, io, io->timeinfo.time, io->prmact, io->evttyp );
	dprintf( "DBG[%05d]: best_match(), Nth 'temp' disqualified (      ) %p [%13.9f] %c %s\n", __LINE__, temp, temp->timeinfo.time, temp->prmact, temp->evttyp );
	best = NULL;
	if (_best == NULL)
	    return((typ_io *)NULL);
	else
	    best = _best;
    }
    else
    {
	/* neither matched? Huh? Need to call a manager for assistance */
	if (_best == NULL)
	{
	    best = NULL;
	    PROG_FEATURE_FAULT(this,(typ_io *),"internal logic fault, should never get here!",CTL_FAULT_FORCE);
	}
	else
	    best = _best;
    }
	

    state.best_match_checks++;

    if (((  io->evtflags & EVTFLG_BESTMATCH) == 0) &&
        ((temp->evtflags & EVTFLG_BESTMATCH) == 0))
        state.best_match_contexts++;
      io->evtflags &= ~EVTFLG_BESTMATCH;	/* Clear this flag on both input contexts */
    temp->evtflags &= ~EVTFLG_BESTMATCH;
    best->evtflags |=  EVTFLG_BESTMATCH;	/* And set on found best match            */

    if ((this->prmact == 'D') && (_best != NULL))
    {
	if (best != _best) 
	{
	    /* There is corner case code up above that revaluates unbalanced requeues (has R&D but missing final D) vs just ones missing D */
	    /* in the corner case of overlapping io (so corner case of a corner case).  In majority of the cases, the normal path will id  */
	    /* the right io context that should get this D event, but the corner corner case code is more exacting in determining the right*/
            /* io context and we get here when the normal corner case selection doesn't match the corner,corner case code for D events and */
	    /* overwrites the "best" selection when they two code paths differ.  This only applies to D events and only when unbalanced    */
	    /* requeues exist (and only when there are overlapping io of same lba:length).					           */
	    logEprintf( "%%E[%05d]-%s( io.%p temp.%p ) assign D to best.%p (_best.%p)\n", __LINE__, __func__, io, temp, best, _best );
	    logEprintf( "%%E[%05d]-switching best.%p to _best.%p **********************************************************\n", __LINE__, best, _best );
	    best = _best;
	}
	printf( "%%I[%05d]-assign D to %p (_best=%p)\n", __LINE__, best, _best );
    }
    else
    {
        if (this->prmact == 'D') printf( "%%I[%05d]-assign D to %p (_best=%p)\n", __LINE__, best, _best );
    }
    if ((this->prmact == 'R') && (_best != NULL))
    {
	if (best != _best) 
	{
	    /* There is corner case code up above that revaluates requeuess to ensure that are associated with an io context that has two  */
	    /* conditions: 1) has an outstanding 'D' without requeue, and 2) the special code chose a different one than normal code did   */
	    logEprintf( "%%E[%05d]-%s( io.%p temp.%p ) assign R to best.%p (_best.%p)\n", __LINE__, __func__, io, temp, best, _best );
	    logEprintf( "%%E[%05d]-switching best.%p to _best.%p **********************************************************\n", __LINE__, best, _best );
	    best = _best;
	}
	printf( "%%I[%05d]-assign R to %p (_best=%p)\n", __LINE__, best, _best );
    }
    else
    {
        if (this->prmact == 'R') printf( "%%I[%05d]-assign R to %p (_best=%p)\n", __LINE__, best, _best );
    }
    _return(best);
}

static char _prmtyp( unsigned char prmtyp )
{
static char __prmtyp_list[16] = "xoNSRWMBD";
    if ((prmtyp >= 0) && (prmtyp <= IOTYP_MAX)) return(__prmtyp_list[prmtyp]);
    else                                        return('?');
}

static int _internal_exit(int sts)
{
    printf( "%%F[%05d]-exiting due to internal/fatal condition, please contact maintainer and provide support case number + blktrace data set being parsed.\n", __LINE__ );
    printf( "%%I[%05d]-version    %s\n", __LINE__, VERSION );
    printf( "%%I[%05d]-maintainer %s\n", __LINE__, MAINTAINER );
    exit(1);
}

static long _get_filesize(char *filename)
{
int fd;
struct stat statbuf;

    if ((fd = open(filename, O_RDONLY, S_IRWXU)) > 0)
    {
        fstat(fd, &statbuf);
        close(fd);
        return((long)statbuf.st_size);
    }
    printf( "DBG[%05d]: cannot open file '%s', return size as -1\n", __LINE__, filename);
}
static char *_cvtseconds( long seconds )
{
static char hhmmss[16];
long hh, mm, ss, rem;

    hh = seconds / 3600; rem = seconds % 3600;
    mm = rem     /   60; rem = rem     %   60;
    ss = rem;

    sprintf( hhmmss, "%5ld:%02ld:%02ld", hh, mm, ss );
    return(hhmmss);
}
static char *_difseconds()
{
static char hhmmss[16];
long hh, mm, ss, rem;

    state.cur_seconds = (unsigned long)time(NULL);
    rem = state.cur_seconds - state.bgn_seconds;

    hh = rem / 3600; rem = rem % 3600;
    mm = rem /   60; rem = rem %   60;
    ss = rem;

    sprintf( hhmmss, "%5ld:%02ld:%02ld", hh, mm, ss );
    return(hhmmss);
}

/* 
 * ==========================================================================================
 * ==========================================================================================
 * IO Context Event Signature Creation & Statistics
 * ==========================================================================================
 * ==========================================================================================
 */

/**
 * ==========================================================================================
 * Function : event_sig_add
 *            @
 * Args     : @io:          io context
 *            @event        event context
 * Returns :  0
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Add this event signature to the io context's event_sigs field.
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * Apply event type limits, aka all events except RIDC only    << @@@TBD
 * allowed once within the signature and RIDC only allowed
 * a maximum of twice each.
 *
 * This is called only *after* the event is matched to the io
 * context.
 *
 **/
int event_sig_add(typ_io *io, typ_event *event)
{
static char str_seclen[8][4]= { "@@", "xx", "0x", "00", "Sx", "S0", "??", "??" };
       char   sect_len   [4];
       int    evtcnt;
       int    added;
    
    /* evtact has full event action, aka "FWFS"	 */
    /* prmact has primary action   , aka  'W'    */
    /* prmtyp has primary action number          */
    if (event == NULL) { printf( "DBG[%05d]: %s(event null)\n", __LINE__, __func__ ); return(0); }

    /* @@@TBD we should create the sig for this event and add it the event_signatures->mgmt list as these include P, U, T, et.al. non-io events */
    if (io    == NULL) { /* @@@TBD create sig and add to event_signatures->mgmt list (P,U,T,et.al non-io cases) */ return(0); }
  
    /* Always ensure that event_sigs has basic type information present ... */ 
    if (io->event_sigs[0] == 0)
    {
	if (event->imbtyp != 0)
	    io->event_sigs[0] = 'i';
	else
	{
            switch (event->prmtyp)
            {
		default            :
		case IOTYP_UNK     : io->event_sigs[0] = 'x'; break;
		case IOTYP_OTHER   : io->event_sigs[0] = 'c'; break;
		case IOTYP_NONE    : io->event_sigs[0] = 'n'; break;
		case IOTYP_SCHED   : io->event_sigs[0] = 'x'; break;
		case IOTYP_READ    : io->event_sigs[0] = 'r'; break;
		case IOTYP_WRITE   : io->event_sigs[0] = 'w'; break;
		case IOTYP_META    : io->event_sigs[0] = 'm'; break;
		case IOTYP_BARRIER : io->event_sigs[0] = 'b'; break;
		case IOTYP_DISCARD : io->event_sigs[0] = 'd'; break;
	    }
        }
	io->event_sigs[1] = ';';
    }

#   define _addsig( _ndx, _allow, _desc ) if ((evtcnt = io->event_count[ _ndx ]) <= _allow) { added=1 ; strcat( io->event_sigs, _desc ); }

    added = 0;
    switch (event->prmact)
    {
	case 'A': /* remAp		*/ _addsig( EVTNDX_A, 1,   "A/" ); break;  /* might be multiples, A,A,A...   */
	case 'Q': /* Queue		*/ _addsig( EVTNDX_Q, 1,   "Q/" ); break;
	case 'S': /* Sleep		*/ _addsig( EVTNDX_S, 1,   "S/" ); break;  /* might be multiples, G,S,G,S... */
	case 'G': /* Get-request        */ _addsig( EVTNDX_G, 1,   "G/" ); break;
	case 'X': /* X-split            */ _addsig( EVTNDX_X, 1,   "X/" ); break;  /* might be multiples	     */
	case 'M': /* Merge   		*/ _addsig( EVTNDX_M, 1,   "M/" ); break;
	case 'F': /* Front-merge        */ _addsig( EVTNDX_F, 1,   "F/" ); break;
	case 'I': /* Insert           	*/ _addsig( EVTNDX_I, 2,   "I/" ); break;  /* might be multiples, IDRIDRID   */
	case 'D': /* Dispatch           */ _addsig( EVTNDX_D, 2,   "D/" ); break;  /* might be multiples, IDRIDRID   */
	case 'R': /* Requeues 		*/ _addsig( EVTNDX_R, 2,   "R/" ); break;  /* might be multiples, IDRIDRID   */
	case 'C': /* Completion         */ _addsig( EVTNDX_C, 2,   "C/" ); break;  /* might be multiples, CC         */
	case 'P': /* Plug               */ strcat( io->event_sigs, "P/" ); added++; break;  
        case 'U': /* Unplug             */ strcat( io->event_sigs, "U/" ); added++; break;
	case 'T': /* Timer              */ strcat( io->event_sigs, "T/" ); added++; break;
	case 'm': /* message            */ strcat( io->event_sigs, "m/" ); added++; break;
	case 'x': /* other/unknown      */
	default :                          strcat( io->event_sigs, "x/" ); added++; break;
    }
#   undef _addsig

    if (added != 0)
    {
        strcat( io->event_sigs, event->evttyp );
        strcat( io->event_sigs, ","           );
    
        sect_len[2] = ';'; sect_len[3] = 0;
        if (event->imbtyp == 0)
        {
                 if ((event->evtflags & EVTFLG_VALID_SECTOR) == 0)  sect_len[0] = 'x';
	    else if (event->sector                           == 0)  sect_len[0] = '0';
	    else                                                    sect_len[0] = 'S';
                 if ((event->evtflags & EVTFLG_VALID_LENGTH) == 0)  sect_len[1] = 'x';
	    else if (event->length                           == 0)  sect_len[1] = '0';
	    else                                                    sect_len[1] = 'L';
        }
        else
        {
	    sect_len[0] = str_seclen[event->imbtyp][0];
	    sect_len[1] = str_seclen[event->imbtyp][1];
        }
        strcat( io->event_sigs, sect_len );
    }

    printf( "DBG[%05d]: %s(%p,%p,%d|%04X,%d:sig '%s')\n", __LINE__, __func__, io, event, evtcnt, io->event_mask, added, io->event_sigs ); fflush(stdout); sleep(0.1);
    assert((strlen(io->event_sigs) < (MAXLEN_EVTSIGS-16)));
    return(0);
}


/*
 * 'event_datablk' structures is a raw (largish) block of memory pre-allocated for
 * 'event_signatures' entries.  These individual events are hard sorted by their
 * leading character (e.g. 'w;A/WS,SL;Q/WS,SL;G/WS,SL;M/WS,SL;D/WS,SL;' would be
 * added to event_signatures->io_writes list).  Initially a separate datablk is
 * allocated for the normal/common types (r,w,...) Less common types might share
 * a datablk.
 *
 * sighdr -> datablk -> datablk -> datablk -> null
 * sighdr -> head    -> next    -> next    -> null
 *
 */


/**
 * ==========================================================================================
 * Function : io_sig_init
 *            @
 * Args     : @iof:          FILE input file handle
 *
 * Returns  : 0
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Allocate and initialize the event signature headers/datablks
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int io_sig_init( FILE *iof )
{
static int __init = 0;
int  n = 0;
char inpline[MAXBUF];
typ_event_signature *iosig;

    if (__init != 0) return(0);
    __init++;

    bzero(&state.event_signatures,sizeof(state.event_signatures));
    _io_sig_hdralloc(&state.event_signatures.io_nones   );
    _io_sig_hdralloc(&state.event_signatures.io_reads   );
    _io_sig_hdralloc(&state.event_signatures.io_writes  );
    _io_sig_hdralloc(&state.event_signatures.io_meta    );
    _io_sig_hdralloc(&state.event_signatures.io_discards);
    _io_sig_hdralloc(&state.event_signatures.io_barriers);
    _io_sig_hdralloc(&state.event_signatures.imbs       );
    _io_sig_hdralloc(&state.event_signatures.mgmt       );
    _io_sig_hdralloc(&state.event_signatures.others     );

    if (iof != NULL)
    {
        /* Read in signatures and add them to the appropriate list */
        while (fgets(inpline,MAXBUF,iof) != NULL)
	{
	    if (inpline[0] != '#')
	    {
	        strtrim(inpline);
	        if ((iosig = io_sig_count(inpline)) != NULL) { n++; iosig->state_machine_conf = STATEMCH_CFG_PRELOAD;}
	    }
	}
    }
    return(n);
}

/**
 * ==========================================================================================
 * Function : io_sig_count
 *            @
 * Args     : @io:		io context
 *
 * Returns  : 0
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Finding a matching signature and bump its count, if none found then add this new
 * signature w/ a count of 1.
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
typ_event_signature *io_sig_count( char *event_sigs )
{
int len = strlen(event_sigs);
typ_event_sighdr **psighdr;
typ_event_sighdr *sighdr;
typ_event_signature *iosig;

    printf( "DBG[%05d]: %s()\n", __LINE__, __func__ );
    io_sig_init(NULL);

    switch (event_sigs[0])
    {
        case 'n': psighdr = &state.event_signatures.io_nones;    break;
	case 'r': psighdr = &state.event_signatures.io_reads;    break;
	case 'w': psighdr = &state.event_signatures.io_writes;   break;
	case 'm': psighdr = &state.event_signatures.io_meta;     break;
	case 'd': psighdr = &state.event_signatures.io_discards; break;
	case 'b': psighdr = &state.event_signatures.io_barriers; break;
	case 'i': psighdr = &state.event_signatures.imbs;        break;
	case 'c': psighdr = &state.event_signatures.mgmt;        break;
	case 'x': psighdr = &state.event_signatures.others;      break;
	default : return((void *)NULL);
    }
    sighdr = *psighdr;
    if (*psighdr == NULL)
    {
        sighdr = _io_sig_hdralloc(psighdr);
    }
    else

    /* Search the list for a match */
    for (iosig = sighdr->head; iosig != NULL; iosig = iosig->next)
    {
        if (iosig->len != len) continue;
	if (strncmp(iosig->signature, event_sigs, len ) != 0) continue;
	iosig->count++;
	return(iosig);
    }

    return(_io_sig_add(sighdr, event_sigs ));
}


/**
 * ==========================================================================================
 * Function : io_sig_add
 *            @
 * Args     : @sighdr:		event signature header for this type of event
 *            @signature:	series of events encountered in the io context
 *
 * Returns  : 0
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Add a new signature to the list
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
static typ_event_signature *_io_sig_add(typ_event_sighdr *sighdr, char *signature )
{
typ_event_signature *iosig;
typ_event_datablk   *datablk;
unsigned long bytes;

    printf( "DBG[%05d]: %s(%s)\n", __LINE__, __func__, signature );

    if ((datablk = sighdr->datablk) == NULL)
    {
        datablk = _io_sig_blkalloc(sighdr);
    }

    bytes = (sizeof(typ_event_signature) + strlen(signature) + 7) & ~0x7L;
    if (datablk->free_size < bytes)
	datablk = _io_sig_blkalloc(sighdr);

    iosig = datablk->free;

    if (sighdr->last == NULL)
    {
	sighdr->head       = iosig;
	sighdr->last       = iosig;
    }
    else
    {
        sighdr->last->next = iosig;
        sighdr->last       = iosig;
    }
    datablk->free_size -= bytes;
    datablk->free       = (void *)(((unsigned long)datablk->free)+bytes);

    iosig->next = (void *)NULL;
    iosig->count= 1;
    iosig->state_machine_conf = 0;		/* Runtime signature		*/
    iosig->len  = strlen(signature);
    strcpy(iosig->signature, signature );

    sighdr->cnt_sigs++;

    return(iosig);
}


/**
 * ==========================================================================================
 * Function : io_sig_dump
 *            @
 * Args     : @iof:          FILE output file handle
 *
 * Returns  : 0
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Dump each of the event signature lists.
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
int io_sig_dump( FILE *iof )
{

    printf( "DBG[%05d]: ===================================================================================\n", __LINE__ );
    printf( "DBG[%05d]: %s()\n", __LINE__, __func__ );
    io_sig_init(NULL);

    _io_sig_dump( iof, state.event_signatures.io_nones,     "Nones"   );
    _io_sig_dump( iof, state.event_signatures.io_reads,     "Reads"   );
    _io_sig_dump( iof, state.event_signatures.io_writes,    "Writes"  );
    _io_sig_dump( iof, state.event_signatures.io_meta,      "Meta"    );
    _io_sig_dump( iof, state.event_signatures.io_discards,  "Discards");
    _io_sig_dump( iof, state.event_signatures.io_barriers,  "Barriers");
    _io_sig_dump( iof, state.event_signatures.imbs,         "IMBs"    );
    _io_sig_dump( iof, state.event_signatures.mgmt,         "Mgmt"    );
    _io_sig_dump( iof, state.event_signatures.others,       "Others"  );
    printf( "DBG[%05d]: --- EOL ---------------------------------------------------------------------------\n", __LINE__ );
    return(0);
}
/**
 * ==========================================================================================
 * Function : _io_sig_dump
 *            @
 * Args     : @iof:          FILE output file handle
 *            @sighdr        event signature header
 *
 * Returns  : 0
 *
 * Description
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Dump the passed in event signature list
 *
 * Notes
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 **/
static int _io_sig_dump(FILE *iof, typ_event_sighdr *sighdr, char *title)
{
int n=0;
typ_event_signature *iosig;
typ_event_datablk   *datablk;

    if (iof == NULL) iof = stdout;  /* for debug purposes */
    fprintf( iof, "Event Signatures : %-16s cnt=%d\n", title, sighdr->cnt_sigs );
    if (sighdr->cnt_sigs != 0)
    {
        for (n=1, iosig=sighdr->head; iosig != NULL; iosig = iosig->next, n++)
            fprintf( iof, "    [%3d] %5d : '%s' [%2d,%d]\n", n, iosig->count, iosig->signature, iosig->len, iosig->state_machine_conf );
        fprintf( iof, "      DataBlks   :\n");
        for (n=1, datablk = sighdr->datablk; datablk != NULL; datablk = datablk->next, n++)
            fprintf( iof, "    [%3d] %16p\n", n, datablk );
    }
    return(n);
}


static typ_event_sighdr *_io_sig_hdralloc(typ_event_sighdr **psighdr)
{
typ_event_sighdr *sighdr;

    if (*psighdr == NULL)
    {
        sighdr = malloc(sizeof(typ_event_sighdr));
        bzero(sighdr,sizeof(typ_event_sighdr));
	*psighdr = sighdr;
	return(sighdr);
    }
    return(*psighdr);
}
static typ_event_datablk *_io_sig_blkalloc(typ_event_sighdr *sighdr)
{
typ_event_datablk *buffer;

    buffer = malloc((sizeof(typ_event_datablk)+DATABLK_SIZE));
    bzero(buffer,(sizeof(typ_event_datablk)+DATABLK_SIZE));

    buffer->alloc_size = sizeof(typ_event_datablk)+DATABLK_SIZE;
    buffer->free_size  = DATABLK_SIZE;
    buffer->free       = &buffer->pool[0];

    if (sighdr->datablk == NULL)
    {
        /* 1st block   */
        sighdr->datablk = buffer;
    }
    else
    {
        buffer->next    = sighdr->datablk;
        sighdr->datablk = buffer;
    }
    return(buffer);
}


/* 
 * ==========================================================================================
 * ==========================================================================================
 * IMB (Implicit) Barriers
 * ==========================================================================================
 * ==========================================================================================
 */
/* 
 * return zero if not an implicit io barrier, otherwise return
 * a positive value of the sub-type of imb within the event.
 *
 * This *only* looks at sector,length fields ... but only for
 * R,W,N io types (so as to ignore U,T,UT, and similar which
 * wont have a sector,length anyway.
 *
 */
int imb_event(typ_event *this)
{
    /* Only do this if the primary action is a R,W,N ... which auto-excludes explicit 'B'arriers too as needed */
    d4printf( "DBG[%05d]: %s(%d,'%s')\n", __LINE__, __func__, this->prmtyp, this->evttyp );

    this->imbtyp = IMBTYP_NONE;

    /* Sector,Length */
    if ((this->prmtyp != IOTYP_READ ) &&
        (this->prmtyp != IOTYP_WRITE) &&		   
	(this->prmtyp != IOTYP_NONE ) &&
	(this->prmtyp != IOTYP_META ))
    {
        /* Ignoring DISCARD, BARRIER, and OTHER types */
        _return(0);
    }
    /* Also disallow for N io types for P, U, and other misc non-io events */
    if (this->prmtyp == IOTYP_NONE)
    {
	if ((this->prmact == 'P') ||
	    (this->prmact == 'U') ||
	    (this->prmact == 'T') ||
	    (this->prmact == '@') ||
	    (this->prmact == 'm') ||
	    (this->prmact == '-') ||
	    (this->prmact == 'N'))
	    return(0);
    }

    if ((this->evtflags & EVTFLG_VALID_SECTOR) == 0)
    {
        _assert(((this->evtflags & EVTFLG_VALID_LENGTH)==0));	/* no sector implies no length! */
	this->imbtyp    = IMBTYP_xx ;
    }
    else /* must be valid sector available... */
    {
	if (this->sector == 0)
	{
	    if ((this->evtflags & EVTFLG_VALID_LENGTH) == 0)
	        this->imbtyp = IMBTYP_0x;
	    else if (this->length == 0)
		this->imbtyp = IMBTYP_00;
	    /* else sector=0, length=<non-zero> aka not a barrier */
	}
	else /* non-zero sector available */
	{
	    /* Sector valid and > 0 */
	    if ((this->evtflags & EVTFLG_VALID_LENGTH) == 0)
	        this->imbtyp = IMBTYP_Sx;
	    else if (this->length == 0)
		this->imbtyp = IMBTYP_S0;
	    /* else sector=<non-zero>, length=<non-zero> aka not a barrier */
	}
    }

    if (this->imbtyp != IMBTYP_NONE)
    {
	printf( "DBG[%05d]: %s(imbtyp=%d)\n", __LINE__, __func__, this->imbtyp );
	this->evtflags |= EVTFLG_IMB;
	_return( this->imbtyp );
    }
    _return(0);
}
/*
 * Add IMB io context to end of lookaside cache list of pointers.  Don't use 
 * previously freed entries (-1) as the order of occuring IMBs need to be 
 * preserved so much add only to first end-of-list entry.  Since the whole
 * list needs to be traversed up until first end-of list entry anyway, perform
 * a list compression, if needed, at the same time.  Doing so means the list only
 * has to be traversed once (vs check, compress, check again).
 *
 */
int imb_active_add(typ_io *this)
{
int free = 0;
int found= -1;
int src,dst;
    /* Add an active imb io context to the look aside cache list.  */

    /* Currently only adding the context in cases of A|Q that have */
    /* S0 case, but could add Sx case also.  Others like xx, not   */
    /* sure at this time or 00 -- maybe later.			   */
    /* Example:
     * 259,0   11       49    10.010404464  1889  A FWFS 575480752 + 0 <- (253,3) 407706544
     * 259,0   11       50    10.010404572  1889  Q FWFS [jbd2/dm-4-8]
     * 259,0   11       51    10.010405867  1889  G FWFS [jbd2/dm-4-8]
     * 259,0   11       52    10.010410793   612  D  FN [kworker/11:1H]
     * 259,0   11       53    10.010895747     0  C  FN 0 [0]
     * 259,0   11       54    10.010896213     0  C WFS 575480752 [0]
     */

    /* Find first EOL (nil pointer) entry			   */
    printf( "DBG[%05d]: %s(%p)\n", __LINE__, __func__, this );
    _imb_dump_cache();
    for (src=dst=0; src<MAXARRAY_IMB_ACTIVE_CACHE; src++)
    {
	printf( "DBG[%05d]: src %2d dst %2d - bgn loop\n", __LINE__, src, dst );
	if (imb_active_cache[src] == this      ) { found = -999; break; }
	if (imb_active_cache[src] == (void *) 0) 
	{ 
	    /* src is at EOL */
	    found = dst; 
	    if (dst != src)
            {
	        imb_active_cache[dst++] = imb_active_cache[src];
	        printf( "DBG[%05d]: src %2d dst %2d - src -> dst, compress\n", __LINE__, src, dst );
	        while (dst <  src) imb_active_cache[dst++] = NULL;
	        printf( "DBG[%05d]: src %2d dst %2d -       hole  compressed\n", __LINE__, src, dst );
		_imb_dump_cache();
	    }
	    printf( "DBG[%05d]: src %2d dst %2d\n", __LINE__, src, dst );
	    break; 
	}

	if (imb_active_cache[src] == (void *)-1) 
	{
	    /* src is at freed entry, continue */
	    printf( "DBG[%05d]: src %2d dst %2d - src free, continue\n", __LINE__, src, dst );
	    continue;
	}

	/* src entry in use, compress list if needed */
	if (src != dst)
	{
	    printf( "DBG[%05d]: src %2d dst %2d - src in use, compress\n", __LINE__, src, dst );
	    imb_active_cache[dst++] = imb_active_cache[src];
	    imb_active_cache[src  ] = (void *)-1;
	}
	else
	    dst++;
    }
    printf( "DBG[%05d]: src %2d dst %2d - end(%2d)\n", __LINE__, src, dst, found);
    imb_active_freed = 0;		        /* all freed entries removed via list compression */
    if (found != -1)
    {
	if (found != -999)
	{
            imb_active_cache[found] = this;
            imb_active_adds++;			/* number of IMB encountered                      */
            imb_active_inuse++;			/* number of IMB currently in cache list	  */
            if (imb_active_inuse > imb_active_maxdepth) imb_active_maxdepth = imb_active_inuse;
	}
	else
	    printf( "%%I[%05d]-%s(%p) already present within imb_active_cache[] list (not added again)!\n", __LINE__, __func__, this );
        _imb_dump_cache();
    }
    else
    {
	printf( "%%F[%05d]-%s() found imb_active_cache[%d] list allocated size too small for nested IMBs present.\n", __LINE__, __func__, MAXARRAY_IMB_ACTIVE_CACHE );
        _imb_dump_cache();
	exit(-1);
    }
    _assert( (found != -1) );
    return(0);

#ifdef NEVER
    if (found == -1)
    {
	/* If no free entries, loose the oldest active one in index[0] */
	if (free == 0) {imb_active_cache[0] = (void *)-1; _imb_dump_cache(); }
        for (src=dst=0; src<MAXARRAY_IMB_ACTIVE_CACHE; src++)
        {
	    if (imb_active_cache[src] == (void *) 0) { found = src; break; }
	    if (imb_active_cache[dst] == (void *)-1)
	    {
	        if (src == dst) continue;
		imb_active_cache[dst++] = imb_active_cache[src];
		imb_active_cache[src  ] = (void *)-1;
	    }
	}
        for (ndx=0; ndx<MAXARRAY_IMB_ACTIVE_CACHE; ndx++)
        {
	    if (imb_active_cache[ndx] == (void *) 0) { found = ndx; break; }
        }
    }
    _imb_dump_cache();
    return(0);
#endif
}
/*
 * Search for the specified io context pointer within the IMB lookaside cache
 * and remove (free) that cache entry.  A freed entry is set to -1.  The end
 * of list is set to nil (0) pointer.  If the entry to be freed is followed
 * by end-of-list entry, then set to nil (new end of list) instead.  This is
 * expected behavior as nesting, or having multiple/simultaneous outstanding 
 * write barriers present is less likely scenario.
 *
 */
int imb_active_rem(typ_io *this)
{
typ_io *tmp;
int ndx;
int freed = 0;

#ifndef TEST
    if (this->imbtyp == 0) /* cannot be on imb active, return */ return(0);
#endif

    printf( "DBG[%05d]: %s(%p) called from move_postio_to_done()\n", __LINE__, __func__, this );
    printf( "DBG[%05d]: %s(%p)\n", __LINE__, __func__, this );
    _imb_dump_cache();
    for (ndx=0; ndx<MAXARRAY_IMB_ACTIVE_CACHE; ndx++)
    {
        tmp = imb_active_cache[ndx];
	if (tmp == (void *) 0 ) /* end of list */ break;
	if (tmp == (void *)-1 ) /* skip, freed */ continue;
	if (tmp == this)
	{
	    freed++;
	    --imb_active_inuse;
	    if (imb_active_cache[ndx+1] != (void *)NULL)
	    {
	        imb_active_cache[ndx] = (void *)-1;   /* mark as freed           */
		imb_active_freed++;                   /* number of freed entries */
	    }
	    else
		imb_active_cache[ndx] = (void *)NULL; /* mark as new end-of-list */
	    _assert((imb_active_inuse >= 0));
	}
    }
    if (freed == 0) printf( "%%I[%05d]-%s(%p), cache entry not found, not freed.\n", __LINE__, __func__, this );
    _imb_dump_cache();
    return(0);
}
/*
 * Check to see if an io context matching this event's sector,length
 * info is on the imb acive cache list.
 *
 */
typ_io *imb_active_find(typ_event *this)
{
int     ndx;
int     oneact;
int     qualified;
typ_io *io = NULL;
typ_io *tmp= NULL;

    /* Search whole list for last match that does not have this event type (A,Q,G,...) already present in the io */
    /* and this io has matching sector info, even if a kinda fuzzy match is needed (aka treating sector of 0 as  */
    /* a wildcard match, if needed). Barriers should only have 1 event type in the io context			 */

    printf( "DBG[%05d]: %s(%p)\n", __LINE__, __func__, this );
    _imb_dump_cache();
    /* Pass 1 - an "exact" match									         */
    for (ndx=0; ndx<MAXARRAY_IMB_ACTIVE_CACHE; ndx++)
    {
	tmp = imb_active_cache[ndx];

	if (tmp == (void *) 0 ) /* end of list */ break;		/* process all until EOL reached	     */
	if (tmp == (void *)-1 ) /* skip, freed */ continue;		/* skip any used but freed entries	     */

	qualified = 0;							/* validate that the event action is allowed */
	oneact    = 0;                                                  /* for this io context                       */
        switch (this->prmact)                                           /* event primary action code                 */
        {
            case 'A' : if ((tmp->event_mask & EVTMSK_A) == 0) qualified++; qualified++; break; /* allow one or more A events      */
            case 'Q' : if ((tmp->event_mask & EVTMSK_Q) == 0) qualified++; oneact++;    break; /* allow just 1 Q event            */
            case 'M' : if ((tmp->event_mask & EVTMSK_M) == 0) /*invalid*/;              break; /* no merges allowed on IMBs       *//* no length to merge		 */
            case 'F' : if ((tmp->event_mask & EVTMSK_F) == 0) /*invalid*/;              break; /* "  "                            */
            case 'X' : if ((tmp->event_mask & EVTMSK_X) == 0) /*invalid*/;              break; /* no splits allowed on IMBs       *//* no length to split! 		 */
            case 'S' : if ((tmp->event_mask & EVTMSK_S) == 0) qualified++; qualified++; break; /* allow one or more S events      *//* may be needed to for Getrequest() */
            case 'G' : if ((tmp->event_mask & EVTMSK_G) == 0) qualified++; oneact++;    break; /* allow just 1 G event            */
            case 'I' : if ((tmp->event_mask & EVTMSK_I) == 0) qualified++; oneact++;    break; /* allow just 1 I event (no RID)   */
            case 'D' : if ((tmp->event_mask & EVTMSK_D) == 0) qualified++; oneact++;    break; /* allow just 1 D event (no RID)   */
            case 'R' : if ((tmp->event_mask & EVTMSK_R) == 0) /*invalid*/;              break; /* no requeues allowed on IMBs     *//* they really aren't dispatched to storage */
            case 'C' : if ((tmp->event_mask & EVTMSK_C) == 0) qualified++; qualified++; break; /* allow one or more C events      *//* but only one of each xx plus Sx|S0 types */

	    default  : /* anything else (N,P,U,T,Q,@.m.-) are  invalid*/; break; 
        }
	if (qualified == 0) { printf( "DBG[%05d]: %p not qualified for '%c', event_mask %016lX\n", __LINE__, tmp, this->prmact, tmp->event_mask ); continue; }

	printf( "DBG[%05d]: %s(pass 1, event '%c' qualified\n", __LINE__, __func__, this->prmact );
	printf( "DBG[%05d]: %s(io  %p ibmtyp %d sector %d:%12d length %d:%6d\n", __LINE__, __func__, tmp,
	    tmp->imbtyp, ((tmp->evtflags & EVTFLG_VALID_SECTOR) == 0)?0:1, tmp->sector,
	                 ((tmp->evtflags & EVTFLG_VALID_LENGTH) == 0)?0:1, tmp->length ); 
	printf( "DBG[%05d]: %s(evt %p ibmtyp %d sector %d:%12d length %d:%6d\n", __LINE__, __func__, this,
	    this->imbtyp, ((this->evtflags & EVTFLG_VALID_SECTOR) == 0)?0:1, this->sector,
	                  ((this->evtflags & EVTFLG_VALID_LENGTH) == 0)?0:1, this->length ); 

        switch (this->imbtyp)
        {
            case IMBTYP_xx  :  /* no   sector, no   length                                                       */ 
		               /* this event has neither sector (nor length) to verify against, do nothing atm   */
		               /* Example:
      				* S0    259,0   11       49    10.010404464  1889  A FWFS 575480752 + 0 <- (253,3) 407706544
      				* xx >> 259,0   11       50    10.010404572  1889  Q FWFS [jbd2/dm-4-8]
      				* xx >> 259,0   11       51    10.010405867  1889  G FWFS [jbd2/dm-4-8]
      				* xx >> 259,0   11       52    10.010410793   612  D  FN [kworker/11:1H]
      				* Ox    259,0   11       53    10.010895747     0  C  FN 0 [0]
      				* Sx    259,0   11       54    10.010896213     0  C WFS 575480752 [0]
      				*/
		    	       /* if Q,G,I,D and none are currently present, then allow a match			 */
		    	       if (oneact != 0)
			       {
			           io = tmp;

			           /* This is optional, but lets try and validate our understanding/expectations for */
			           /* the state machine and io event flow for IMBs 				     */
			           /* (1) its expected that this is a 'W'rite and 'S'ync as a minimum                */
			           if ( (tmp->iomask & (IOMASK_WRITE | IOMASK_SYNC)) != (IOMASK_WRITE | IOMASK_SYNC))
			           {
				       printf( "DBG[%05d]: tmp->iomask %016lX (WRITE:%016lX, SYNC:%016lX)\n", __LINE__, tmp->iomask, IOMASK_WRITE, IOMASK_SYNC );
				       printf( " %%E[%05d]-IMB io context of '%s' matching to event of '%s', event expected to include W+S as minimum??!!\n", __LINE__,
						   tmp->evttyp, this->evttyp );
			           }
			       }

			       switch (this->prmact)                                           
        		       {
            			   case 'A' : 
            			   case 'Q' : 
            			   case 'G' : 
                                   /* This is optional, but lets try and validate our understanding/expectations for */
                                   /* the state machine and io event flow for IMBs                                   */
                                   /* (1) its expected that this is a 'W'rite and 'S'ync as a minimum                */
                                   if ( (tmp->iomask & (IOMASK_WRITE | IOMASK_SYNC)) != (IOMASK_WRITE | IOMASK_SYNC))
                                   {
				       printf( "DBG[%05d]: tmp->iomask %016lX (WRITE:%016lX, SYNC:%016lX)\n", __LINE__, tmp->iomask, IOMASK_WRITE, IOMASK_SYNC );
                                       printf( " %%E[%05d]-IMB io context of '%s' matching to event of '%s' in '%s', event expected to include W+S as minimum??!!\n", __LINE__,
                                                   tmp->evttyp, this->evttyp, this->evtact );
                                   }
				   /* @@@TBD would be useful to track the IMB type here so that later A/Q/G testing applied/found/expected same or different io flow */
				   break;

            			   case 'D' : /* Allow D FN IMBTYP_xx only */
            			   case 'C' : /* This might not happen for 'C' as the examples recently seen are not IMBTYP_xx but IMBTYP_0x|IMBTYP_Sx formats */
				   if ( (tmp->iomask & (IOMASK_WRITE | IOMASK_SYNC)) != (IOMASK_WRITE | IOMASK_SYNC))
                                   {
				       
				       printf( "DBG[%05d]: tmp->iomask %016lX (WRITE:%016lX, SYNC:%016lX)\n", __LINE__, tmp->iomask, IOMASK_WRITE, IOMASK_SYNC );
                                       printf( " %%E[%05d]-IMB io context of '%s' matching to event of '%s' in '%s', event expected to include W+S as minimum??!!\n", __LINE__,
                                                   tmp->evttyp, this->evttyp, this->evtact );
                                   }
				   /* @@@TBD would be useful to track the IMB type here so that later A/Q/G testing applied/found/expected same or different io flow */
				   break;

				   case 'I': printf( " %%F[%05d]-logic fault, not expecting 'I'nsert events in IMBs?\n", __LINE__ ); exit(-1);
				       

            			   case 'M' :
            			   case 'F' :
            			   case 'X' :
            			   case 'S' :
            			   case 'R' : 
            			   default  : /* anything else (N,P,U,T,Q,@.m.-) are  invalid, and should not lead us here */; 
					      printf( " %%F[%05d]-logic fault, disqualifying '%c' event found in IMBs?\n", __LINE__, this->prmact ); exit(-1);
        		       }
		               break;

            case IMBTYP_0x  :  /* ==0  sector, no   length                                                       */ 
		               /* Example:
      				* S0    259,0   11       49    10.010404464  1889  A FWFS 575480752 + 0 <- (253,3) 407706544
      				* xx    259,0   11       50    10.010404572  1889  Q FWFS [jbd2/dm-4-8]
      				* xx    259,0   11       51    10.010405867  1889  G FWFS [jbd2/dm-4-8]
      				* xx    259,0   11       52    10.010410793   612  D  FN [kworker/11:1H]
      				* Ox >> 259,0   11       53    10.010895747     0  C  FN 0 [0]
      				* Sx    259,0   11       54    10.010896213     0  C WFS 575480752 [0]
      				*/
			       /* while this *might* signal that the io had A|Q of non-zero sector, and this is  */
			       /* just a placeholder 0, only allow *exact* matching of explicit sector length of */
			       /* zero present within the imb io                                                 */
			       if ((tmp->evtflags & EVTFLG_VALID_SECTOR) == 0) break;
			       if ( tmp->sector                          != 0) break;
			       io = tmp;
			       /* @@@TBD, this should in theory be the 1st 'C'ompletion event... check/valid?    */
			       break;

            case IMBTYP_00  :  /* ==0  sector, ==0  length                                                       */
		               /* Example:
      				* S0    259,0   11       49    10.010404464  1889  A FWFS 575480752 + 0 <- (253,3) 407706544
      				* xx    259,0   11       50    10.010404572  1889  Q FWFS [jbd2/dm-4-8]
      				* xx    259,0   11       51    10.010405867  1889  G FWFS [jbd2/dm-4-8]
      				* xx    259,0   11       52    10.010410793   612  D  FN [kworker/11:1H]
      				* Ox    259,0   11       53    10.010895747     0  C  FN 0 [0]
      				* Sx    259,0   11       54    10.010896213     0  C WFS 575480752 [0]
      				*/
			       if ((tmp->evtflags & EVTFLG_VALID_SECTOR) == 0) break;
			       if ( tmp->sector                          != 0) break;
			       if ((tmp->evtflags & EVTFLG_VALID_LENGTH) == 0) break;
			       if ( tmp->length                          != 0) break;
			       io = tmp;
			       break;

            case IMBTYP_S0  :  /* > 0  sector, zero length                                                       */
		               /* Example:
      				* S0 >> 259,0   11       49    10.010404464  1889  A FWFS 575480752 + 0 <- (253,3) 407706544
      				* xx    259,0   11       50    10.010404572  1889  Q FWFS [jbd2/dm-4-8]
      				* xx    259,0   11       51    10.010405867  1889  G FWFS [jbd2/dm-4-8]
      				* xx    259,0   11       52    10.010410793   612  D  FN [kworker/11:1H]
      				* Ox    259,0   11       53    10.010895747     0  C  FN 0 [0]
      				* Sx    259,0   11       54    10.010896213     0  C WFS 575480752 [0]
      				*/
			       if ((tmp->evtflags & EVTFLG_VALID_SECTOR) == 0) break;
			       if ( tmp->sector                          != this->sector) break;
			       if ((tmp->evtflags & EVTFLG_VALID_LENGTH) == 0) break;
			       if ( tmp->length                          != 0) break;
			       io = tmp;
			       /* @@@TBD this can only happen if the io context via previous A happened and this is */
			       /* @@@TBD 2nd remap.  As such, we should verify the chain of remaps, that is the     */
			       /* @@@TBD prior remap was sector x -> y and so this remap should be y -> z and check */
			       /* @@@TBD of the 'y' in prior remap matches the 'y' in this remap.                   */
			       /* @@@TBD Although, that should not happen right?  As a 2nd remap of S0 type should  */
			       /* @@@TBD already have been matched to the prior io context as needed and so never   */
			       /* @@@TBD get here?                                                                  */
			       break;

            case IMBTYP_Sx  :  /* > 0  sector, no   length                                                       */ 
		               /* Example:
      				* S0    259,0   11       49    10.010404464  1889  A FWFS 575480752 + 0 <- (253,3) 407706544
      				* xx    259,0   11       50    10.010404572  1889  Q FWFS [jbd2/dm-4-8]
      				* xx    259,0   11       51    10.010405867  1889  G FWFS [jbd2/dm-4-8]
      				* xx    259,0   11       52    10.010410793   612  D  FN [kworker/11:1H]
      				* Ox    259,0   11       53    10.010895747     0  C  FN 0 [0]
      				* Sx >> 259,0   11       54    10.010896213     0  C WFS 575480752 [0]
      				*/
			       if ((tmp->evtflags & EVTFLG_VALID_SECTOR) == 0) break;
			       if ( tmp->sector                          != this->sector) break;
			       io = tmp;
			       break;

            case IMBTYP_NONE:  /* not an implicit barrier                                                        */ 
            default         :  /* leave io as null and return						     	 */
		               break;
        }
	if (io != NULL) { printf( "DBG[%05d]: %s(%p matched!)\n", __LINE__, __func__, io ); /* ...but we want last match so */ continue; }
    }

    if (io != NULL) { imb_active_crossmatch(this,io); return(io); }

    /* Pass 2 - allow a "fuzzy" match, e.g. 0 in event matching exact non-zero sector	*/
    /*          note: this is trickier in that, while it happens in the event stream,   */
    /*                this will match on close-enough which might be not really the     */
    /*                correct context.  This is more about qualifying the current event */
    /*                as being part of an implicit barrier vs strong matching to an     */
    /*                active imb context.  The (meh) assumption is that there are so few*/
    /*                imb active that we should allow an event imb match via "fuzzy"    */
    /*                match vs skipping the event entirely.  Let real data end up being */
    /*                the guide on this and how best to craft it so there are few if any*/
    /*                mismatches detected and returned.                                 */
    for (ndx=0; ndx<MAXARRAY_IMB_ACTIVE_CACHE; ndx++)
    {
	tmp = imb_active_cache[ndx];

	if (tmp == (void *) 0 ) /* end of list */ break;
	if (tmp == (void *)-1 ) /* skip, freed */ continue;

	qualified = 0;                                                  /* validate that the event action is allowed */
        oneact    = 0;                                                  /* for this io context                       */
        switch (this->prmact)                                           /* primary action code                       */
        {
            case 'A' : if ((tmp->event_mask & EVTNDX_A) == 0) qualified++; qualified++; break; /* allow one or more A events      */
            case 'Q' : if ((tmp->event_mask & EVTNDX_Q) == 0) qualified++; oneact++;    break; /* allow just 1 Q event            */
            case 'M' : if ((tmp->event_mask & EVTNDX_M) == 0) /*invalid*/;              break; /* no merges allowed on IMBs       *//* no length to merge                */
            case 'F' : if ((tmp->event_mask & EVTNDX_F) == 0) /*invalid*/;              break; /* "  "                            */
            case 'X' : if ((tmp->event_mask & EVTNDX_X) == 0) /*invalid*/;              break; /* no splits allowed on IMBs       *//* no length to split!               */
            case 'S' : if ((tmp->event_mask & EVTNDX_S) == 0) qualified++; qualified++; break; /* allow one or more S events      *//* may be needed to for Getrequest() */
            case 'G' : if ((tmp->event_mask & EVTNDX_G) == 0) qualified++; oneact++;    break; /* allow just 1 G event            */
            case 'I' : if ((tmp->event_mask & EVTNDX_I) == 0) qualified++; oneact++;    break; /* allow just 1 I event (no RID)   */
            case 'D' : if ((tmp->event_mask & EVTNDX_D) == 0) qualified++; oneact++;    break; /* allow just 1 D event (no RID)   */
            case 'R' : if ((tmp->event_mask & EVTNDX_R) == 0) /*invalid*/;              break; /* no requeues allowed on IMBs     *//* they really aren't dispatched to storage */
            case 'C' : if ((tmp->event_mask & EVTNDX_C) == 0) qualified++; qualified++; break; /* allow one or more C events      *//* but only one of each xx plus Sx|S0 types */

            default  : /* anything else (N,P,U,T,Q,@.m.-) are  invalid*/; break;
        }
	if (qualified == 0) continue;

	printf( "DBG[%05d]: %s(pass 2, event '%c' qualified\n", __LINE__, __func__, this->prmact );
	printf( "DBG[%05d]: %s(io  %p ibmtyp %d sector %d:%12d length %d:%6d\n", __LINE__, __func__, tmp,
	    tmp->imbtyp, ((tmp->evtflags & EVTFLG_VALID_SECTOR) == 0)?0:1, tmp->sector,
	                ((tmp->evtflags & EVTFLG_VALID_LENGTH) == 0)?0:1, tmp->length );
	printf( "DBG[%05d]: %s(evt %p ibmtyp %d sector %d:%12d length %d:%6d\n", __LINE__, __func__, this,
	    this->imbtyp, ((this->evtflags & EVTFLG_VALID_SECTOR) == 0)?0:1, this->sector,
	                  ((this->evtflags & EVTFLG_VALID_LENGTH) == 0)?0:1, this->length );


        switch (this->imbtyp)
        {
            case IMBTYP_xx  :  /* no   sector, no   length                                                       */ 
		               /* this event has neither sector (nor length) to verify against, do nothing atm   */
		               /* Example:
      				* S0    259,0   11       49    10.010404464  1889  A FWFS 575480752 + 0 <- (253,3) 407706544
      				* xx >> 259,0   11       50    10.010404572  1889  Q FWFS [jbd2/dm-4-8]
      				* xx >> 259,0   11       51    10.010405867  1889  G FWFS [jbd2/dm-4-8]
      				* xx >> 259,0   11       52    10.010410793   612  D  FN [kworker/11:1H]
      				* Ox    259,0   11       53    10.010895747     0  C  FN 0 [0]
      				* Sx    259,0   11       54    10.010896213     0  C WFS 575480752 [0]
				*/
		    	       /* if Q,G,I,D and none are currently present, then allow a match			 */
		    	       if (oneact != 0)
			           io = tmp;
		               break;

            case IMBTYP_0x  :  /* ==0  sector, no   length                                                       */ 
		               /* Example:
      				* S0    259,0   11       49    10.010404464  1889  A FWFS 575480752 + 0 <- (253,3) 407706544
      				* xx    259,0   11       50    10.010404572  1889  Q FWFS [jbd2/dm-4-8]
      				* xx    259,0   11       51    10.010405867  1889  G FWFS [jbd2/dm-4-8]
      				* xx    259,0   11       52    10.010410793   612  D  FN [kworker/11:1H]
      				* Ox >> 259,0   11       53    10.010895747     0  C  FN 0 [0]
      				* Sx    259,0   11       54    10.010896213     0  C WFS 575480752 [0]
      				*/
			       /* while this *might* signal that the io had A|Q of non-zero sector, and this is  */
			       /* just a placeholder 0, only allow matching of sector length of zero present     */
			       /* within the imb io                                                              */
			       if ((tmp->evtflags & EVTFLG_VALID_SECTOR) == 0) break;
			       if ( tmp->sector                          != 0) break;
			       io = tmp;
			       break;

            case IMBTYP_00  :  /* ==0  sector, ==0  length                                                       */
		               /* Example:
      				* S0    259,0   11       49    10.010404464  1889  A FWFS 575480752 + 0 <- (253,3) 407706544
      				* xx    259,0   11       50    10.010404572  1889  Q FWFS [jbd2/dm-4-8]
      				* xx    259,0   11       51    10.010405867  1889  G FWFS [jbd2/dm-4-8]
      				* xx    259,0   11       52    10.010410793   612  D  FN [kworker/11:1H]
      				* Ox    259,0   11       53    10.010895747     0  C  FN 0 [0]
      				* Sx    259,0   11       54    10.010896213     0  C WFS 575480752 [0]
      				*/
			       if ((tmp->evtflags & EVTFLG_VALID_SECTOR) == 0) break;
			       if ( tmp->sector                          != 0) break;
			       if ((tmp->evtflags & EVTFLG_VALID_LENGTH) == 0) break;
			       if ( tmp->length                          != 0) break;
			       io = tmp;
			       break;

            case IMBTYP_S0  :  /* > 0  sector, zero length                                                       */
		               /* Example:
      				* S0 >> 259,0   11       49    10.010404464  1889  A FWFS 575480752 + 0 <- (253,3) 407706544
      				* xx    259,0   11       50    10.010404572  1889  Q FWFS [jbd2/dm-4-8]
      				* xx    259,0   11       51    10.010405867  1889  G FWFS [jbd2/dm-4-8]
      				* xx    259,0   11       52    10.010410793   612  D  FN [kworker/11:1H]
      				* Ox    259,0   11       53    10.010895747     0  C  FN 0 [0]
      				* Sx    259,0   11       54    10.010896213     0  C WFS 575480752 [0]
      				*/
			       if ((tmp->evtflags & EVTFLG_VALID_SECTOR) == 0) break;
			       if ( tmp->sector                          != this->sector) break;
			       if ((tmp->evtflags & EVTFLG_VALID_LENGTH) == 0) break;
			       if ( tmp->length                          != 0) break;
			       io = tmp;
			       break;

            case IMBTYP_Sx  :  /* > 0  sector, no   length                                                       */ break;
		               /* Example:
      				* S0    259,0   11       49    10.010404464  1889  A FWFS 575480752 + 0 <- (253,3) 407706544
      				* xx    259,0   11       50    10.010404572  1889  Q FWFS [jbd2/dm-4-8]
      				* xx    259,0   11       51    10.010405867  1889  G FWFS [jbd2/dm-4-8]
      				* xx    259,0   11       52    10.010410793   612  D  FN [kworker/11:1H]
      				* Ox    259,0   11       53    10.010895747     0  C  FN 0 [0]
      				* Sx >> 259,0   11       54    10.010896213     0  C WFS 575480752 [0]
      				*/
			       if ((tmp->evtflags & EVTFLG_VALID_SECTOR) == 0) break;
			       if ( tmp->sector                          != this->sector) break;
			       io = tmp;
			       break;

            case IMBTYP_NONE:  /* not an implicit barrier                                                        */ 
            default         :  /* leave io as null and return						     */
		               break;
        }
	if (io != NULL) { printf( "DBG[%05d]: %s(%p matched!)\n", __LINE__, __func__, io ); /* ...but we want last match so */ continue; }
    }
    if (io != NULL) imb_active_crossmatch(this,io);
    return(io);
}
int imb_active_crossmatch(typ_event *event, typ_io *io)
{
    return(0);
}

int _imb_dump_cache()
{
int ndx;

    printf( "DBG[%05d]: imb active cache list (inuse=%2d freed=%2d max=%2d adds=%d)\n", __LINE__, 
		    imb_active_inuse, imb_active_freed, imb_active_maxdepth, imb_active_adds );
    for (ndx=0; ndx<MAXARRAY_IMB_ACTIVE_CACHE; ndx++)
    {
#ifndef TEST
        printf( "DBG[%05d]: cache[%2d] = %p imbtyp %d\n", __LINE__, ndx, imb_active_cache[ndx], 
		(imb_active_cache[ndx] == NULL)?-1:((imb_active_cache[ndx] == (void *)-1)?-2:imb_active_cache[ndx]->imbtyp) );
#else
        printf( "DBG[%05d]: cache[%2d] = %p\n", __LINE__, ndx, imb_active_cache[ndx] );
#endif
	if (imb_active_cache[ndx] == (void *) 0) break;
    }
    return(0);
}


/* @@@EOF@@@ */



/* =============================================================== */
/* =============================================================== */
/* === NOTES ===================================================== */
/* =============================================================== */
/* =============================================================== */


/*
 * 11/08/2020
 *
 

DBG[04240]: staged            0xcaf6990[14190] ->    0xcaf87a0    8,  6  52.02888842 'A'    FWS A..........,01 3:               0,     0 000084
DBG[04240]: staged            0xcaf87a0[14191] ->    0xcafd9a0    8,  6  52.02947897 'A'    FWS A..........,01 3:               0,     0 000084
DBG[04240]: staged            0xcafd9a0[14192] ->    0xcaff7b0    8,  6  52.03154274 'A'    FWS A..........,01 3:               0,     0 000084
DBG[04240]: staged            0xcaff7b0[14193] ->    0xcb02460    8,  6  52.03262594 'A'    FWS A..........,01 3:               0,     0 000084
DBG[04240]: staged            0xcb02460[14194] ->    0xcb031f0    8,  6  52.03715772 'A'    FWS A..........,01 3:               0,     0 000084
DBG[04240]: staged            0xcb031f0[14195] ->    0xcb05000    8,  3  52.03732623 'A'    FWS A..........,01 3:               0,     0 000084
DBG[04240]: staged            0xcb05000[14196] ->    0xcb06ff0    8,  6  52.03784938 'A'    FWS A..........,01 3:               0,     0 000084

After the addition of the expanded duplicate io checks across both staged/mainio lists, barrier
code matching is broken.  At the end we can see the staged queue has accumulated the start of all
the barrier io but none are getting the later QGIC events as it was earlier.  The barrier search
code seems to be bypass for some reason.  

Events are parsed via parse_event() which builds the typ_event structure.  As part of that parsing, it flags 
the event with a SPCFLG_00 flag if it looks like a barrier event. (FWS:0:0 match).

Then the event specific routine for event->prmtyp is called.  For example:

getreq_event()
    -> if all three pieces of needed info present, search of staged list happens, otherwise
       missing data means exceptionevent() called.  The exception event is both tagged further
       as EVTFLG_EXCEPTION and output to the *exceptions file. This used to mean the event was
       discarded -- now it just means its "exception": something odd about the event that could
       result in discard action or rescue via special corner case code checks.  
  
    >> so in the case of a barrier AQGIC with QGIC having no sector:length, the code above goes
       through the excecptionevent() rather than search_staged1() -- the primary search for
       match/staged list code.

Then a search of mainio is applied to pick up normal cases of AQSGI... where the Sleep moved
the staged io to the mainio/active request queue.

    if ((io == NULL) && (nonio == 0))
        io = search_mainio1(this,io,eventname,&onmain);

And again, this is nominal case of staged search failed and we didn't go through the
exceptions code.  Its unclear why I placed this *outside* of the orginal valid event
clause -- what I mean is I valid that the event has sufficient information to be used
is search_staged/search_mainio functions and call search_staged inside of that "event
is valid"... but then call search_mainio1() outside of that validation?  Why? Was that
deliberate?  Otherwise moving the 2nd search of the mainio inside of the valid=3 ("event
is valid, has enough info to use as matching criteria" would seem like the thing to do.
Having it oustide of event validation means we can be calling the search_mainio1() with
non-validated events.  Previously this was prevented via the nonio==0 because nonio is
set to 1 in the exceptions (non valid) clause.  So, moving search_mainio1() into the
valid clause right after search_staged1() and dropping the check for nonio would be
equivalent to where that clause was originally placed.  

And this is where things changed.  Previously, after above, 

    /- If no match and special is set, give a second special look -/
    if ((io == NULL) && ((this->specials & SPCFLG_00) != 0))
        io = search_staged_special1(this,eventname,__LINE__);

    So io was null because it went through the exceptionevent() because it didn't have a 
    valid sector:length in the event string.  The event has the SPCFLG_00 set because of
    that and the io type if FWS (its not 'N' would be more general case but I kept the
    match criteria as narrow as possible).  So gets here and calls the search_staged_special1()
    code to see if it can find a match using "barrier" match criteria.

    And if it still doesn't find a match goes the discard route.

This changed, apparently, when we added a 2nd search: a search of mainio here:
>> as discussed above, the first two lines were already present before the latest
>> duplicate io corner case code flow added.  However, those two lines were 
>> effectively right after the search_staged1().  That is the nonio==0 is surrogate
>> for valid=3 "event is valid for normal matching".

    if ((io == NULL) && (nonio == 0))
        io = search_mainio1(this,io,eventname,&onmain);
>> and this is what we added. So while above will not attempt a mainio search
>> for invalid events (ones missing sector:length in barrier case), this following
>> code will.  The assumption is that the staged search happened and now we need
>> to check the mainio1 for a duplicate match.  Still, io should be null at this
>> point; we skipped staged search because event is "invalid" in AQGIC barrier case.
>> and nonio was set to 1 so we skipped above came here and found io == null, so 
>> this clause too should be skipped and then the "normal" abnormal special case
>> barrier search should be performed.  But somehow it wasn't.  Still all this
>> code really belongs in the mainline valid=3 clause.  The checks being done
>> should affectively result in the same code path being executed whether this
>> code is inside or outside the valid=3 given the other parts of 'if' like
>> nonio==0 act as surrogate to put this code inside the valid=3 in a virtual
>> sense even though the code is not physically written that way.  Bottom line:
>> lets move the search_mainio1() into the valid clause where it belongs.  Align
>> virtual and physical placements.

    else if ((io != NULL) && (state.event_count_sleep != 0))
    {
        /- special case, we need to look for best io on mainio list and -/
        /- then compare it to the best one found on the staged list     -/
        /- due to a prior sleep, a dupe io needing a G may be sitting on-/
        /- the active list so go look...                                -/
        best_staged = io;
        best_mainio = search_mainio1(this,io,eventname,&onmain);
        if (best_mainio == best_staged)
        {
            /- the above didn't find a (better) match, returned same ptr-/
            /- avoid sending in two pointers to best_match() same/same  -/
            io = best_staged;
        }
        else
        {
            if ((io = best_match(this,best_staged,best_mainio)) == NULL) io = best_staged;
            if (io == best_mainio) onmain=1;
        }
    }

>> So I still don't see how barrier special case matching was broken/skipped.  After above
>> and neither search_mainio1() being called, it should drop to the following existing
>> barrier search special case and do the right thing.  This code is triggered via io==null
>> which is the only thing that could possibly have changed to skip this function.  The
>> event flag is baked into the event and none of the code should be removing any flags --
>> at best it might add one or more, but should not be changing event data otherwise.
>> the event data is a reference copy of the string event and that string isn't changing,
>> just our perception of what it represents.

    /- If no match and special is set, give a second special look -/
    if ((io == NULL) && ((this->specials & SPCFLG_00) != 0))
        io = search_staged_special1(this,eventname,__LINE__);

Time to look at -ddd output, ugh! This should be simple to see how I broke it with
the new duplicate corner case code!

*/

/* 11/08/2020
 *

There was a kmf also introduced in with the new check for duplicates logic somewhere.  Will also
use the debug compile version to track that down first.  Then -ddd output to track down how the
barrier special search code is bypassed or otherwise broken with the addition of the expanded
duplicate io checks across staged + mainio lists.

Ok, the core dump is a cut/paste issue in a printf.  It output 'best' instead of 'temp' in the
case where both io are disqualified.  Checking input args io and temp are valid, so cut/paste
of the printf in this case is cause of kmf.  the best pointer is null in cases where neither
io qualify for use. Fixed.


*/

/*
 * 11/08/2020
 *

Fixed cut/paste that was causing kmf and now the its processing to the end.  It wasn't before,
or at least wasn't on one of the data sets in case *902.  Time to do a full re-run in this case
and see what happens.

*/

        

/* 11/09/2020
 *

#
#  Per IO
#  Transfer     #IO
#  Sectors        count Q2I       Total        Avg         Q2D       Total        Avg         Q2C       Total        Avg                'Size'
#    0 -    7     21340 Q2I:      0.040369767/ 0.000001892 Q2D:      0.053871148/ 0.000002524 Q2C:      3.866356027/ 0.000181179   19.7% Subpage (    <   1 4k page )
#    8 -   31     42841 Q2I:      0.131366455/ 0.000003066 Q2D:      0.174457427/ 0.000004072 Q2C:     21.846741436/ 0.000509949   39.6% Small   (  1 -   3 4k pages)
#   32 -   71       478 Q2I:      0.006680459/ 0.000013976 Q2D:      0.008635828/ 0.000018067 Q2C:      0.556630587/ 0.001164499    0.4% Medium  (  4 -   8 4k pages)
#   72 -  263       235 Q2I:      0.001385513/ 0.000005896 Q2D:      0.001659938/ 0.000007064 Q2C:      0.186555944/ 0.000793855    0.2% Large   (  9 -  32 4k pages)
#  264 - 1031       314 Q2I:      0.006358536/ 0.000020250 Q2D:      0.006473245/ 0.000020615 Q2C:      5.878798615/ 0.018722289    0.3% Jumbo   ( 33 - 128 4k pages)
#      > 1031         0 Q2I:      0.000000000/ 0.000000000 Q2D:      0.000000000/ 0.000000000 Q2C:      0.000000000/ 0.000000000    0.0% Xtra    (    > 128 4k pages)
#
# Subpage and Small io sizes are typically inefficient (except on high iops devices like NVMe)
# Medium io sizes are ok, but Large io size is typically the spot on the performance curve where
#        efficiency is best before it starts to flatten out again for Jumbo and Xtra sized io.
#
Total io = 108271 I/O Aligned to (   8) = 0 ( 0.000000000%) [-aNNN; align check off]

So total_io = 108,271 but the sum of bucket counts doesn't match that!

Doesn't add up to 100%, is this because BARRIERS bumped io count but never bumped a bucket?  I mean A in AQGIC for barriers shouldn't trigger event
count -- that should only be done at io complete time.

check it out. find the bug.  Think I found it, state.total_io was updated outside the !BARRIER, !GHOST clause so was being updated for those io
events when it should not have been.

*/

/*
 * 11/12/2020 customer case dataset provided for fixing merges 
 * /tmp/blktrace.testdata/blktrace.2.6.32/run-20200101-010101/sdz.blktrace.txt
 *

DBG[04215]:   9073::'CPU0 (sdz):'
DBG[04216]:   9072::'CPU0 (sdz):'
DBG[04217]: Plug   P:00000000            U:00000000 (isPlugged=-1)
DBG[04219]: SeqNo  x:00009070 Q:00001706 S:00000000 G:00001706 M:........ F:........ I:00001706 D:00001706 R:00000026 C:00000000 (inProgress=00001706, inFlight=00001706)
DBG[04222]: Events A:00000000 Q:00001706 S:00000000 G:00001706 M:00000000 F:00000000 I:00001886 D:00001886 R:00000180 C:00001706 x:00000000


Note: annotation includes these bad counts too? DTicket isn't being output and CTicket never seems to increase at all.

# Plug field : '@' Dispatch event, but isPlugged > 0?!
#            : ' ' nominal
#            : '$' IS_ORPHAN_IO     flag is set on this io
#            : '&' IS_CONFLICTED_IO flag is set on this io
#            : '#' IS_OVERLAPPED_IO flag is set on this io

So '#' before plug U0 data is saying all these io overlap other io?!?  Also header is missing 6 digit line number.

#Maj,Mn CPU    SeqNo     Seconds        PID  Evt Typ Sector   +Len Description                        ; Plug   QTicket#   DTicket#   CTicket#  Stg Prg    R    W  Dev    R    W
#------ --- -------- --------------- --------|--|---|---------+--- -----------------------------      ; ---- ---------- ---------- ----------|----|---- ---- ----|---- ---- ----
08463   65,160  8      113    12.416778248 28615  I   R 31547520 + 128 [(null)]                       ;#U0           47          0          0|   0|   1:   1,   0|   0:   0,   0|         
08627   65,160  8      114    12.416780281 28615  D   R 31547520 + 128 [(null)]                       ;#U0           47         47          0|   0|   1:   1,   0|   1:   1,   0|   0     
09317   65,160  8      115    12.417621582     0  C   R 31547520 + 128 [0]                            ;#U0           47         47          0|   0|   1:   1,   0|   0:   0,   0|   0  -47
07392   65,160  0       61    13.107309714 28621  Q   R 73950080 + 128 [(null)]                       ;#U0           48          0          0|   1|   0:   0,   0|   0:   0,   0|         
08271   65,160  0       62    13.107312244 28621  G   R 73950080 + 128 [(null)]                       ;#U0           48          0          0|   0|   1:   1,   0|   0:   0,   0|         
08463   65,160  0       63    13.107314991 28621  I   R 73950080 + 128 [(null)]                       ;#U0           48          0          0|   0|   1:   1,   0|   0:   0,   0|         
08627   65,160  0       64    13.107317087 28621  D   R 73950080 + 128 [(null)]                       ;#U0           48         48          0|   0|   1:   1,   0|   1:   1,   0|   0     
09317   65,160  0       65    13.108269891     0  C   R 73950080 + 128 [0]                            ;#U0           48         48          0|   0|   1:   1,   0|   0:   0,   0|   0  -48
07392   65,160  8      116    13.277431578 28615  Q   R 31094144 + 128 [(null)]                       ;#U0           49          0          0|   1|   0:   0,   0|   0:   0,   0|         
08271   65,160  8      117    13.277433878 28615  G   R 31094144 + 128 [(null)]                       ;#U0           49          0          0|   0|   1:   1,   0|   0:   0,   0|         
08463   65,160  8      118    13.277436402 28615  I   R 31094144 + 128 [(null)]                       ;#U0           49          0          0|   0|   1:   1,   0|   0:   0,   0|         
08627   65,160  8      119    13.277438428 28615  D   R 31094144 + 128 [(null)]                       ;#U0           49         49          0|   0|   1:   1,   0|   1:   1,   0|   0     
09317   65,160  8      120    13.278313133     0  C   R 31094144 + 128 [0]                            ;#U0           49         49          0|   0|   1:   1,   0|   0:   0,   0|   0  -49
07392   65,160 14       21    13.459482126 28610  Q   R 42405504 + 128 [(null)]                       ;#U0           50          0          0|   1|   0:   0,   0|   0:   0,   0|         
08271   65,160 14       22    13.459484423 28610  G   R 42405504 + 128 [(null)]                       ;#U0           50          0          0|   0|   1:   1,   0|   0:   0,   0| 


Note that the event count for completes show 1706 C events, but the C seqno is still zero. ... and inprog and inflight counts are never
decremented @complete time as they should be.  introduced a bug? The actual output looks ok in terms of inprog/inflight

  14: 14  94.789249723   0.0013      0.001785     14.958194 % 99     14.959979  11    28233 W     208       20384256          -768 [(null):pid not found]   0   0
  13: 13  94.789856116   0.0010      0.001360     14.505782 % 99     14.507142  11    28233 W      48       20388176          3712 [(null):pid not found]   0   0
  12: 12  94.789778261   0.0011      0.001632     14.662771 % 99     14.664403  11    28233 W      80       20388096          -128 [(null):pid not found]   0   0
  11: 11  94.790413029   0.0012      0.001513     14.867489 % 99     14.869002  11    28233 W     128       70837632      50449456 [(null):pid not found]   0   0
  10: 10  94.790461010   0.0012      0.001549     14.925473 % 99     14.927022  11    28233 W     128       71042176        204416 [(null):pid not found]   0   0
   9:  9  94.790579937   0.0013      0.001688     15.788928 % 99     15.790616  11    28233 W     256       71043072           768 [(null):pid not found]   0   0
   8:  8  94.791192252   0.0012      0.001516     17.321358 % 99     17.322874  11    28233 W     128        1697152     -69346176 [(null):pid not found]   0   0
   7:  7  94.791370855   0.0012      0.001575     18.008179 % 99     18.009754  11    28233 W     128        1699840          2560 [(null):pid not found]   0   0

Also verify these are present in the new merged output (below is old *.out file) -- specificall the requeue warning. -- This should also be present in the SUM
output.  The requeue warnings should include a second number so when greping can see that (but not in SUM, except maybe # of samples in which requeues occurred?)
Should include the later patch with D2D option activation instructions.  Note, verified that %W requeue warning is not present in merged.

...dump!
SEC: dTime(sec)           Q2I(ms)        Q2D(ms)        D2C(ms)     Q2C(ms;await) reads  avgrq      kbs writes  avgrq      kbs      seeks in-progress in-flight requeues
SEC:     70 totals        3.139373       3.237533    2682.119805    2685.357338       0      0        0    151    137    10392      20784          1         0       26
SEC:     70 tot.avg       0.020791       0.021441      17.762383      17.783823       0      0        0    151    137    10392      137
SEC:     70 max.rd        0.000000       0.000000       0.000000       0.000000
SEC:     70 max.wr        1.207743       1.219063      38.237968      39.457031
SEC: -------------------------------------------------------------------------------------------------------------------------
SEC: %W-'R'equeue events encountered (       0 reads,       26 writes), this can significantly slow down percieved storage response time!
SEC: -------------------------------------------------------------------------------------------------------------------------


Other issues:

%W[04712]-HotSpot data not saved, cannot open '' for write access.
DBG[04745]: min/max bucket 2:3015
DBG[04859]: allocated buckets counted 447
DBG[04860]: hotspot 1 segments 447 buckets
DBG[04861]: found   1 segments 443 buckets 753 reads 953 writes


DBG[03332]: config file '/username//.config/blktrace/blktrace.conf' not present.


should be /home/username/.config/blktrace/blktrace.conf !!!

TODO from above:

1) fix output of %W sleep and requeue, look in fork2 code base.  output @sec and sum times.  add summ stat for #samples with requeue and/or sleeps for mesg @summ time.
2) fix hotspot cannot open issue
3) fix CSeqNo issue. Suspect these need to be issue at C time (and not later at delayed output time)
4) fix annotation header output, include line number
5) fix DTicket/CTicket output in annotation
6) fix annotation plug field where '#' all io are overlappeing is set?
7) why is inprog inflight counts they way they are @end?

1)
    fprintf( outf, " %12ld %-22s %4d%c%3d %s\n", seek, name, event->cnt_requeues, (event->cnt_sleep)==0?' ':'S', (event->merge_count+event->completed_count), smerge );
    if (event->cnt_sleep > 1)
        fprintf( outf, "%%W[%05d]-event sleep count %d > 1!?\n", __LINE__, event->cnt_sleep );
#else

This is at event output, even though the R and S countes are in the merged output line, it also at the event, outputs warning.  This really needs to be moved
to SEC: end as summary for section vs *every* single event that has a sleep.  verify R&S counts are output in merged line like above.  Note above is used because
the merged line only has 'S' rather than a count... change?.

Noted that in generic accum dump the %W for requeues and sleeps should already be present

int accum_dump(int tbc)
{
char styp[8] = "SEC";

    accumulator_dump(&accum,styp,1);

    /- Add any alerts -/
    if (((accum.cnt_requeues_reads + accum.cnt_requeues_writes) > 0) ||
        ((accum.cnt_sleep_reads    + accum.cnt_sleep_writes)    > 0))
    {
         fprintf( outf, "#%s: --- Alert ---------------------------------------------------------------------------------------------------------------\n", styp );
         if ((accum.cnt_sleep_reads    + accum.cnt_sleep_writes)    > 0)
             fprintf( outf, " %s: %%W-'S'leep   events encountered (%8d reads, %8d writes), this can significantly slow down perceived storage response time! (@%5d secs)\n",
                styp, accum.cnt_sleep_reads,  accum.cnt_sleep_writes, (int)(accum.boundary-1.0) );
         if ((accum.cnt_requeues_reads + accum.cnt_requeues_writes) > 0)
         {
             fprintf( outf, " %s: %%W-'R'equeue events encountered (%8d reads, %8d writes), this can significantly slow down perceived storage response time! (@%5d secs)\n",
                styp, accum.cnt_requeues_reads,  accum.cnt_requeues_writes, (int)(accum.boundary-1.0));
             if (chk_use_include_d2d == 0)
             {
                 fprintf( outf, " %s: %%I-Add 'include_d2d=1' to ./blktrace.conf recommended if there are a significant number of retries present within the data!%*.*s (@%5d secs)\n",
                    styp, 9,9," ", (int)(accum.boundary-1.0) );
                 chk_use_include_d2d++;
             }
         }
         fprintf( outf, "#%s: -------------------------------------------------------------------------------------------------------------------------\n", styp );
    }
    fprintf( outf, "#\n");


Unless the accum.cnt_sleep_reads/writes and requeue counts are not being incremented.

Ditto for SUM

int summ_dump()
{
    accumulator_dump(&summ,"SUM",0);

    /- Add ALERTs, if any... -/
    if ((summ.cnt_sleep_reads + summ.cnt_sleep_writes) != 0)
        fprintf( outf, "SUM: ALERT %%W-'S'leep   events encountered (%8d reads, %8d writes), this can significantly slow down perceived storage response time!\n",
                summ.cnt_sleep_reads,  summ.cnt_sleep_writes );
    if ((summ.cnt_requeues_reads + summ.cnt_requeues_writes) > 0)
    {
        fprintf( outf, "SUM: ALERT %%W-'R'equeue events encountered (%8d reads, %8d writes), this can significantly slow down perceived storage response time!\n",
                summ.cnt_requeues_reads,  summ.cnt_requeues_writes );
        if (conf_include_d2d == 0)
            fprintf( outf, "SUM: ALERT %%I-Add 'include_d2d=1' to ./blktrace.conf recommended if there are a significant number of retries present within the data!\n");
    }
    fprintf( outf, "\n");



In requeue_event:

    --state.inFlight;           /- it *has* been returned by storage lldd               -/--...and any io 'D'ispatched takes up a lun queue slot -/
    switch (event->rw)
    {
        case IOTYP_UNKNOWN  :
        case IOTYP_OTHER    :
        case IOTYP_NONE     :
        case IOTYP_DISCARD  :
        case IOTYP_BARRIER  :
        case IOTYP_META     : break;
        case IOTYP_WRITE    : --state.inFlight_Read;  accum.cnt_requeues_writes++; summ.cnt_requeues_writes++; break;
        case IOTYP_READ     : --state.inFlight_Write; accum.cnt_requeues_reads++;  summ.cnt_requeues_reads++;  break;
        default             : break;
    }

And in sleep_event:

    /--no timestamps are altered for this event type -/
    /- no action update is performed                 -/
    event->cnt_sleep++;

    switch (event->rw)
    {
        case IOTYP_UNKNOWN  :
        case IOTYP_OTHER    :
        case IOTYP_NONE     :
        case IOTYP_DISCARD  :
        case IOTYP_BARRIER  :
        case IOTYP_META     : break;
        case IOTYP_WRITE    : accum.cnt_sleep_writes++; summ.cnt_sleep_writes++; break;
        case IOTYP_READ     : accum.cnt_sleep_reads++;  summ.cnt_sleep_reads++;  break;
        default             : break;
    }

Currently only this, but alert code uses cnt_sleep_<type> counters!


        samp.cnt_sleeps++;
        summ.cnt_sleeps++;

So fork2 only had individual type counters and no summary count (except via summing), while the
new merge code does not include individual type counts, only summary -- although the individual
type counters are present in the accumulator.  Leave the summary counter, and add back in the
code to update the individual io type counters for both sleep and requeue as they are both missing
here.



*/

/* 
 * 11/12/2020
 *

blktrace_merge: blktrace_parse.v4.c:9551: plug_event: Assertion `state.PlugCount > state.UnplugCount' failed.

The expectation is P/U events are paired except for UT events which in prior data sets brought the count down
to one as the sequence was UT,U events.  Need to revamp the whole P/U  processing to avoid assert() failures
as they are at best bad understanding in our model implmentation rather than something we need to core dump
on.

Add a mask flag in state and track the type of mismath events of 0->U sequence for example and flag them
Treat unpaired UT as special as these are plug timeout events.  And not having P events to pair with them
is odd, but ultimately a dataset issue and not a program issue.

*/



/* 
 * 12/08/2020
 *

	Sigh.  Another barrier issue, although the code should have worked -- so there is a bug somewhere.
   	We can see two barriers sitting in the staging queue, one AQ and on A.  We get a Q event which should
        be best match with the 2nd A.... io.  But it disqualified the A.... io and chose the AQ.... io for some
        reason and then when blows up and logic errors out because the one it chose already has a Q event and the
        rule is you can only have one Q event per io.  

	So issue is, why did it choose AQ or A for the new '.Q...' event?

--bgn:095750-----------------------------------------      2:       0
  8,0    1    13241    12.058192746 126042  Q FWS [db2sysc]
DBG[02791]: set EXCEPTION flag on event:  [02790]: standard format, but event missing '[ location{sector:length} ]'
DBG[07027]: staged list  0x5d9f0d0          0:     0... <= 1st hit
DBG[07028]: staged list  0x5d9f820          0:     0... <= Nth hit
DBG[07029]: continue, best_match_special1() will be used to determine which to use
DBG[06601]: staged list  0x5d9f0d0          0:     0... <= 1st hit
DBG[06602]: staged list  0x5d9f820          0:     0... <= Nth hit

DBG[04333]: dump_staged_list(2)
DBG[04334]: ===================================================================================
                              Address   ndx         Next         _Dev_  Timestamp   Act Type_  EventMask__,nn x _____Sector_____, Len_  flags  counts
DBG[04366]: staged            0x5d9f0d0[   0] ->    0x5d9f820    8,  0  12.05819225 'A'    FWS AQ.........,01 3:               0,     0 000084
DBG[04366]: staged            0x5d9f820[   1] ->        (nil)    8,  0  12.05819245 'A'    FWS A..........,01 3:               0,     0 000084
DBG[04344]: --------------------------------------------------------------------


DBG[04397]: dump_mainio_list(0)
DBG[04398]: ===================================================================================
                              Address   ndx         Next         _Dev_  Timestamp   Act Type_  EventMask__,nn x _____Sector_____, Len_  flags  counts
DBG[04401]: current_mainio        (nil)[    ]
DBG[04408]: --------------------------------------------------------------------

DBG[06669]: best_match_special1(Q,io=0x5d9f0d0,temp=0x5d9f820)
DBG[06698]: [ 12.058192746] Q FWS ; io 00 0003: temp 01 0001; debug_mask 0002 (event not present)
DBG[06706]: [ 12.058192746] Q FWS ; io 00 0003: temp 03 0001; event_mask 0001 (pre-reqs present )
DBG[06727]: [ 12.058192746] Q FWS ; io 04  FWS: temp 07  FWS
DBG[06759]; best_match_special1(), 1st   'io' disqualified (newest)                            << yup, has a 'Q' already
DBG[06760]: best_match_special1(), Nth 'temp'    qualified (oldest) [ 12.058192246] A FWS      << yup, best match.
DBG[06960]: return best match 0x5d9f0d0                                                        << huh, it passed back 'io' not 'temp'!?
blktrace_merge: blktrace_parse.v4.c:7603: queue_event: Assertion `io->info->QSeqNo == 0' failed.

doh! I best=io not best=temp.  stupid programmer = stupid bug.

*/


/*
 * 2.6.32++ example case /cases/SF02825588/blktrace.1610032780953179895-cavadb77.1/run-20210107-122321
 *

Check the following are properly processed:

 65,80   4       88   147.726639006  2261  Q   R 0 + 8 [(null)]
 65,80   4       89   147.726640683  2261  G   R 0 + 8 [(null)]
 65,80   4       90   147.726641142  2261  P   N [(null)]
 65,80   4       91   147.726643583  2261  I   R 0 + 8 [(null)]
 65,80   4       92   147.726644166  2261  U   N [(null)] 1
 65,80   4       93   147.726645020  2261  D   R 0 + 8 [(null)]
 65,80   0       15   147.727088089     6  C   R 0 + 8 [0]
>> good ouput:
#Prg:Flt   Queue(s)     Q2I(ms)   Q2D(ms)       D2C(ms)            Q2C(ms)     CPU      PID Typ  Size         Sector         Seek  Description            reQ Merges:sectors,...
#---:--- ------------- -------- ------------- -------------+---- ------------- --- -------- ---- ---- -------------- ------------- ---------------------- --- ---:---------------------
   1:  1 147.726639006   0.0046      0.006014      0.443069 % 98      0.449083   4     2261 R       8              0        -51536 [(null):pid not found]   0   0


 65,80   4       94   148.732180793  2261  G   N [(null)]
 65,80   4       95   148.732184891  2261  I   R 236 (a3 0a 00 00 00 00 00 00 00 ec 00 ..) [(null)]
 65,80   4       96   148.732185635  2261  D   R 236 (a3 0a 00 00 00 00 00 00 00 ec 00 ..) [(null)]
 65,80   0       16   148.732332249     6  C   R (a3 0a 00 00 00 00 00 00 00 ec 00 ..) [0]
>> correct processing.  event 1 is non-io, 2, 3, and 4 are non-standard events with no sector:size info present.
>> should teach the processor to deal with (xx xx ....) and decode the nominal scsi command we'd see like 00 (TUR)
>> or this one RTPG

 65,80   2        1   158.237289371  4680  A   R 0 + 256 <- (253,94) 0
 65,80   2        2   158.237290605  4680  I   R 0 + 256 [kdmwork-253:94]
 65,80   2        3   158.237291674  4680  D   R 0 + 256 [kdmwork-253:94]
 65,80   0       17   158.238410044     6  C   R 0 + 256 [0]
>> tested, bug was fixed, now produces good output.

#Prg:Flt   Queue(s)     Q2I(ms)   Q2D(ms)       D2C(ms)            Q2C(ms)     CPU      PID Typ  Size         Sector         Seek  Description            reQ Merges:sectors,...
#---:--- ------------- -------- ------------- -------------+---- ------------- --- -------- ---- ---- -------------- ------------- ---------------------- --- ---:---------------------
   1:  1 158.237289371   0.0012      0.002303      1.118370 % 99      1.120673   2     4680 R     256              0            -8 [kdmwork-253:94]         0   0



The odd thing here is 'Q' and 'G' events only appear on the odd io, "normal" read and writes are just AIDC.

The first should produce a good read from sector 0 that is 8 sectors long.

The 2nd, an A3h 0Ah service action is an RTPG command and should be noop'd maybe? as there is no sector or size info
  present.

*/


/* 2.6.32++ special case for dm-* devices
 *


#Maj,Mn CPU   SeqNo     Seconds     PID  Evt Typ Sector   +Len Description
#------ --- ------- --------------- -----|--|---|---------+--- -------------------------------------
253,233 16        1     0.000000000 97549  Q   R 3896 + 32 [ora_ckpt_wqj]
253,233 16        2     0.000683788     0  C   R 3896 + 32 [0]
253,233 16        3     0.000734126 97549  Q   R 5720 + 32 [ora_ckpt_wqj]
253,233 16        4     0.001796586     0  C   R 5720 + 32 [0]
253,233 16        5     0.001838873 97549  Q   R 5784 + 32 [ora_ckpt_wqj]
253,233 16        6     0.002633219     0  C   R 5784 + 32 [0]
253,233 16        7     0.002679117 97549  Q   R 5816 + 32 [ora_ckpt_wqj]
253,233 16        8     0.003562486     0  C   R 5816 + 32 [0]
253,233 16        9     0.003863907 97549  Q  WS 3960 + 32 [ora_ckpt_wqj]
253,233 16       10     0.005171649     0  C  WS 3960 + 32 [0]
253,233 17        1     0.006773517 97549  Q   R 3896 + 32 [ora_ckpt_wqj]
253,233 17        2     0.007171101     0  C   R 3896 + 32 [0]
253,233 17        3     0.007216560 97549  Q   R 5720 + 32 [ora_ckpt_wqj]
253,233 17        4     0.007699816     0  C   R 5720 + 32 [0]
253,233 17        5     0.007727837 97549  Q   R 5784 + 32 [ora_ckpt_wqj]
253,233 17        6     0.008264796     0  C   R 5784 + 32 [0]
253,233 17        7     0.008289795 97549  Q   R 291680 + 32 [ora_ckpt_wqj]
253,233 17        8     0.008561603     0  C   R 291680 + 32 [0]
253,233 16       11     2.462583572  7402  Q  WS 4594952 + 8 [jbd2/dm-233-8]
253,233 16       12     2.462595273  7402  Q  WS 4594960 + 8 [jbd2/dm-233-8]
253,233 16       13     2.469318482     0  C  WS 4594952 + 8 [0]
253,233 16       14     2.469319605     0  C  WS 4594960 + 8 [0]
253,233 16       15     2.469350066  7402  Q  WS 4594968 + 8 [jbd2/dm-233-8]
253,233 16       16     2.470146214     0  C  WS 4594968 + 8 [0]

There are no events that advance a Q event in the pre-stage queue/area to the active queue,
the io go directly from pre-stage to completed.  Need to take this into account for dm type
devices -- for now if the major number is 253 then check/allow for this type of behavior.

The old version of parse didn't care as it didn't have the pre-stage queue area, it was flat
all one queue.

#Input file: dm-233.blktrace.txt
 %W[06381]-orphan 'C'ompletion event discarded: '253,233 16        2     0.000683788     0  C   R 3896 + 32 [0]'
 %W[06381]-orphan 'C'ompletion event discarded: '253,233 16        4     0.001796586     0  C   R 5720 + 32 [0]'
 %W[06381]-orphan 'C'ompletion event discarded: '253,233 16        6     0.002633219     0  C   R 5784 + 32 [0]'
 %W[06381]-orphan 'C'ompletion event discarded: '253,233 16        8     0.003562486     0  C   R 5816 + 32 [0]'
 %W[06381]-orphan 'C'ompletion event discarded: '253,233 16       10     0.005171649     0  C  WS 3960 + 32 [0]'


*/

/* 
 * 2.6.32++ blktrace
 *



--bgn:000003-----------------------------------------      0:       0
Input file dm-312.blktrace.0 added
%E[02760]-Compound event action 'file' that is not a 'UT' event. add to exceptions.
%E[02800]-Compound event type (RWBS) 'dm-312.blktrace.0' unparsed for prime type, add to exceptions.
DBG[03017]: not in norm format per primary type, skipping further parse
--end------------------------------------------------


R+W+Barrier+Sync = read .AND. write barrier ; both/all types of data io must complete before scheduler
                   runs this io. New barrier type, add to recognized list.


--bgn:000161-----------------------------------------      0:       2
253,312  0        7     0.001545166     6  C   R 3122341952 + 16 [0]
%W[06182]-could not find 'main' io request to completion       3122341952:      16 into @253,312  0        7     0.001545166     6  C   R 3122341952 + 16 [0], line=161 (limit=400), Qevents=5 (limit=200)
DBG[10320]: event flag DISCARDED not set?
253,312  0        7     0.001545166     6  C   R 3122341952 + 16 [0]                           ;#U0
%W[06382]-orphan 'C'ompletion event discarded: '253,312  0        7     0.001545166     6  C   R 3122341952 + 16 [0]'
%E[13856]-event processing fault in complete_event: 9949 ; 'orphan 'C' event, discard'
DBG[09949]: continuing after data processing fault
--end------------------------------------------------

--bgn:000162-----------------------------------------      0:       2
253,312  0        8     0.001558861     6  C   N 3122341952 [0]
%I[02954]: not in norm format per primary type, is IOTYP_NONE
--end------------------------------------------------


>> This is early enough that this could be an orphan C event... a search confirms.  But
>> what is very odd here is that there is a non-data C event on same sector right after it.
>> is this a new type of overlapping io, with a non-data io, maybe a barrier, is started
>> started on sector right after the data io is started on that sector?

%I[02954]: not in norm format per primary type, is IOTYP_NONE

...and yes this is not in norm format, but its also even less important because its a non-data 'N' io event:

152:253,312 50       21     0.000798997 109036  A   R 422109056 + 16 <- (253,321) 422076288
153:253,312 50       22     0.000799442 109036  Q   R 422109056 + 16 [ora_w035_nq0]
154:253,312 50       23     0.000800384 109036  G   R 422109056 + 16 [ora_w035_nq0]
156:253,312 50       25     0.000801158 109036  I   R 422109056 + 16 [ora_w035_nq0]
158:253,312 50       27     0.000802129 109036  D   R 422109056 + 16 [ora_w035_nq0]
163:253,312 50       28     0.001603885     0  C   R 422109056 + 16 [0]
171:253,312 50       29     0.001616043   263  C   N 422109056 [0]

>> wth is the extra non-data io C for?.
>> we should probably annotate that IOTYP_NONE (N:non-data movement command)... as special case?.

Looking for other examples clearly shows the 2nd non-data C event against the sector is "standard"
within this data stream:

207078:253,312  6     4663     6.010327893 30531  A   R 2925382800 + 16 <- (253,324) 251554960
207079:253,312  6     4664     6.010329303 30531  Q   R 2925382800 + 16 [oracle_30531_nq]
207080:253,312  6     4665     6.010331442 30531  G   R 2925382800 + 16 [oracle_30531_nq]
207082:253,312  6     4667     6.010332452 30531  I   R 2925382800 + 16 [oracle_30531_nq]
207084:253,312  6     4669     6.010333560 30531  D   R 2925382800 + 16 [oracle_30531_nq]
207104:253,312  0    22467     6.010716999     6  C   R 2925382800 + 16 [0]
207106:253,312  0    22468     6.010733773     6  C   N 2925382800 [0]
5166815:253,312 62    23231   169.078970702 18044  A   R 2925382800 + 16 <- (253,324) 251554960
5166816:253,312 62    23232   169.078971186 18044  Q   R 2925382800 + 16 [oracle_18044_nq]
5166817:253,312 62    23233   169.078972300 18044  G   R 2925382800 + 16 [oracle_18044_nq]
5166819:253,312 62    23235   169.078973187 18044  I   R 2925382800 + 16 [oracle_18044_nq]
5166821:253,312 62    23237   169.078974013 18044  D   R 2925382800 + 16 [oracle_18044_nq]
5166831:253,312 62    23238   169.079284425     0  C   R 2925382800 + 16 [0]
5166832:253,312 62    23239   169.079293588   323  C   N 2925382800 [0]

Checking for the full sequence to make sure there is nothing before this...

5166824-253,312  1   187365   169.079078932 30629  A   R 3649094336 + 16 <- (253,321) 975266496
5166825-253,312  1   187366   169.079079698 30629  Q   R 3649094336 + 16 [oracle_30629_nq]
5166826-253,312  1   187367   169.079081594 30629  G   R 3649094336 + 16 [oracle_30629_nq]
5166827-253,312  1   187368   169.079082101 30629  P   N [oracle_30629_nq]
5166828-253,312  1   187369   169.079082865 30629  I   R 3649094336 + 16 [oracle_30629_nq]
5166829-253,312  1   187370   169.079083688 30629  U   N [oracle_30629_nq] 1
5166830-253,312  1   187371   169.079084419 30629  D   R 3649094336 + 16 [oracle_30629_nq]
5166831:253,312 62    23238   169.079284425     0  C   R 2925382800 + 16 [0]
5166832:253,312 62    23239   169.079293588   323  C   N 2925382800 [0]

So while "normal" io in this file are for some dm (above is dm-312, below is dm-233)

#Maj,Mn CPU   SeqNo     Seconds     PID  Evt Typ Sector   +Len Description
#------ --- ------- --------------- -----|--|---|---------+--- -------------------------------------
253,233 16        1     0.000000000 97549  Q   R 3896 + 32 [ora_ckpt_wqj]
253,233 16        2     0.000683788     0  C   R 3896 + 32 [0]
253,233 16        3     0.000734126 97549  Q   R 5720 + 32 [ora_ckpt_wqj]
253,233 16        4     0.001796586     0  C   R 5720 + 32 [0]
253,233 16        5     0.001838873 97549  Q   R 5784 + 32 [ora_ckpt_wqj]
253,233 16        6     0.002633219     0  C   R 5784 + 32 [0]
253,233 16        7     0.002679117 97549  Q   R 5816 + 32 [ora_ckpt_wqj]
253,233 16        8     0.003562486     0  C   R 5816 + 32 [0]
253,233 16        9     0.003863907 97549  Q  WS 3960 + 32 [ora_ckpt_wqj]
253,233 16       10     0.005171649     0  C  WS 3960 + 32 [0]
253,233 17        1     0.006773517 97549  Q   R 3896 + 32 [ora_ckpt_wqj]
253,233 17        2     0.007171101     0  C   R 3896 + 32 [0]
253,233 17        3     0.007216560 97549  Q   R 5720 + 32 [ora_ckpt_wqj]
253,233 17        4     0.007699816     0  C   R 5720 + 32 [0]
253,233 17        5     0.007727837 97549  Q   R 5784 + 32 [ora_ckpt_wqj]
253,233 17        6     0.008264796     0  C   R 5784 + 32 [0]
253,233 17        7     0.008289795 97549  Q   R 291680 + 32 [ora_ckpt_wqj]
253,233 17        8     0.008561603     0  C   R 291680 + 32 [0]

I guess the format is specific to the dm- block layer type, maybe lvm vs mpath or something.
The dangling 2nd C in non-data io type format (N) against that starting sector of the preceeding
io is "interesting" but for our purposes is an orphan and discarded.  I suppose we can start a 
post completion/output queue -- a short N position fifo ring buffer of the last N io completed
and see if the C/N io sector matches one of the last/recently completed io... but not sure why
we'd do that other than to tie it off as a known footprint event.

NOTE:

253,233 85        1    54.209464325 127673  Q   R 3896 + 32 [oracle_127673_w]
253,233 23        5    54.209511596 127671  Q   R 3896 + 32 [oracle_127671_w]
253,233 85        2    54.209728307     0  C   R 3896 + 32 [0]
DBG[14972]: io 0x1920620 is missing required events
DBG[14994]: temp 0x1920b70 is missing required events
DBG[14997]: temp    0x1920b70
DBG[14998]: io mask 0002 .Q...... ->event_mask
DBG[14999]: allowed 0733 AQSG..RI   event_mask
DBG[15000]: options FECE A.SG..R.   optional (removal mask)
DBG[15001]: remains 0002 .Q......   after removing optional
DBG[15002]: require 0602 .Q.....I   required mask
DBG[15003]: results 0600            (must be zero)
253,233 23        6    54.209792607     0  C   R 3896 + 32 [0]
253,233 85        3    54.219429679 127673  Q   R 5688 + 32 [oracle_127673_w]
253,233 22        1    54.219497590 127671  Q   R 5688 + 32 [oracle_127671_w]
253,233 85        4    54.219726487     0  C   R 5688 + 32 [0]

This will happen with Q|C logic and there are two or more overlapping io to the same sector.
In the above, there are two R to the same sector by two different processes.
Whereas when there is no overlap:

253,233 21       21    60.120165763 97549  Q  WS 3960 + 32 [ora_ckpt_wqj]
253,233 21       22    60.120625715     0  C  WS 3960 + 32 [0]
253,233 22        5    60.123054587 97549  Q   R 3896 + 32 [ora_ckpt_wqj]
253,233 22        6    60.123884410     0  C   R 3896 + 32 [0]
253,233 22        7    60.123926310 97549  Q   R 5688 + 32 [ora_ckpt_wqj]
253,233 22        8    60.124130585     0  C   R 5688 + 32 [0]
253,233 22        9    60.124156578 97549  Q   R 5752 + 32 [ora_ckpt_wqj]
253,233 22       10    60.124484339     0  C   R 5752 + 32 [0]
253,233 22       11    60.124524870 97549  Q   R 291712 + 32 [ora_ckpt_wqj]
253,233 22       12    60.124810331     0  C   R 291712 + 32 [0]

This is semi-normal and disabling the dbg output is not in our best interest.


 */
 /* Fault processing notes                                                 							*/
 /* --------------------------------------------------------------------------------------------------------------------------- */
 /* Fault processing functions are called to report, set state, & resolve (drop,exit,...) based 
  * upon the fault and the current state. There are several macros to call one of the fault 
  * processing functions.  The functions are *only* called via a _FAULT macro.
  *
    DATA_FEATURE_FAULT(    _event,_typ,_rsn,_ctl) return(_typ      _data_processing_fault(_event,__FUNCTION__, __LINE__, _rsn, _ctl)) 
    PROG_FEATURE_FAULT(    _event,_typ,_rsn,_ctl) return(_typ   _program_processing_fault(_event,__FUNCTION__, __LINE__, _rsn, _ctl))
    PROG_FEATURE_FAULT1(   _io   ,_typ,_rsn,_ctl) return(_typ  _program_processing_fault1(_io   ,__FUNCTION__, __LINE__, _rsn, _ctl))
    PROG_FEATURE_FAULT1_NO(_io   ,_typ,_rsn,_ctl)              _program_processing_fault1(_io   ,__FUNCTION__, __LINE__, _rsn, _ctl)
 
          RUNTIME_FAULT(   _event,_typ,_rsn,_ctl) return(_typ              _runtime_fault(_event,__FUNCTION__, __LINE__, _rsn, _ctl))
 
    RUNTIME_FAULT     : fault on system event like malloc() failed, detectable faults unrelated to the event data being processed.
 
    DATA_FEATURE_FAULT: fault on an io block such that it could not be accurately attached to an io context for some reason 
                        that is, the data as captured within a merged io block cannot be properly processed. The default policy
                        is to continue unless -DDEBUG is present, in which case the default policy is to exit.
        1) DATA_FEATURE_FAULT(this,(typ_io *),"2ndhand merging failed",                   CTL_FAULT_DEFAULT);
        2) DATA_FEATURE_FAULT(this,(typ_io *),"multiple conflicting matched io",          CTL_FAULT_DEFAULT);
        3) DATA_FEATURE_FAULT(this,(typ_io *),"best_match failed to resolve to target io",CTL_FAULT_DEFAULT);
 
    NOTE: currently there is no callouts to _discard_processing_fault()? Oversight?
  */



/*
 * internal logic fault?  multiple issues here that need to be addressed.
 *
 253,4   62        2     0.009975147     0  C WFSM 524777921 + 4 [0]
DBG[02698]: verify_staged_list(ok)
DBG[02699]: verify_mainio_list
DBG[02699]: verify_mainio_list(ok)
DBG[09739]: part 'A' - tmo check of 0
DBG[09814]: part 'B' - mainio full request match check
DBG[09815]: check mainio list for match  524777921:     4...{full request coverage}
DBG[09826]: part 'C' - postio sub-bio match only
DBG[09827]: check postio list for match  524777921:     4...{sub-BIO only coveraged}
DBG[09921]: part 'D'
DBG[09922]: check mainio list for match  524777921:     4...{sub-BIO only coveraged}

DBG[09977]: dm device detected.  special check staging queue...'253,4   62        2     0.009975147     0  C WFSM 524777921 + 4 [0]'

DBG[06659]: stage list  524777921:     4 0x23524f0
DBG[06662]: stage list  524777921:     4 0x23524f0 matched!
DBG[06672]: stage list  524777921:     4 0x23524f0 passed filters!
DBG[06677]: staged list  0x23524f0  524777921:     4... <= 1st hit
DBG[09988]: looking for @ 0.009975147:524777921+     4, found  0.009921410:524777921+     4 on staged staged list (dm- device)
DBG[11219]:              mov_staged (0x23524f0 Q FWFSM  524777921+4 '[mysqld]') <= remove io from staged list, add to mainio list
DBG[11224]: verify_staged_list(ok)
DBG[11266]: clr IS_STAGED on io 0x23524f0  524777921:     4
DBG[11276]: move_staged_to_mainio() - inProgress++ = 1
DBG[10029]: looking for @ 0.009975147:524777921+     4, found  0.009921410:524777921+     4 on staged list {subio:(nil) via 'F'}
%I[10114]: complete io  524777921      4 F: 0.009921410 < C: 0.009975147 (+-0.000053737)


%W[10135]-corner case detected, force to postio: '253,4   62        2     0.009975147     0  C WFSM 524777921 + 4 [0]'
DBG[10231]: ctracker update 524777921:4 ; line -> tmo 6->16 , time -> tmo    0.009975 ->    0.011975
%E[14488]-missing feature fault in complete_event:10275 ; 'internal logic fault, matched type '^E' processing missing!.'
DBG[10275]: continuing after nofeature fault
--end------------------------------------------------


So at the end of things, we have a bunch of completed io on the mainio queue that were never moved onto the postio/completed
queue... is that because the thing that moved these from staged->mainio queue was due to 'C' event and not the expected G,S,M, or I
events?  So the mainio queue, which we expect to only accumulate nr_requests or so, ends up accumulating a LOT of io.  

NOTE**** though that the Q/C WS io move staged->mainio->postio w/o issue.  Only the FWFSM seem to have gotten hung up for
some unknown reason!!!!

DBG[04764]: dump_mainio_list(8)
DBG[04765]: ===================================================================================
                              Address   ndx         Next         _Dev_  Timestamp   Act Type_  EventMask__,nn x _____Sector_____, Len_  flags  counts
DBG[04768]: current_mainio        (nil)[    ]
DBG[04799]: active            0x23632c0[   0] ->    0x2362210  253,  4   0.29150246 'Q'  FWFSM .Q.......C.,01 3:       524777939,     2 040000 merges=   0 requeues=   0 sleeps=   0
DBG[04799]: active            0x2362210[   1] ->    0x2359100  253,  4   0.29123031 'Q'  FWFSM .Q.......C.,01 3:       524777937,     2 040000 merges=   0 requeues=   0 sleeps=   0
DBG[04799]: active            0x2359100[   2] ->    0x2358050  253,  4   0.29093679 'Q'  FWFSM .Q.......C.,01 3:       524777935,     2 040000 merges=   0 requeues=   0 sleeps=   0
DBG[04799]: active            0x2358050[   3] ->    0x23567b0  253,  4   0.29070476 'Q'  FWFSM .Q.......C.,01 3:       524777933,     2 040000 merges=   0 requeues=   0 sleeps=   0
DBG[04799]: active            0x23567b0[   4] ->    0x23556b0  253,  4   0.29035894 'Q'  FWFSM .Q.......C.,01 3:       524777929,     4 040000 merges=   0 requeues=   0 sleeps=   0
DBG[04799]: active            0x23556b0[   5] ->    0x23545b0  253,  4   0.01032288 'Q'  FWFSM .Q.......C.,01 3:       524777927,     2 040000 merges=   0 requeues=   0 sleeps=   0
DBG[04799]: active            0x23545b0[   6] ->    0x23524f0  253,  4   0.01010913 'Q'  FWFSM .Q.......C.,01 3:       524777925,     2 040000 merges=   0 requeues=   0 sleeps=   0
DBG[04799]: active            0x23524f0[   7] ->        (nil)  253,  4   0.00992141 'Q'  FWFSM .Q.......C.,01 3:       524777921,     4 040000 merges=   0 requeues=   0 sleeps=   0
DBG[04775]: --------------------------------------------------------------------

Note the above if from a very very short dm-4 file or 10-16 events, of which 8 end up stuck in mainio w/Complete status!.

not normal:
DBG[09988]: looking for @ 0.009975147:524777921+     4, found  0.009921410:524777921+     4 on staged staged list (dm- device)
DBG[11219]:              mov_staged (0x23524f0 Q FWFSM  524777921+4 '[mysqld]') <= remove io from staged list, add to mainio list
DBG[11224]: verify_staged_list(ok)
DBG[11266]: clr IS_STAGED on io 0x23524f0  524777921:     4
DBG[11276]: move_staged_to_mainio() - inProgress++ = 1
DBG[10029]: looking for @ 0.009975147:524777921+     4, found  0.009921410:524777921+     4 on staged list {subio:(nil) via 'F'}
%I[10114]: complete io  524777921      4 F: 0.009921410 < C: 0.009975147 (+-0.000053737)
>> 
>> same to here, but then ... it says "force to postio" but it didn't!
>>
%W[10135]-corner case detected, force to postio: '253,4   62        2     0.009975147     0  C WFSM 524777921 + 4 [0]'
DBG[10231]: ctracker update 524777921:4 ; line -> tmo 6->16 , time -> tmo    0.009975 ->    0.011975
%E[14488]-missing feature fault in complete_event:10275 ; 'internal logic fault, matched type F:'5' processing missing!.'
DBG[10275]: continuing after nofeature fault
--end------------------------------------------------




Here is a "normal" C event within the above test file:

DBG[09988]: looking for @ 0.009880290:789586704+   104, found  0.000000000:789586704+   104 on staged staged list (dm- device)
DBG[11219]:              mov_staged (0x2348c90 Q WS     789586704+104 '[mysqld]') <= remove io from staged list, add to mainio list
DBG[11224]: verify_staged_list(ok)
DBG[11266]: clr IS_STAGED on io 0x2348c90  789586704:   104
DBG[11276]: move_staged_to_mainio() - inProgress++ = 1
DBG[10029]: looking for @ 0.009880290:789586704+   104, found  0.000000000:789586704+   104 on staged list {subio:(nil) via 'F'}
%I[10114]: complete io  789586704    104 F: 0.000000000 < C: 0.009880290 (+-0.009880290)
>>
>> same to here only.
dDBG[04897]: dump_io_raw() flag_debug=4 reason=''
dDBG[04903]: dump mainio event 0000000002348C90, merges=0(1 active, 36999104 completed)
dDBG[04906]:      sector, size, 'Q' QIDC :    789586704:   104 .Q.......C.  0.000000000  0.000000000  0.000000000  0.009880290
dDBG[04938]: done.
DBG[12172]: stats_check_boundary( 1.000000000) flg:0 inPrg:1 idle:1 evtime: 0.000000000
DBG[12174]: io event first= 0.000000000 this  0.000000000
DBG[05300]: disk_access 0000000789586704      104   9.88029003 write
DBG[05314]: end_sector:bucket 789586704:24096
DBG[05316]: end_sector:segment 789586704:5  (bucket:24096)
DBG[05489]: allocated bucket struct for #24096
DBG[05323]: disk_access    24096:[   5,3616] FFFFFFFFFFFFFFFF 000000002F102310 0000000000000000
DBG[05333]: disk_access    24096:[   5,3616] 0000000789577728 0000000789586704 0000000789610495
DBG[05365]: disk_access    24096:[   5,3616] w: 1,104,      9.8803,      9.8803
queue        insert        Q2I          dispatch    Q2D           completed     Q2C          cpu pid     iotyp    size           sector    name/string
 0.000000000  0.000000000/ 0.000000000  0.000000000/ 0.000000000  0.009880290/ 0.009880290   35 1665597 WS        104        789586704 [mysqld]
DBG[10681]: event used. not discarded.
253,4   62        1     0.009880290     0  C  WS 789586704 + 104 [0]                           ;#U0            1          0          0|   0|   1:   0,   1|   0:   0,   0|  -1    0
DBG[11324]:              mov_mainio (0x2348c90 Q WS     789586704+104 '[mysqld]') <= remove io from mainio list, add to done   list
DBG[11328]: verify_mainio_list
DBG[11328]: verify_mainio_list(ok)
DBG[11385]: updated inProgress here @move_io_to_done() time.
DBG[11390]: move_mainio_to_done() - inProgress-- = 0
DBG[11420]: queue state set idle @ 0.009880290 here @move_mainio_to_done()
--end------------------------------------------------

...and the normal WS Q,C

--bgn:000004-----------------------------------------      1:       0
253,4   62        1     0.009880290     0  C  WS 789586704 + 104 [0]
DBG[02698]: verify_staged_list(ok)
DBG[02699]: verify_mainio_list
DBG[02699]: verify_mainio_list(ok)
DBG[09739]: part 'A' - tmo check of 0
DBG[09814]: part 'B' - mainio full request match check
DBG[09815]: check mainio list for match  789586704:   104...{full request coverage}
DBG[09826]: part 'C' - postio sub-bio match only
DBG[09827]: check postio list for match  789586704:   104...{sub-BIO only coveraged}
DBG[09921]: part 'D'
DBG[09922]: check mainio list for match  789586704:   104...{sub-BIO only coveraged}

DBG[09977]: dm device detected.  special check staging queue...'253,4   62        1     0.009880290     0  C  WS 789586704 + 104 [0]' <<  case='F' Q,C only.

DBG[06659]: stage list  789586704:   104 0x228ac90
DBG[06662]: stage list  789586704:   104 0x228ac90 matched!
DBG[06672]: stage list  789586704:   104 0x228ac90 passed filters!
DBG[06677]: staged list  0x228ac90  789586704:   104... <= 1st hit
DBG[09988]: looking for @ 0.009880290:789586704+   104, found  0.000000000:789586704+   104 on staged staged list (dm- device)
DBG[11219]:              mov_staged (0x228ac90 Q WS     789586704+104 '[mysqld]') <= remove io from staged list, add to mainio list
DBG[11224]: verify_staged_list(ok)
DBG[11266]: clr IS_STAGED on io 0x228ac90  789586704:   104
DBG[11276]: move_staged_to_mainio() - inProgress++ = 1
DBG[10029]: looking for @ 0.009880290:789586704+   104, found  0.000000000:789586704+   104 on staged list {subio:(nil) via 'F'}
%I[10114]: complete io  789586704    104 F: 0.000000000 < C: 0.009880290 (+-0.009880290)


dDBG[04897]: dump_io_raw() flag_debug=4 reason=''
dDBG[04903]: dump mainio event 000000000228AC90, merges=0(1 active, 36220864 completed)
dDBG[04906]:      sector, size, 'Q' QIDC :    789586704:   104 .Q.......C.  0.000000000  0.000000000  0.000000000  0.009880290
dDBG[04938]: done.
DBG[12172]: stats_check_boundary( 1.000000000) flg:0 inPrg:1 idle:1 evtime: 0.000000000
DBG[12174]: io event first= 0.000000000 this  0.000000000
DBG[05300]: disk_access 0000000789586704      104   9.88029003 write
DBG[05314]: end_sector:bucket 789586704:24096
DBG[05316]: end_sector:segment 789586704:5  (bucket:24096)
DBG[05489]: allocated bucket struct for #24096



*/

/*

4.18'ism: with LVM devices which usually only have Q,C events.


--bgn:1038993-----------------------------------------  17767:       0
253,470 139     4389    12.177968255 1349202  X   W 3409663328 / 3409663360 [postgres]
DBG[03130]: except: F fmt: 1  none: F
DBG[03142]: !IOTYP_NONE or IOTYP_NONE+Flush
%F[07079]-fatal, split_event(4396062,17766) found more than 1 match!

Special case: Q,X,<nil>  
If an lvm Queued io has a subsequent X split, then it never has a C event for 
either of the splits.
    + Processing exception (tentative)
      if a X split is processed and there are two io in staged with the same
      sector,length and X event was applied to the previous (first found) 
      event, then that first event is likely orphaned and will never have 
      a C event to remove it from the staged queue.
      - if the above footprint identified .AND. no I,G,D events have been
        ever been previously processed, .AND. we are not near the top of the
	blktrace file {ed:such that the I,G,D global counters may be zero just
        because we haven't processed enough events}, then exception out the 
	prior Q,X io as never likely to be completed.
	+ NOTE: we don't really know what happened to the Q,X,nil io event
	  stream.  We'd need to look at the underlying devices of the lv 
	  to see if an io event of lba,length was passed at the same time
	  to the underlying device or not.  I expect it was, but for some
	  reason, its C event never ends up being output in the lv layer.


 633990:253,470 18     4535     8.222449308 2161444  Q   W 3409663328 + 64 [postgres]
 633991:253,470 18     4536     8.222451654 2161444  X   W 3409663328 / 3409663360 [postgres]  << no C for 3409663328
 635682:253,470 50     6434     8.238387593 1273336  C   W 3409663360 + 32 [0]		       << split event completes[1]

1038987:253,470 139    4388    12.177957547 1349202  Q   W 3409663328 + 128 [postgres]
1038993:253,470 139    4389    12.177968255 1349202  X   W 3409663328 / 3409663360 [postgres]  << this is one, finds 2 W io @ 3409663328[2]
1040973:253,470 35     5549    12.196393179 19690    C   W 3409663360 + 96 [0]		       << split event completes

5152724:253,470 72    41026    51.058221878 1349202  Q   W 3409663360 + 64 [postgres]	       << normal
5154981:253,470 92    49049    51.078499218 19690    C   W 3409663360 + 64 [0]		       << normal, BUT![3]

6656182:253,470 35    50797    68.175153266 975901   Q   W 3409663328 + 32 [postgres]
6659065:253,470 88    48957    68.208129274 19690    C   W 3409663328 + 32 [0]

8691390:253,470 140    8759    90.539419099 966211   Q   W 3409663360 + 32 [postgres]
8693032:253,470 62    60332    90.554402433 19690    C   W 3409663360 + 32 [0]

[1] Note, in this case we *could*, if we so chose, use the C on the split io to then
    search the staged queue for the main io associated with this split and if so found 
    force complete it to.  This would prevent just dumping off the original io as Q,X,nil
    exception and not count it. See suggested changes for detecting such cases.
[2] Note the split tells us the starting lba of original io and the starting lba of the 
    new split lba, but no length to use as matching criteria -- it is assumed that is not
    needed.  In this case there are two io on staged queue with that lba... the original
    one from 8.2 sec mark that was +64 but after split is +32 and then the unsplit one at
    the 12.1s mark that is 128 sectors.

    Suggested changes.
    1) add X split event to both io post split so we know they had a split event
    2) add O original specials flag to the original io so we know which was the 
       original io.  By practice, original io are split only once.  So, A->A.1,A.2
       and A.1 will no longer be subject to splits.  But A.2 could split into
       A.2',A.3 and A.2' would then get O flag attached?  I think that is 
       insufficient.  We need to add some better tracking of splits by depth and
       original lba,length,time.  Any one io associated with splits needs to track
       its immediate parent io.  So

           io #1  1.000 : 10,100 -> 10,25 (this) and 35,75 (split)
	                  35,75  -> 35,25            60,50 (split)
			  60,50  -> 60,25            85,25 (split)

			  10,100         orig: -    -          0
			  10,25	+ Xevt + orig: 1.00,10,100 lvl 1 (making this 1st io split from original)
			  35,75 + Xevt + orig: 1,00,10,100 lvl 2 (making this 2nd io split from original)
			  35,25 + Xevt + orig: " "
			  60,50 + Xevt + orig: 1.01,35,75  lvl 3
			  60,25 + Xevt + orig: " "
			  85,25 + Xevt + orig: 1.01,35,75  lvl 4
     3) if X split finds multiples, choose the "best one" which does not have an X event already.
        {ed: the problem with this is it will generate two io and the 2nd event could orphan a different
	     io that we're looking for, but in the current 4.18 case, the 2nd split event does complete.
	     Alternatively, we can special case the C event on the 2nd split to complete all other io
	     from the same split tree -- but for 4.18 only the "main" io (lvl=1,3,5,...) this io was 
	     was split off from.}

[3] BTT is fairly simple, match a C to its Q for Q2C.  So in this case this C will likely be matched 
    as follows:

     633990:253,470 18     4535     8.222449308 2161444  Q   W 3409663328 + 64 [postgres]
    5154981:253,470 92    49049    51.078499218 19690    C   W 3409663360 + 64 [0]                 << normal, BUT![3]
                               >> large Q2C difference

 
    instead of as:

    5152724:253,470 72    41026    51.058221878 1349202  Q   W 3409663360 + 64 [postgres]          << normal
    5154981:253,470 92    49049    51.078499218 19690    C   W 3409663360 + 64 [0]                 << normal, BUT![3]
                               >> small Q2C difference


			       
This issue does NOT happen with non-LVM devices that have X split events.

253,89  67     3464    12.234701221 19690  A   W 3119963904 + 128 <- (253,457) 865482496	-> staged
253,89  67     3465    12.234701393 19690  Q   W 3119963904 + 128 [mdX_raid10]			   staged
253,89  67     3466    12.234701707 19690  X   W 3119963904 / 3119964000 [mdX_raid10]		   staged
253,89  67     3467    12.234702147 19690  G   W 3119963904 + 96 [mdX_raid10]			   staged -> mainio
253,89  67     3468    12.234702592 19690  G   W 3119964000 + 32 [mdX_raid10]                      staged -> mainio
253,89  67     3499    12.235065565 19690  I   W 3119963904 + 96 [mdX_raid10]				     mainio
253,89  67     3500    12.235065769 19690  I   W 3119964000 + 32 [mdX_raid10]				     mainio
253,89  67     3507    12.235095645 19690  D   W 3119963904 + 96 [mdX_raid10]				     mainio
253,89  67     3508    12.235100150 19690  D   W 3119964000 + 32 [mdX_raid10]				     mainio
253,89  67     3535    12.235450519 19690  C   W 3119963904 + 96 [0]					     mainio -> postio
253,89  67     3536    12.235451407 19690  C   W 3119963904 [0]                                                        postio -> (done:output)
253,89  67     3540    12.235485055 19690  C   W 3119964000 + 32 [0]				             mainio -> postio
253,89  67     3541    12.235504326 19690  C   W 3119964000 [0]						               postio -> (done:output)

*/

/*

   4.18'ism on lv device where Q/X/X/X... sequence does not end up with 
   a C event, but a later C' for Q' gets matched up with the much earlier
   X event resulting in bad Q2C calculation like the following:

Individual max await times:
#SEC: dTime(sec)         Q2I(ms)      Q2D(ms)      D2C(ms)      Q2C(ms;await)
#SEC:    38 wr.max         0.000        0.000    20933.854 %100     20933.854 
#SEC:    37 wr.max         0.000        0.000    20503.270 % 99     20503.270 
#SEC:    31 wr.max         0.000        0.000    14665.591 % 99     14665.591 
#SEC:    27 wr.max         0.000        0.000    10355.046 %100     10355.046 
#SEC:    26 wr.max         0.000        0.000     9202.000 %100      9202.000 
#SEC:    25 wr.max         0.000        0.000     8617.350 % 99      8617.350 
#SEC:    19 wr.max         0.000        0.000     2432.974 %100      2432.974 
#SEC:    18 wr.max         0.000        0.000     1636.754 %100      1636.754 
#SEC:    17 wr.max         0.000        0.000      464.145 %100       464.145 
#SEC:    48 wr.max         0.000        0.000      130.111 %100       130.111 
#SEC:    20 wr.max         0.000        0.000      128.976 %100       128.976 
#SEC:    47 wr.max         0.000        0.000       99.194 %100        99.194 
#SEC:     7 wr.max         0.000        0.000       84.026 % 99        84.026 
#SEC:    16 wr.max         0.000        0.000       76.243 % 99        76.243 
#SEC:    34 wr.max         0.000        0.000       67.157 % 99        67.157 
#SEC:     6 wr.max         0.000        0.000       65.591 % 99        65.591 
#SEC:     4 wr.max         0.000        0.000       62.634 % 99        62.634 
#SEC:     8 wr.max         0.000        0.000       49.912 % 99        49.912 
#SEC:    45 wr.max         0.000        0.000       43.107 % 99        43.107 

253,470 122    14392    17.252158201 1343941  X   W 307344384 / 307344512 [kworker/u291:3]
253,470 38    21193    38.169287370 980440  Q   W 307344512 + 32 [postgres]
253,470 111    27256    38.185971679 19690  C   W 307344512 + 32 [0]

>> The event stream confused the Q/C pairing logic.  Each of these Q and X events act as a Q event
>> for creating/introducing an io into the lv layer. These wr.max values are not correct.

253,470 122    14376    17.252119054 1343941  Q   W 307342496 + 2048 [kworker/u291:3]
253,470 122    14377    17.252122378 1343941  X   W 307342496 / 307342592 [kworker/u291:3]  << size of split is difference.
253,470 122    14378    17.252124445 1343941  X   W 307342592 / 307342720 [kworker/u291:3]
253,470 122    14379    17.252126428 1343941  X   W 307342720 / 307342848 [kworker/u291:3]
253,470 122    14380    17.252128528 1343941  X   W 307342848 / 307342976 [kworker/u291:3]
253,470 122    14381    17.252129881 1343941  X   W 307342976 / 307343104 [kworker/u291:3]
253,470 122    14382    17.252131688 1343941  X   W 307343104 / 307343232 [kworker/u291:3]
253,470 122    14383    17.252132758 1343941  X   W 307343232 / 307343360 [kworker/u291:3]
253,470 122    14384    17.252134785 1343941  X   W 307343360 / 307343488 [kworker/u291:3]
253,470 122    14385    17.252136043 1343941  X   W 307343488 / 307343616 [kworker/u291:3]
253,470 122    14386    17.252138255 1343941  X   W 307343616 / 307343744 [kworker/u291:3]
253,470 122    14387    17.252139552 1343941  X   W 307343744 / 307343872 [kworker/u291:3]
253,470 122    14388    17.252149475 1343941  X   W 307343872 / 307344000 [kworker/u291:3]
253,470 122    14389    17.252151549 1343941  X   W 307344000 / 307344128 [kworker/u291:3]
253,470 122    14390    17.252154052 1343941  X   W 307344128 / 307344256 [kworker/u291:3]
253,470 122    14391    17.252156428 1343941  X   W 307344256 / 307344384 [kworker/u291:3]
253,470 122    14392    17.252158201 1343941  X   W 307344384 / 307344512 [kworker/u291:3]

253,470 38    21193    38.169287370 980440  Q   W 307344512 + 32 [postgres]
253,470 111    27256    38.185971679 19690  C   W 307344512 + 32 [0]


>> At some point the number of splits can leave ALL the splits orphans without C events
>> need to guard against this when matching and make an exception if there are multiple
>> X and Q events that are active on the staged list.



>> here are the follow-on events that reference any of those starting lba sector numbers

253,470 75    11940    19.317826097 966061  Q   W 307342496 + 32 [postgres]
253,470 127    10506    19.342066443 19690  C   W 307342496 + 32 [0]

253,470 81    14112    19.363487032 966027  Q   W 307343104 + 32 [postgres]
253,470 48    10229    19.386773482 19690  C   W 307343104 + 32 [0]

253,470 131    11320    19.476925938 975443  Q   W 307344128 + 32 [postgres]
253,470 136    15171    19.509758461 19690  C   W 307344128 + 32 [0]

253,470 61    15522    19.544874025 978265  Q   W 307342976 + 32 [postgres]
253,470 61    15523    19.545112653 978265  Q   W 307343232 + 32 [postgres]
253,470 61    15524    19.545405301 978265  Q   W 307343488 + 32 [postgres]
253,470 71    10662    19.559544893 976257  Q   W 307343360 + 32 [postgres]
253,470 24    13221    19.559901760 978265  Q   W 307344256 + 32 [postgres]
253,470 71    10664    19.560080990 976257  Q   W 307343872 + 32 [postgres]
253,470 25    18268    19.571362131 19690  C   W 307342976 + 32 [0]
253,470 25    18383    19.573486472 974119  C   W 307343232 + 32 [0]
253,470 97    15234    19.587812357 19690  C   W 307343488 + 32 [0]
253,470 97    15237    19.587832856 19690  C   W 307343360 + 32 [0]
253,470 97    15380    19.592970704 19690  C   W 307344256 + 32 [0]
253,470 97    15599    19.596898454 19690  C   W 307343872 + 32 [0]

253,470  1    14034    19.852114007 975478  Q   W 307342720 + 32 [postgres]
253,470 106    12178    19.888512251 19690  C   W 307342720 + 32 [0]

253,470 135    18366    31.525828667 975952  Q   W 307344384 + 32 [postgres]
253,470 33    18943    31.544366358 19690  C   W 307344384 + 32 [0]

253,470 33    19885    33.642683700 976148  Q   W 307344000 + 32 [postgres]
253,470 119    20286    33.647977113 19690  C   W 307344000 + 32 [0]

253,470 22    29694    33.964551452 978862  Q   W 307342848 + 32 [postgres]
253,470 68    20864    33.968561610  5482  C   W 307342848 + 32 [0]

253,470 19    23316    34.067589742 976211  Q   W 307343616 + 32 [postgres]
253,470 42    21290    34.072259061  2497  C   W 307343616 + 32 [0]

253,470 36    26045    34.983147732 978130  Q   W 307342976 + 32 [postgres]
253,470 138    22839    35.004260413 19690  C   W 307342976 + 32 [0]

253,470 36    26264    35.889001475 975646  Q   W 307342592 + 32 [postgres]
253,470 96    27197    35.906499323 19690  C   W 307342592 + 32 [0]

253,470 38    21193    38.169287370 980440  Q   W 307344512 + 32 [postgres]
253,470 111    27256    38.185971679 19690  C   W 307344512 + 32 [0]

253,470 60    37030    40.662965887 966326  Q   W 307343744 + 32 [postgres]
253,470  2    23705    40.682304107 19690  C   W 307343744 + 32 [0]


>> as can be seen, multiple split io has **no** C events whatsoever.  All are orphaned.
>> I suspect that the others are similar, multiple X-split io that have no C events 
>> associated with them.

Normally we see:

253,470 117        2     0.000908070 1305925  Q  RA 3427587104 + 128 [postgres]
253,470 117        3     0.000910162 1305925  X  RA 3427587104 / 3427587200 [postgres]

253,470 117       27     0.001298067 1305925  C  RA 3427587200 + 32 [0]

And 2 X

253,470  5    32112    41.314900259 1349295  Q  RA 3671548864 + 256 [postgres]
253,470  5    32114    41.314921177 1349295  X  RA 3671548864 / 3671548928 [postgres]
253,470  5    32115    41.314942774 1349295  X  RA 3671548928 / 3671549056 [postgres]

253,470  5    32141    41.315793274 1349295  C  RA 3671549056 + 64 [0]

And 3 X

253,470  5    32320    41.321796520 1349295  Q  RA 3671560128 + 352 [postgres]
253,470  5    32321    41.321805824 1349295  X  RA 3671560128 / 3671560192 [postgres]
253,470  5    32322    41.321818815 1349295  X  RA 3671560192 / 3671560320 [postgres]
253,470  5    32323    41.321834643 1349295  X  RA 3671560320 / 3671560448 [postgres]

253,470  5    32344    41.322710758 1349295  C  RA 3671560448 + 32 [0]




253,470 60    38781    42.635500913 1305925  Q   W 3429478432 + 800 [postgres]
253,470 60    38782    42.641351643 1305925  X   W 3429478432 / 3429478528 [postgres]
253,470 60    38783    42.641358534 1305925  X   W 3429478528 / 3429478656 [postgres]
253,470 60    38784    42.641365250 1305925  X   W 3429478656 / 3429478784 [postgres]
253,470 60    38785    42.641372861 1305925  X   W 3429478784 / 3429478912 [postgres]
253,470 60    38786    42.641385225 1305925  X   W 3429478912 / 3429479040 [postgres]
253,470 60    38787    42.641389647 1305925  X   W 3429479040 / 3429479168 [postgres]

253,470 48    22379    42.654440688 19690  C   W 3429479168 + 64 [0]


Create deadio queue and move XPARENTS (if lv device) from staged to deadio, but only
after enough Q & Cs to validate we're dealing with an lv device.  Then do a 1 time 
garbage collection of XPARENTS to deadio to remove likely Q/X orphans off the staged
queue which otherwise is slowing things down.

Also in matchups, if first is an XPARENT then look to see if the 2nd io found, if 
found is pure Q event.  Then this C matches the newest Q not matching the oldest XPARENT
(Q/X) which is likely will never have a matching C event.  Only the last XTARGET only
event is likely to have a C event and even then, sometimes this event never has a C event
which leads us to this case of Q/X/X/X/X/nil and Q'/C' later for the same sector -- the old
code matched C' to the old XTARGET io which is wrong and generates very large Q2C times.

#SEC:    17 wr.max         0.000        0.000      464.145 %100       464.145
#SEC:    18 wr.max         0.000        0.000       72.225 % 99        72.225
#SEC:    19 wr.max         0.000        0.000      143.791 % 99       143.791
#SEC:    20 wr.max         0.000        0.000      128.976 %100       128.976
#SEC:    21 wr.max         0.000        0.000       58.906 %100        58.906
#SEC:    22 wr.max         0.000        0.000       49.375 % 99        49.375
#SEC:    23 wr.max         0.000        0.000       67.605 %100        67.605
#SEC:    24 wr.max         0.000        0.000       58.536 %100        58.536
#SEC:    25 wr.max         0.000        0.000       53.655 % 99        53.655
#SEC:    26 wr.max         0.000        0.000       69.403 %100        69.403
#SEC:    27 wr.max         0.000        0.000       42.235 %100        42.235
#SEC:    28 wr.max         0.000        0.000       55.157 % 99        55.157
#SEC:    29 wr.max         0.000        0.000       36.270 % 99        36.270
#SEC:    30 wr.max         0.000        0.000       46.552 % 99        46.552
#SEC:    31 wr.max         0.000        0.000       39.228 %100        39.228
#SEC:    32 wr.max         0.000        0.000       61.793 %100        61.793
#SEC:    33 wr.max         0.000        0.000       42.362 %100        42.362
#SEC:    34 wr.max         0.000        0.000       67.157 % 99        67.157
#SEC:    35 wr.max         0.000        0.000       58.195 %100        58.195
#SEC:    36 wr.max         0.000        0.000       58.913 % 99        58.913
#SEC:    37 wr.max         0.000        0.000       47.801 % 99        47.801
#SEC:    38 wr.max         0.000        0.000       27.842 %100        27.842
#SUM:    17 wr.max         0.000        0.000      464.145 %100       464.145

*/

/* 
 * X Split bug/behavior:
 *
 * %W[11878]-the following event at [  17790]            22 X     W 201980276200.!:116813800.! has been discarded.
 * 0: [00017791] '  8,96   6     3242    22.305787028 1621409  G   W 201980276200 + 512 [kworker/u18:2]'   ; [06961] detected as orphan event, forced  ghost request creation [0000000000
003810]
 * 
 * Input:
 *  17790   8,96   6     3241    22.305786048 1621409  X   W 201980276200 / 116813800 [kworker/u18:2]
 *  17791   8,96   6     3242    22.305787028 1621409  G   W 201980276200 + 512 [kworker/u18:2]
 *
 * Which spawns a 'G' event for the X split, to calve off part of some original Q/A... but this splinter itself does not have
 * a 'Q/A' event match.  The 'X' event in essence is the Q/A event for this G because it is a splinter.  That is all that is
 * needed here is the X event present, as that becomes the base time *if* the original Q/A was not present (where does X stash
 * that? in one of the special parent links?).
 *
 * In other cases where there are multiple splits, you get a plethora of discards which are false!
 * %W[11878]-the following event at [  17677]            22 X     W 9563074184.!:973140104.! has been discarded.
   0: [00017678] '  8,96   6     3129    22.211758294 1621409  G   W 9563074184 + 512 [kworker/u18:2]'   ; [06961] detected as orphan event, forced  ghost request creation [000000000000
3810]
   0: [00017683] '  8,96   6     3134    22.211763229 1621409  G   W 9563074696 + 408 [kworker/u18:2]'   ; [06961] detected as orphan event, forced  ghost request creation [000000000000
3810]
   0: [00017723] '  8,96   6     3174    22.234271685 1621409  G   W 161811988408 + 512 [kworker/u18:2]'   ; [06961] detected as orphan event, forced  ghost request creation [0000000000
003810]
   0: [00017725] '  8,96   6     3176    22.234274347 1621409  G   W 161811988920 + 472 [kworker/u18:2]'   ; [06961] detected as orphan event, forced  ghost request creation [0000000000
003810]
   0: [00017782] '  8,96   6     3233    22.305771159 1621409  G   W 201980275176 + 512 [kworker/u18:2]'   ; [06961] detected as orphan event, forced  ghost request creation [0000000000
003810]

 * It actually does generate the output, but flags this as [GHOST] when it really is [XSPLIT] and even that shouldn't be labeled as its just another
 * IO after the split.
   3:  4  22.211758294   0.0053      0.005844      0.264408 % 97      0.270252   6  1621409 W     512     9563074184     970777048 [kworker/u18:2]          0   0: [GHOST]
 *
 * So fix the logic to not get upset at splits because a Q/A event is not present!
 *
 * 1st up is the annotation event %W[11878], which is firing becase no event->request is present, that is an io was not attached to the event!  But X split
 * should have generated an io event, so this is bug -- the created io wasn't attached to the event! But it is?!
 *
 * 11627         this->request = split;
 *
 * First note that previously, the size of the split was derived from start/end lba info
 * 253,470 122    14377    17.252122378 1343941  X   W 307342496 / 307342592 [kworker/u291:3]  << size of split is difference, 96 sectors.
 *
 * But now, 4.18.0-348.7.1.el8_5.x86_64 has linear splits and you cannot tell the size of the io until companion G event, aka I cannot
 * update the Q/A event until G event when I know the size being pulled out!
 *
 * Event time an io is split off the original A/Q does it need to be adjusted to reflect what is left?  Do we do that? In the following
 * case the origina A/Q at 201980275176|4096 1st split is 201980275176|512.  Only show the related X/G events 
 *
 *  17779   8,96   6     3230    22.305765444 1621409  A   W 201980275176 + 4096 <- (8,97) 201980273128		<< @512 splits it would take 8 splits.
 *  17780   8,96   6     3231    22.305766136 1621409  Q   W 201980275176 + 4096 [kworker/u18:2]		<< original A/Q
 *
 *  17781   8,96   6     3232    22.305769016 1621409  X   W 201980275176 / 116812776 [kworker/u18:2]		<< 1st split, update Q/A to new LBA+512.
 *  17782   8,96   6     3233    22.305771159 1621409  G   W 201980275176 + 512 [kworker/u18:2]			<< remove 512 from 4096,
 *
 *  17784   8,96   6     3235    22.305773770 1621409  X   W 201980275688 / 116813288 [kworker/u18:2]		<< 2nd split, using udpated LBA+512, again update Q/A +512
 *  									   -116812776 = 512, but only if there is a prior split!
 *  17785   8,96   6     3236    22.305774732 1621409  G   W 201980275688 + 512 [kworker/u18:2]			<< but we only know the new size here!
 *
 *  17790   8,96   6     3241    22.305786048 1621409  X   W 201980276200 / 116813800 [kworker/u18:2]		<< 3rd split
 *  17791   8,96   6     3242    22.305787028 1621409  G   W 201980276200 + 512 [kworker/u18:2]
 *
 *  17796   8,96   6     3247    22.305793749 1621409  X   W 201980276712 / 116814312 [kworker/u18:2]		<< 4th
 *  17797   8,96   6     3248    22.305794319 1621409  G   W 201980276712 + 512 [kworker/u18:2]
 *
 *  17808   8,96   6     3259    22.305807655 1621409  X   W 201980277736 / 116815336 [kworker/u18:2]		<< 5th
 *  17809   8,96   6     3260    22.305808346 1621409  G   W 201980277736 + 512 [kworker/u18:2]
 *
 *  17814   8,96   6     3265    22.305814556 1621409  X   W 201980278248 / 116815848 [kworker/u18:2]		<< 6th
 *  17815   8,96   6     3266    22.305815087 1621409  G   W 201980278248 + 512 [kworker/u18:2]			<< 201980278760
 *
 *  17822   8,96   6     3273    22.305820388 1621409  I   W 201980278248 + 512 [kworker/u18:2]
 *  17823   8,96   6     3274    22.305820975 1621409  D   W 201980278248 + 512 [kworker/u18:2]
 *  17824   8,96   6     3275    22.305823505 1621409  P   N [kworker/u18:2]
 *  17825   8,96   6     3276    22.305918694 1621409  C   W 201980275176 + 512 [0]				<< 1st split completes
 *  17826   8,96   6     3277    22.305927297 1621409  C   W 201980275688 + 512 [0]
 *  17827   8,96   6     3278    22.305933095 1621409  C   W 201980276200 + 512 [0]
 *  17828   8,96   6     3279    22.305969163 1621409  C   W 201980276712 + 512 [0]
 *  17829   8,96   6     3280    22.306007073 1621409  C   W 201980277224 + 512 [0]
 *  17830   8,96   6     3281    22.306045115 1621409  C   W 201980277736 + 512 [0]				<< 6th split completes
 *
 *  17831   8,96   6     3282    22.306066310 1621409  A   W 201980279272 + 4096 <- (8,97) 201980277224		<<!!! this overlaps with the prior write!
 *  17832   8,96   6     3283    22.306066742 1621409  Q   W 201980279272 + 4096 [kworker/u18:2]		<<it covers the 8th and final 512 split of 
 *  17833   8,96   6     3284    22.306068539 1621409  X   W 201980279272 / 116816872 [kworker/u18:2]           <<original io, but this new io seems to shorten
 *  17834   8,96   6     3285    22.306069897 1621409  G   W 201980279272 + 512 [kworker/u18:2]                 <<the prior io by 512 sectors, so all that is left is 512.
 *  														<<and no need to split!
 *  :
 *  17820   8,96   6     3271    22.305820064 1621409  G   W 201980278760 + 512 [kworker/u18:2]			<<!!!! 7th, but no split!!!!  (201980279272)
 *                                                                                                              <<this is meant to tie off the original Q/A
 *                                                                                                              <<as the new overlapping io eliminates the 8th
 *                                                                                                              <<split, basically killing it/removing it from
 *                                                                                                              <<the original write @17779, shortening to so
 *                                                                                                              <<that it only has 512 sectors left so this G
 *                                                                                                              <<is tied to the original 17779 A/Q event. this
 *                                                                                                              <<is way new behavior, prior the writes just
 *                                                                                                              <<either clobbered each other or a barrier was
 *                                                                                                              <<dropped in, but now it appears new writes can
 *                                                                                                              <<remove lba from prior writes! ugh.
 *
 *
 *
 */

/* 
 * Notes on X splits
 * The two types
 * 1.  253,470 122    14377    17.252122378 1343941  X   W    307342496 / 307342592 [kworker/u291:3]  << size of difference between these to numbers.	
 * 2.    8,96    6     3241    22.305786048 1621409  X   W 201980276200 / 116813800 [kworker/u18:2]   << size is unknown until 'G' event, diff ref bases	
 *
 * 1. is what we found before, parents can only be split once, its splitting off length of the io from the tail of the io, each prior parent becomes
 *    immediately available to be sent to storage (in order), cascaded splits, size can be determined at X split event time. The parent changes with
 *    each cascading split (main A/Q io, then 1st split is parent to 2nd split, etc.)
 * 2. is what we found in 348 kenrel, there is just 1 parent, the original A/Q io, it can be split multiple times, splits are from the top of the parent
 *    io, the parent is the same for all splits, linear not cascading.  The **hard part** is we DO NOT KNOW the event io size that is being split off
 *    until later G event time -- although current guess is 512.  The reason is that type 2 uses two different reference bases for start/ending sector.
 *    Whereas in type #1 its ending sector (2nd number) - starting sector (1st number) = length... there is no equivalent caclucation that can be performed
 *    in the type #2 case.  We workaround this issue for 2nd thru Nth split by taking current 2nd number - previous 2nd number to get a size.  But that
 *    leaves the 1st split in limbo and assumes that slips are a linear front to back peel of the the original A/Q io parent.  That the linear order must
 *    be guaranteed -- shaky logic at best.
 */

/* Notes on Orphan Barriers
 *

#Maj,Mn CPU   SeqNo     Seconds     PID  Evt Typ Sector   +Len Description
#------ --- ------- --------------- -----|--|---|---------+--- -------------------------------------
  8,0    4        1     0.000000000     0  C   R 42697760 + 1024 [0]
  8,0    4        2     0.008045318     0  C   R 42700832 + 1024 [0]
  8,0    4        3     0.034376765     0  C   R 42696736 + 1024 [0]
  8,0    4        4     0.041379390     0  C   R 42698784 + 1024 [0]
  8,0    4        5     0.115868632     0  C   R 42702880 + 1024 [0]
  8,0    4        6     0.201348853     0  C   R 42701856 + 1024 [0]
  8,3    2        1     0.497802786  2645  A  WS 106374072 + 8 <- (253,10) 8698808
  8,0    2        2     0.497802886  2645  A  WS 108723128 + 8 <- (8,3) 106374072
  8,0    2        3     0.497803987  2645  Q  WS 108723128 + 8 [jbd2/dm-10-8]
  8,0    2        4     0.497805587  2645  G  WS 108723128 + 8 [jbd2/dm-10-8]
  8,0    2        5     0.497805887  2645  P   N [jbd2/dm-10-8]
  8,3    2        6     0.497807187  2645  A  WS 106374080 + 8 <- (253,10) 8698816
  8,0    2        7     0.497807287  2645  A  WS 108723136 + 8 <- (8,3) 106374080
  8,0    2        8     0.497807487  2645  Q  WS 108723136 + 8 [jbd2/dm-10-8]
  8,0    2        9     0.497808187  2645  M  WS 108723136 + 8 [jbd2/dm-10-8]
  8,0    2       10     0.497809187  2645  I  WS 108723128 + 16 [jbd2/dm-10-8]
  8,0    2       11     0.497809687  2645  U   N [jbd2/dm-10-8] 1
  8,0    2       12     0.497809987  2645  D  WS 108723128 + 16 [jbd2/dm-10-8]
  8,0    2       13     0.530513903     0  C  WS 108723128 + 16 [0]
  8,3    2       14     0.530536705  2645  A FWS 0 + 0 <- (253,10) 0 <----- this! ------------+
  8,0    2       15     0.530537205  2645  Q FWS [jbd2/dm-10-8]
  8,0    2       16     0.530538005  2645  G FWS [jbd2/dm-10-8]
  8,0    2       17     0.530538605  2645  I FWS [jbd2/dm-10-8]
  8,0    0        1     0.531892926     0  C  WS 0 [0]  <---------- this is a completion of --+

Will generate:

 %W[07170]-orphan 'C'ompletion event discarded: '  8,0    4        1     0.000000000     0  C   R 42697760 + 1024 [0]'
 %W[07170]-orphan 'C'ompletion event discarded: '  8,0    4        2     0.008045318     0  C   R 42700832 + 1024 [0]'
 %W[07170]-orphan 'C'ompletion event discarded: '  8,0    4        3     0.034376765     0  C   R 42696736 + 1024 [0]'
 %W[07170]-orphan 'C'ompletion event discarded: '  8,0    4        4     0.041379390     0  C   R 42698784 + 1024 [0]'
 %W[07170]-orphan 'C'ompletion event discarded: '  8,0    4        5     0.115868632     0  C   R 42702880 + 1024 [0]'
 %W[07170]-orphan 'C'ompletion event discarded: '  8,0    4        6     0.201348853     0  C   R 42701856 + 1024 [0]'
 %W[07170]-orphan 'C'ompletion event discarded: '  8,0    0        1     0.531892926     0  C  WS 0 [0]'

   1:  1   0.497802786   0.0064      0.007201     32.703916 % 99     32.711117   2     2645 WS     16      108723128             0 [jbd2/dm-10-8]           0   2:  8,  8.
   1:  1   0.531907827   0.0027      0.003301      1.152402 % 99      1.155703   0        4 WFS     8      108723144             0 [kworker/0:0]            0   0

We'd rather create a fake completion event for these types of barriers? Wait. What. hmmm, this isn't an orphan at all!
There is a (F)WS event present, but we cannot match on it because FWS != WS.  Detect a barrier completion (WS 0:{0} in this 
case as there is no specified length, we can infer if sector 0 and WS then length = 0 even if one isn't supplied.  super
special case.  Then we can't match WS -> FWS, but because FWS is 0:0 then match that. ugh. dang it!

*/

/* ==================================================================================================================================== */
/* ------------------------------------------------------------------------------------------------------------------------------------ */
    /* See FN.101 on bug with F/M merging                                                          */

    /* The following is a case where the 'M' event is for an io [B] that is already on As in:
      *  8,16  14     3570     7.158122890 20830  A   W 1494200944 + 8 <- (8,21) 1449157232    IO [A]
      *  8,16  14     3571     7.158123134 20830  Q   W 1494200944 + 8 [kworker/u32:4]
      *  8,16  14     3572     7.158124053 20830  G   W 1494200944 + 8 [kworker/u32:4]         << move to active/mainio
      *
      *  8,16  14     3573     7.158125551 20830  A   W 1494200960 + 8 <- (8,21) 1449157248    IO [B]
      *  8,16  14     3574     7.158125783 20830  Q   W 1494200960 + 8 [kworker/u32:4]
      *  8,16  14     3575     7.158126522 20830  G   W 1494200960 + 8 [kworker/u32:4]         << move to active/mainio
      *
      *  8,16  14     3576     7.158127848 20830  A   W 1494200952 + 8 <- (8,21) 1449157240   
      *  8,16  14     3577     7.158128095 20830  Q   W 1494200952 + 8 [kworker/u32:4]
      *  8,16  14     3578     7.158128325 20830  F   W 1494200952 + 8 [kworker/u32:4]         Fmerge C -> [B] on mainio
      *
      *  8,16  14     3588     7.158149960 20830  I   W 1494200944 + 8 [kworker/u32:4]         Insert [A]
      *  8,16  14     3589     7.158150367 20830  M   W 1494200952 + 16 [kworker/u32:4]        Bmerge [B] -> [A], both on mainio!
      *
      *  8,16  14     3593     7.158156020 20830  D   W 1494200944 + 24 [kworker/u32:4]
      *  8,16  14     3597     7.158238587 26245  C   W 1494200944 + 24 [0]
      *

So what is happening on 'M' time is this:

--bgn:000028-----------------------------------------      0:       5
  8,16  14     3589     7.158150367 20830  M   W 1494200952 + 16 [kworker/u32:4]
DBG[03107]: verify_staged_list(ok:0)
DBG[03108]: verify_mainio_list
DBG[03108]: verify_mainio_list(ok:5)
%W[07040]-could not find 'main' io request to bmerge           1494200952:      16 into @  8,16  14     3589     7.158150367 20830  M   W 1494200952 + 16 [kworker/u32:4], line=28 (limit=400), Qevents=7 (limit=200) [near bgn file|event]
DBG[12225]: annotate_event() - event discarded, no assigned request context
DBG[12239]: annotate_event() - event->io block <nil>, but event flag DISCARDED not set?
  8,16  14     3589     7.158150367 20830  M   W 1494200952 + 16 [kworker/u32:4]               ;#U-1
DBG[07189]: create ghost, trigger is 'M' event: '  8,16  14     3589     7.158150367 20830  M   W 1494200952 + 16 [kworker/u32:4]'
DBG[12344]:                create_io(M W      1494200952+16 '[kworker/u32:4]')
DBG[12592]:               add_staged(0xd0b820 ; M W      1494200952+16 '[kworker/u32:4]') (nil)
>>
>> we **should not** be creating a ghost. 
>>
>> the issue is this event:
      *  8,16  14     3589     7.158150367 20830  M   W 1494200952 + 16 [kworker/u32:4]        Bmerge [B] -> [A], both on mainio!
>> logic says, find the io context this merge is associated with on the staging queue, but ...952 was merged onto an io on the mainio queue
>> already and removed from the staging queue.  This is the 2nd merge on this io post a previous merge!  So while 99.9% of the time
>> 'this' io context for the merge io portion itself is on the staged queue, in this specific corner case it is not -- its on the mainio
>> queue.  This only will happen in these types of merging where a front merge happens to fill in a hole between two io.  At Insert time
>> of the prio ...944 io a merge check is performed.  "Is there any io currently active which can be back merged onto this io?"  The 
>> answer has been no up until now which mdraid raid1/mirror io.  The io must be submitted out of sequence but close enough that a F/B
>> merge "heals" the difference between out of order io.  So in this one case, we cannot depend on just looking on the staging queue for
>> a context! ugh.

*/

/* ==================================================================================================================================== */
/* ------------------------------------------------------------------------------------------------------------------------------------ */
/* FN.102 - remap bug https://bugzilla.redhat.com/show_bug.cgi?id=2095524 -- wrong target shown in remap events
 *
 *                             +----- this should be '21' as next remap is same sector remap from 8,21
 *                             V
 *                           8,16   7      389     1.013926459  1167  A   W 1449157120 + 8 <- (9,2) 1448892928
 *                           8,16   7      400     1.013984003  1167  A   W 1494200832 + 8 <- (8,21) 1449157120

Turning on flag_remap_bug flag will turn on logic to ignore the minor device matching part of the remap algorithm.
So that should, in theory, match 1449157120 8,16 to (8,21) 1449157120 in 2nd event.  Add a short time limit to
when that matching is value also, maybe 5ms or so to start as back to back remaps should happen quickly in time.

*/

/* 
 *
 
BUG: best match chooses the wrong one because it discounts optional events.

So search_mainio1() notes that it found two matches....
DBG[05485]: active            0x11a56c0[   0] ->    0x11a4e00    8, 80   2.87580453 'A'      R AQ.G.......,00 3:            2240,    32 000004 merges=   0 requeues=   0 sleeps=   0
DBG[05485]: active            0x115eb30[ 123] ->    0x115e2c0    8, 80   2.74996052 'A'      R AQS........,00 3:            2240,    32 000004 merges=   0 requeues=   0 sleeps=   1

Which leads to a call to best_match().

DBG[18011]: best_match(I,io=0x11a56c0,temp=0x115eb30)
DBG[18174]: io R:        2240.000032 has been marked SAMEIOSCHED
DBG[18179]: io R:        2240.000032 has been marked SAMEIOSCHED
DBG[18474]: [  2.875807831] I R ; io 01 0023: temp 01 0013; debug_mask 0400 (event not present)
DBG[18494]: io      0x11a56c0 (requeues=0)
DBG[18495]: io mask 0023 AQ.G.... ->event_mask
DBG[18496]: allowed 0033 AQSG....   event_mask
DBG[18497]: options FFCE A.SG....   optional (removal mask)  >>> the 'G' is an "important" optional event.
DBG[18498]: remains 0002 .Q......   after removing optional
DBG[18499]: require 0002 .Q......   required mask
DBG[18500]: results 0000            (must be zero)           << this is best match for I event.
DBG[18527]: temp    0x115eb30
DBG[18528]: temp    0x115eb30 (requeues=0)
DBG[18529]: io mask 0013 AQS..... ->event_mask
DBG[18530]: allowed 0033 AQSG....   event_mask
DBG[18531]: options FFCE A.SG....   optional (removal mask)
DBG[18532]: remains 0002 .Q......   after removing optional
DBG[18533]: require 0002 .Q......   required mask
DBG[18534]: results 0000            (must be zero)           << but so it this one as 'G' is optional, but if present it changes the logic!!!!

DBG[18552]: [  2.875807831] I R ; io 03 0023: temp 03 0013; event_mask 0033 0033 (pre-reqs present )
DBG[18598]: [  2.875807831] I R ; io 07    R: temp 07    R (expecting 07 xxxx for qualification)
DBG[18607]: best_match() both context fully qualified, choosing oldest by time (or SeqNo if tied)
DBG[18644]: best_match(), choose 'temp' (oldest) 0x115eb30 [  2.749960522] A R
DBG[18645]:                        'io' (newest) 0x11a56c0 [  2.875804531] A R

So this is a case were previous optional events, G in this case, is present in one but not the other but
the logic "hides" this from the matching logic.  So we need yet another mask requests, optional events 
results mask... if one event HAS the optional events but the other does not, then the one WITH the optional
events is a "better" match otherwise we're open to exactly this type of issue.

We need to track "important" optional events and elevate those that how that important optional event as a "better"/best
choice between otherwise like events.




18794:  8,80  13       99     2.749960522 228793  A   R 2240 + 32 <- (253,4) 192
18795:  8,80  13      100     2.749961122 228793  Q   R 2240 + 32 [ora_lgwr_slsimp]
18796:  8,80  13      101     2.749962422 228793  S   R 2240 + 32 [ora_lgwr_slsimp]

19739:  8,80   8      221     2.875804531 229679  A   R 2240 + 32 <- (253,4) 192                << 2nd read from disk from same location!
19740:  8,80   8      222     2.875805031 229679  Q   R 2240 + 32 [oracle_229679_s]
19741:  8,80   8      223     2.875806731 229679  G   R 2240 + 32 [oracle_229679_s]             << this appears to be on 2nd IO, but program likely
19743:  8,80   8      225     2.875807831 229679  I   R 2240 + 32 [oracle_229679_s]             << tagged it to first io which went to sleep!

19745:  8,80   8      227     2.875808531 229679  D   R 2240 + 32 [oracle_229679_s]             << this Dispatch again is likely 2nd io, but we
                                                                                                << tagged first match for G on 1st io, so this D will
                                                                                                << follow that, find 1st io with G,I events allowing a D

19838:  8,80  13      122     2.879091147 228793  G   R 2240 + 32 [ora_lgwr_slsimp]             << and 2nd G event but finds 1st io already has G from above!
                                                                                                << and dies in assert();
19840:  8,80  13      124     2.879092547 228793  I   R 2240 + 32 [ora_lgwr_slsimp]
19842:  8,80  13      126     2.879093347 228793  D   R 2240 + 32 [ora_lgwr_slsimp]             << 2nd instance dispatched.

20826:  8,80  13      128     3.003693651 108019  A   R 2240 + 32 <- (253,4) 192                << 3rd! read from same 2240 sector so now 3 read to same/same
                                                                                                << simultaneously!
20827:  8,80  13      129     3.003694451 108019  Q   R 2240 + 32 [oracle_108019_s]             << Q this latest
20828:  8,80  13      130     3.003696351 108019  S   R 2240 + 32 [oracle_108019_s]             << I this latest
20849:  8,80   8      240     3.012182092     0  C   R 2240 + 32 [0]                            << 1st completion on 2240
20898:  8,80  13      135     3.016175711     0  C   R 2240 + 32 [0]                            << 2nd completion on 2240 as both have 'D' events now.
                                                                                                << but 3rd io to 2240 still outstanding.

So bottom line is, if we get into a GSegNo != 0 place, then we need to assume that just maybe
there is another io context available in the staging queue that is same sect:len and does not
yet have a G event.



*/

/*
 
x360 blktrace has only A,D,C events:

But this results in D events, which only search the main io queue, to fail to find a match as there is no event that pushing
the io from the staging queue to the main queue as there normally would be.

--bgn:000004-----------------------------------------      1:       0
  8,16   4        2     0.000001220   253  D  WS 1653056 + 8 [kworker/4:1H]
DBG[03263]: verify_staged_list(ok:1)
DBG[03264]: verify_mainio_list
DBG[03264]: verify_mainio_list(ok:0)
DBG[07722]: mainio list[    0]  check for    1653056:     8 match for dispatch  ...
DBG[06888]: check_2ndhand_merging(   1653056:     8)
DBG[06907]: mainio list[    0]  check for    1653056:     8...(base)
DBG[06946]: <eol>
DBG[06947]: no matching base io @starting sector 01653056:     8, return null.
%W[07213]-could not find 'main' io request to dispatch            1653056:       8 into @  8,16   4        2     0.000001220   253  D  WS 1653056 + 8 [kworker/4:1H], line=4 (limit=400), Qevents=0 (limit=200) [near bgn file|event]
DBG[12705]: annotate_event() - event discarded, no assigned request context
DBG[12719]: annotate_event() - event->io block <nil>, but event flag DISCARDED not set?
  8,16   4        2     0.000001220   253  D  WS 1653056 + 8 [kworker/4:1H]                       ;#U0
DBG[07407]: create ghost, trigger is 'D' event: '  8,16   4        2     0.000001220   253  D  WS 1653056 + 8 [kworker/4:1H]'
DBG[12841]:                create_io(D WS     1653056+8 '[kworker/4:1H]')
DBG[13139]:              mov_mainio (0xce1510 D WS     1653056+8 '[kworker/4:1H]') <= move ghost io mainio list
DBG[13145]: verify_mainio_list
DBG[13145]: verify_mainio_list(ok:0)

But its even worse.  The 'A' event did create a staging queue entry... that gets orphaned and never matched.
So the ghost create is on the main io queue where 'C' matches up later and removes -- but the staging queue
ends up with 100s of io sitting there unmatched.

So, A|Q events create staged io context.  S,G,I all would move the io to the main queue as sleeping for a request implied
it needs a request, G obviously gets a request and I inserts the request.  So that leaves either D or C events that could
be a problem.  

Lets only tackle D events for now, having event sequences of just A,C seem really odd to have to deal with so lets postpone
that battle for later.

#Maj,Mn CPU   SeqNo     Seconds     PID  Evt Typ Sector   +Len Description
#------ --- ------- --------------- -----|--|---|---------+--- -------------------------------------
  8,16   4        1     0.000000000   253  A   W 1653056 + 8 <- (253,0) 1653056
  8,16   4        2     0.000001220   253  D  WS 1653056 + 8 [kworker/4:1H]
  8,16   1        2     0.000298441  6665  C  WS 1653056 + 8 [0]
  8,16   1        3     0.059992784   212  A   W 1653056 + 8 <- (253,0) 1653056
  8,16   1        4     0.059993740   212  D  WS 1653056 + 8 [kworker/1:1H]
  8,16   5        2     0.060204359  6664  C  WS 1653056 + 8 [0]
  8,16   6        1     0.110029468   255  A   W 1653056 + 8 <- (253,0) 1653056
  8,16   6        2     0.110030202   255  D  WS 1653056 + 8 [kworker/6:1H]
  8,16   0        2     0.110213562  6660  C  WS 1653056 + 8 [0]
  8,16   6        3     0.180040597   255  A   W 1653056 + 8 <- (253,0) 1653056
  8,16   6        4     0.180041963   255  D  WS 1653056 + 8 [kworker/6:1H]
  8,16   0        4     0.180377324  6660  C  WS 1653056 + 8 [0]

#PS|Prg:Flt   Queue(s)     Q2I(ms)   Q2D(ms)       D2C(ms)            Q2C(ms)     
#--|---:--- ------------- -------- ------------- -------------+---- ------------- 
  1|   0:  1   0.000001220   0.0000      0.000000      0.297221 %100      0.297221   4      253 WS      8        1653056       1653056 [kworker/4:1H]           0   0: [GHOST]
  2|   0:  1   0.059993740   0.0000      0.000000      0.210619 %100      0.210619   1      212 WS      8        1653056       1653056 [kworker/1:1H]           0   0: [GHOST]
  3|   0:  1   0.110030202   0.0000      0.000000      0.183360 %100      0.183360   6      255 WS      8        1653056       1653056 [kworker/6:1H]           0   0: [GHOST]
  4|   0:  1   0.180041963   0.0000      0.000000      0.335361 %100      0.335361   6      255 WS      8        1653056       1653056 [kworker/6:1H]           0   0: [GHOST]
  5|   0:  1   0.239987574   0.0000      0.000000      0.191068 %100      0.191068   6      255 WS      8        1653056       1653056 [kworker/6:1H]     

Pay attention to the PS (pre-stage queue depth), its just going up and up.  Clearly showing these pre-stage
io context are getting unmatched and abandoned.

...so in D if it doesn't find the io on the main io queue, search the staging queue, but only look at
io context that have A and !Q events and only if the conf_x360_policy != 0 and only if the Q event
count is zero.  That should be enough caveats to focus just on A,D,C sequences we're seeing here.
We may need to rethink the logic, but I want it as narrowly focused as possible.

Essentially, we need to pick up part of the 'I'nsert logic to scan the pre-stage queue in a new and
different/very specific manner.

*/

/* 
 * Bug with x-splits
 *

#Maj,Mn CPU   SeqNo     Seconds     PID  Evt Typ Sector   +Len Description
#------ --- ------- --------------- -----|--|---|---------+--- -------------------------------------
  8,16  11       12     0.095032260 942852  A   W 961742848 + 4096 <- (8,17) 961740800    [A.0]
  8,16  11       13     0.095033587 942852  Q   W 961742848 + 4096 [kworker/u32:4]
  8,16  11       14     0.095038620 942852  X   W 961742848 / 961743872 [kworker/u32:4]   [A.0,1] len=orig-new 961743872-961742848 = 1024 left=orig-new 4096-1024
  8,16  11       15     0.095040118 942852  G   W 961742848 + 1024 [kworker/u32:4]        [A.0] which now has a length of 1024 as x-split changes A.0 size.
  8,16  11       16     0.095040952 942852  U   N [kworker/u32:4] 1
  8,16  11       17     0.095042902 942852  D   W 961741824 + 1024 [kworker/u32:4]
  8,16  11       18     0.095051462 942852  P   N [kworker/u32:4]
  8,16  11       19     0.095055397 942852  X   W 961743872 / 961744896 [kworker/u32:4]	  [A.1,2] 1024 again
  8,16  11       20     0.095055958 942852  G   W 961743872 + 1024 [kworker/u32:4]        [A.1]   1024 new size from original of 4096-1024.
  8,16  11       21     0.095056155 942852  U   N [kworker/u32:4] 1
  8,16  11       22     0.095056665 942852  D   W 961742848 + 1024 [kworker/u32:4]
  8,16  11       23     0.095063000 942852  P   N [kworker/u32:4]
  8,16  11       24     0.095066629 942852  X   W 961744896 / 961745920 [kworker/u32:4]   [A.2,3]
  8,16  11       25     0.095067166 942852  G   W 961744896 + 1024 [kworker/u32:4]
  8,16  11       26     0.095067352 942852  U   N [kworker/u32:4] 1
  8,16  11       27     0.095067905 942852  D   W 961743872 + 1024 [kworker/u32:4]        [A.2]
  8,16  11       28     0.095074246 942852  P   N [kworker/u32:4]
  8,16  11       29     0.095077441 942852  G   W 961745920 + 1024 [kworker/u32:4]
  8,16  11       30     0.095077631 942852  U   N [kworker/u32:4] 1
  8,16  11       31     0.095078274 942852  D   W 961744896 + 1024 [kworker/u32:4]	  [A.3] for 1 4096 sized io is broken into 4 sub-io of 1024 each.
  8,16  11       32     0.095084429 942852  P   N [kworker/u32:4]

#PS|Prg :Flt   Queue(s)     Q2I(ms)   Q2D(ms)       D2C(ms)            Q2C(ms)     CPU      PID Typ  Size         Sector         Seek  Description            reQ Merges:sectors,...
#--|----:--- ------------- -------- ------------- -------------+---- ------------- --- -------- ---- ---- -------------- ------------- ---------------------- --- ---:-----------------
  0|   0:  1   0.094077484   -.----      0.017833      0.756004 % 97      0.773837  11   942852 W    1024      961739776     961739776 [kworker/u32:4]          0   0: [GHOST]  
  2|   0:  1   0.094090857   -.----      0.024223      0.973155 % 97      0.997378  11   942852 W    1024      961740800     961740800 [kworker/u32:4]          0   0: [GHOST]  
  8|   0:  1   0.094114143   -.----      0.928759      1.710709 % 64      2.639468  11   942852 W    1024      961741824     961741824 [kworker/u32:4]          0   0: [GHOST]  
  8|   0:  1   0.095040118   -.----      0.016547      2.102129 % 99      2.118676  11   942852 W    1024      961742848     961742848 [kworker/u32:4]          0   0: [GHOST]  
  8|   0:  1   0.095055958   -.----      0.011947      2.093064 % 99      2.105011  11   942852 W    1024      961743872     961743872 [kworker/u32:4]          0   0: [GHOST]  
 10|   0:  1   0.095067166   -.----      0.011108      2.609565 % 99      2.620673  11   942852 W    1024      961744896     961744896 [kworker/u32:4]          0   0: [GHOST]  
 12|   0:  1   0.095077441   -.----      0.431610      2.652923 % 86      3.084533  11   942852 W    1024      961745920     961745920 [kworker/u32:4]          0   0: [GHOST]  

But we can see we're accumulating pre-staged io and there is no I event which maybe triggering the [GHOST].  This could be another example of requiring an I
event that doesn't exist, but there is a G event that in this specific foot print instance should be used as a I event.... at least until any I events show
up.  But they do later on when we don't have to split incoming io!  grrrr.

Note: these lengths look incorrect, 1023 should be 1024! is this a simple math error we're only noticing now?

#===== Stage Queue:     56 Remaining ================================================================
 56|   0:  1   0.095032260   -.----      -.------     -.------- % --      0.000000  11   942852 W    3073      961743871             0 [kworker/u32:4]          0   0
 56|   0:  1   0.095032260   -.----      -.------     -.------- % --      0.000000  11   942852 W    1023      961742848         -4096 [kworker/u32:4]          0   0
 56|   0:  1   0.095502263   -.----      -.------     -.------- % --      0.000000  11   942852 W    3073      961747967          4096 [kworker/u32:4]          0   0
 56|   0:  1   0.095502263   -.----      -.------     -.------- % --      0.000000  11   942852 W    1023      961746944         -4096 [kworker/u32:4]          0   0
 56|   0:  1   0.095982630   -.----      -.------     -.------- % --      0.000000  11   942852 W    3073      961752063          4096 [kworker/u32:4]          0   0
 56|   0:  1   0.095982630   -.----      -.------     -.------- % --      0.000000  11   942852 W    1023      961751040         -4096 [kworker/u32:4]          0   0
 56|   0:  1   0.096465435   -.----      -.------     -.------- % --      0.000000  11   942852 W    3073      961756159          4096 [kworker/u32:4]          0   0
 56|   0:  1   0.096465435   -.----      -.------     -.------- % --      0.000000  11   942852 W    1023      961755136         -4096 [kworker/u32:4]          0   0
 56|   0:  1   0.097456705   -.----      -.------     -.------- % --      0.000000  11   942852 W    3073      961760255          4096 [kworker/u32:4]          0   0
 56|   0:  1   0.097456705   -.----      -.------     -.------- % --      0.000000  11   942852 W    1023      961759232         -4096 [kworker/u32:4]          0   0
 56|   0:  1   0.097944239   -.----      -.------     -.------- % --      0.000000  11   942852 W    3073      961764351          4096 [kworker/u32:4]          0   0


  8,16  10    21131    43.102475252 921954  A   W 1011116032 + 4096 <- (8,17) 1011113984
  8,16  10    21132    43.102475593 921954  Q   W 1011116032 + 4096 [kworker/u32:2]
  8,16  10    21133    43.102483479 921954  X   W 1011116032 / 1011118080 [kworker/u32:2]
  8,16  10    21134    43.102484286 921954  G   W 1011116032 + 2048 [kworker/u32:2]
  8,16  10    21139    43.102503402 921954  I   W 1011116032 + 2048 [kworker/u32:2]
  8,16  10    21140    43.102512206    476  D   W 1011116032 + 2048 [kworker/10:1H]
  8,16   1    20617    43.141485352     20  C   W 1011116032 + 2048 [0]
  8,16  10    21141    43.141495002 921954  G   W 1011118080 + 2048 [kworker/u32:2]
  8,16  10    21143    43.141842210 921954  A   W 1011120128 + 4096 <- (8,17) 1011118080
  8,16  10    21148    43.141857119 921954  D   W 1011118080 + 2048 [kworker/u32:2]
  8,16   1    20618    43.144817038      0  C   W 1011118080 + 2048 [0]

This was just a two-way split is that why there is an Insert seen?  Hating inconsistent event train right now.


So this is even worse in that its a SPLIT and has an Insert that others typically do not have.  Making it difficult to says a X,G = Insert ... except maybe in
the case where you get to D and have X,G but no I.  But I still don't know if that is what is causing the ghost and why are we accumulating pre-staged io like above?

1) add an assert() that any io with an X event in its past **CANNOT** have either a F/M merge event.  I guess its possible that a split
   might be applied not to reduce size but to align it with the disk quanta of some type and a fragment of that split might then be 
   able to merge onto a previous io in the next or previous disk quanta.  But that just does not seem highly likely so lets guard our
   logic/understanding of the event train and prohibit that for now since we may, probably, make design decisions on that understanding.

Sizing error noted here:

  8,16  11       14     0.095038620 942852  X   W 961742848 / 961743872 [kworker/u32:4]
DBG[03299]: verify_staged_list(ok:1)
DBG[03300]: verify_mainio_list
DBG[03300]: verify_mainio_list(ok:0)
DBG[12458]: split_event(this:961742848,split:961743872)
DBG[12463]: split_event(961742848:1024,961743872:<remainder>)
DBG[07693]: stage list    961742848:      4096 0x16e1c90 | [00000003]   0.095032260 A    W
DBG[07697]: stage list    961742848:      4096 0x16e1c90 matched!
DBG[07709]: stage list  961742848:  4096 0x16e1c90 passed filters!
DBG[07714]: stage list  0x16e1c90  961742848:  4096... <= 1st hit
DBG[07743]: stage list  0x16e1c90 returned.
DBG[12471]: found event for X Split [     5] 961742848 => 961742848 : 4096
DBG[12605]: found X split 961742848/961743872 found target: 961742848,4096
DBG[12607]: existing io   961742848,4096 0x16e1c90
DBG[12608]: adjusted io   961743871,3073 0x16e1c90      << wrong! should be 4096 - 1024 or 3072! and the primary/1st io should be length of 1024.

DBG[12616]: io->info 0x16e1ff0  split->info 0x16e2860
DBG[12617]: split    io   961743872,3073 0x16e2500
DBG[12618]: io 0x16e2500 GSeqNo 0 (split)
DBG[12637]: orig.2   io   961743871,3073 0x16e1c90
DBG[12638]: split    io   961742848,1023 0x16e2500      << wrong!

Ok, the majority of this was bad math

	    if (((evt_length = (end_sector - bgn_sector)+1) < 0) || (evt_length > MAX_IO_SIZE))

*/

/*
 * Still issues with data set, accumulating pre-stage orphans for some reason.
 *

  0|  37: 36   0.095982630   -.----      0.489461      5.674879 % 92      6.164340  11   942852 W    1024      961754112             0 [kworker/u32:4]          0   0
  1|  38: 36   0.096465435   -.----      0.018504      6.188004 % 99      6.206508  11   942852 W    1024      961755136             0 [kworker/u32:4]          0   0
  1|  37: 36   0.096465435   -.----      0.030237      6.178692 % 99      6.208929  11   942852 W    1024      961756160             0 [kworker/u32:4]          0   0
  0|  42: 41   0.096465435   -.----      0.041038      6.882905 % 99      6.923943  11   942852 W    1024      961757184             0 [kworker/u32:4]          0   0
  2|  95: 95   0.096465435   -.----      0.999357     34.614152 % 97     35.613509  11   942852 W    1024      961758208             0 [kworker/u32:4]          0   0
  2|  94: 94   0.097456705   -.----      0.032706     34.948757 % 99     34.981463  11   942852 W    1024      961760256          1024 [kworker/u32:4]          0   0
  2|  93: 93   0.097456705   -.----      0.021186     34.963450 % 99     34.984636  11   942852 W    1024      961759232         -2048 [kworker/u32:4]          0   0
  2|  92: 92   0.097456705   -.----      0.042819    108.455465 % 99    108.498284  11   942852 W    1024      961761280          1024 [kworker/u32:4]          0   0
  2|  91: 91   0.097944239   -.----      0.021664    108.312415 % 99    108.334079  11   942852 W    1024      961763328          1024 [kworker/u32:4]          0   0
  2|  90: 90   0.097456705   -.----      0.494672    111.823798 % 99    112.318470  11   942852 W    1024      961762304         -2048 [kworker/u32:4]          0   0
  2|  89: 89   0.097944239   -.----      0.035679    112.686214 % 99    112.721893  11   942852 W    1024      961764352          1024 [kworker/u32:4]          0   0
  2|  88: 88   0.097944239   -.----      0.046424    113.390751 % 99    113.437175  11   942852 W    1024      961765376             0 [kworker/u32:4]          0   0
  2|  87: 87   0.097944239   -.----      0.590819    112.848884 % 99    113.439703  11   942852 W    1024      961766400             0 [kworker/u32:4]          0   0

 14|  83: 83   8.295188520   -.----      0.035661    440.986170 % 99    441.021831  10   942852 W    2032      965398376             0 [kworker/u32:4]          0   0
 14|  82: 82   8.295687261   -.----      0.495615    440.281140 % 99    440.776755  10   942852 W     376      965404296          3888 [kworker/u32:4]          0   0
 14|  81: 81   8.295687261   -.----      0.030208    482.451917 % 99    482.482125  10   942852 W    1720      965402576         -2096 [kworker/u32:4]          0   0
 14|  80: 80   8.296174178   -.----      0.021421    481.980975 % 99    482.002396  10   942852 W    1904      965404672           376 [kworker/u32:4]          0   0
 14|  79: 79   8.296174178   -.----      0.553231    482.035327 % 99    482.588558  10   942852 W     168      965408600          2024 [kworker/u32:4]          0   0
 14|  78: 78   8.295687261   -.----      0.019068    483.058167 % 99    483.077235  10   942852 W    2000      965400576         -8192 [kworker/u32:4]          0   0
 14|  77: 77   8.296174178   -.----      0.033675    483.298154 % 99    483.331829  10   942852 W    2024      965406576          4000 [kworker/u32:4]          0   0

 20| 154:154   8.304890511   -.----      0.016757    606.553152 % 99    606.569909  10   942852 W    1368      965470208         -8192 [kworker/u32:4]          0   0
 20| 153:153   8.302834266   -.----      0.031827    611.069785 % 99    611.101612  10   942852 W    2048      965455864        -15712 [kworker/u32:4]          0   0
 20| 152:152   8.304459200   -.----      0.019929    609.703866 % 99    609.723795  10   942852 W    2040      965466112          8200 [kworker/u32:4]          0   0
 20| 151:151   8.303246596   -.----      0.018361    610.920777 % 99    610.939138  10   942852 W    2040      965457920        -10232 [kworker/u32:4]          0   0
 20| 150:150   8.304890511   -.----      0.027765    610.640430 % 99    610.668195  10   942852 W    1880      965471576         11616 [kworker/u32:4]          0   0
 20| 149:149   8.306127991   -.----      0.433121    609.271932 % 99    609.705053  10   942852 W     472      965482024          8568 [kworker/u32:4]          0   0
 20| 148:148   8.303246596   -.----      0.028310    612.560381 % 99    612.588691  10   942852 W    2048      965459960        -22536 [kworker/u32:4]          0   0
 20| 147:147   8.304045275   -.----      0.020459    612.055330 % 99    612.075789  10   942852 W    2040      965462016             8 [kworker/u32:4]          0   0

108| 102:102  10.812634578   -.----      0.024063    192.019400 % 99    192.043463  10   942852 W    2040      966346752       -177632 [kworker/u32:4]          0   0
108| 101:101  10.816003326   -.----      0.023911    212.615223 % 99    212.639134  10   942852 W    2040      966375424         26632 [kworker/u32:4]          0   0
108| 100:100  10.823876602   -.----      0.023267    205.946126 % 99    205.969393  10   942852 W    2040      966445056         67592 [kworker/u32:4]          0   0
108|  99: 99  10.971474479   -.----      0.368127     58.516322 % 99     58.884449  10   942852 W       8      966531064         83968 [kworker/u32:4]          0   0
108|  98: 98  10.972167387   -.----      0.423786     57.768948 % 99     58.192734  10   942852 W       8      966539256          8184 [kworker/u32:4]          0   0
108|  97: 97  10.971826203   -.----      0.358128     58.992076 % 99     59.350204  10   942852 W       8      966535160         -4104 [kworker/u32:4]          0   0
108|  96: 96  10.822758277   -.----      0.024041    208.813188 % 99    208.837229  10   942852 W    1904      966436864        -98304 [kworker/u32:4]          0   0


Getting G event orphans which are causing at least some of this?

 51|  82: 82  10.970479078   -.----      0.266047      8.965727 % 97      9.231774  10   942852 W       8      966524376         26080 [kworker/u32:4]          0   0
 %E[07293]-orphan getrequest event detected, discarding '  8,16  10     6964    10.979712197 942852  G   W 966608896 + 2560 [kworker/u32:4]'; line=22974 (limit=400), QEvents=1187 (limit=200)
 %E[07293]-orphan getrequest event detected, discarding '  8,16  10     6968    10.979724974 942852  G   W 966611456 + 1536 [kworker/u32:4]'; line=22978 (limit=400), QEvents=1187 (limit=200)
:
:
 %E[07293]-orphan getrequest event detected, discarding '  8,16  10     7261    10.990541737 942852  G   W 966719488 + 2560 [kworker/u32:4]'; line=23271 (limit=400), QEvents=1214 (limit=200)
 %E[07293]-orphan getrequest event detected, discarding '  8,16  10     7265    10.990555546 942852  G   W 966722048 + 1536 [kworker/u32:4]'; line=23275 (limit=400), QEvents=1214 (limit=200)
108| 102:102  10.812634578   -.----      0.024063    192.019400 % 99    192.043463  10   942852 W    2040      966346752       -177632 [kworker/u32:4]          0   0
108| 101:101  10.816003326   -.----      0.023911    212.615223 % 99    212.639134  10   942852 W    2040      966375424         26632 [kworker/u32:4]          0   0

Cause appears that x-split created io length > MAX_IO_SIZE (2048), but there can be multiple nested io with cascading 
splits.


--bgn:018241-----------------------------------------      1:     189
  8,16  10     3079     8.310617934 942852  X   W 965515264 / 965517824 [kworker/u32:4]
DBG[03304]: verify_staged_list(ok:1)
DBG[03305]: verify_mainio_list
DBG[03305]: verify_mainio_list(ok:189)
DBG[12463]: split_event(this:965515264:  2561,split:965517824)
DBG[07698]: stage list    965515264:      4096 0x269fef0 | [00018239]   8.310609110 A    W
DBG[07702]: stage list    965515264:      4096 0x269fef0 matched!
DBG[07714]: stage list  965515264:  4096 0x269fef0 passed filters!
DBG[07719]: stage list  0x269fef0  965515264:  4096... <= 1st hit
DBG[07748]: stage list  0x269fef0 returned.
DBG[12475]: found event for X Split [ 18241] 965515264 => 965515264 : 4096
DBG[12583]: 1st io size 2560 is < 0 or > 2048 (MAX_IO_SIZE)					<< 2560 larger than MAX_IO_SIZE, so reset to just 512
DBG[12591]: split_event() default 1st split to 512						<< here, which is wrong and will result in orphaned io.
DBG[12610]: found X split 965515264/965517824 found target: 965515264,4096
DBG[12612]: existing io   965515264,4096 0x269fef0
DBG[12613]: adjusted io   965515776,3584 0x269fef0
DBG[13066]:                create_io(X W      965515264+965517824 '[kworker/u32:4]')
DBG[12621]: io->info 0x26a0250  split->info 0x26a0ac0
DBG[12622]: split    io   965517824,3584 0x26a0760
DBG[12623]: io 0x26a0760 GSeqNo 0 (split)
DBG[12642]: orig.2   io   965515776,3584 0x269fef0
DBG[12643]: split    io   965515264,512 0x26a0760
DBG[12672]: major:  8 QSeqNo:  904 XSeqNo: 2086 GSeqNo: 2976 ISegNo:   35 DSegNo: 2975 CSeqNo: 2787
DBG[12951]: event used. not discarded.
  8,16  10     3079     8.310617934 942852  X   W 965515264 / 965517824 [kworker/u32:4]           ;#P1          904          0          0|   2| 189:   0, 189| 188:   0, 188|-
--end------------------------------------------------

Fix: increase max io size from 2048 (1M) to 8192 (4M) to get through split logical.
     consider adding a warning or error at D or C time if the io length > some max io size value

This stopped the orphans in pre-stage due to new/incorrect size (512) being applied to io instead of actual value.
Added %E in output file if this happens again (forcing size to a smaller default value)


*/

/*
 * Weird, these are from the same system but one is sane, the other is crap.
 *

The sdb device: (sane)

  8,16  11       12     0.095032260 942852  A   W 961742848 + 4096 <- (8,17) 961740800	[A.0]
  8,16  11       13     0.095033587 942852  Q   W 961742848 + 4096 [kworker/u32:4]

                                                  A.0         A.1, A.1-A.0 = 1024 sectors
  8,16  11       14     0.095038620 942852  X   W 961742848 / 961743872 [kworker/u32:4] [A.1] split off, 1024
  8,16  11       15     0.095040118 942852  G   W 961742848 + 1024 [kworker/u32:4]	[A.0] request created
  8,16  11       17     0.095042902 942852  D   W 961741824 + 1024 [kworker/u32:4]      [A.0] dispatched
  
  8,16  11       19     0.095055397 942852  X   W 961743872 / 961744896 [kworker/u32:4] [A.2] split off
  8,16  11       20     0.095055958 942852  G   W 961743872 + 1024 [kworker/u32:4]	[A.1] request created
  8,16  11       22     0.095056665 942852  D   W 961742848 + 1024 [kworker/u32:4]	[A.1] dispatched

  8,16  11       24     0.095066629 942852  X   W 961744896 / 961745920 [kworker/u32:4] [A.3] split off
  8,16  11       25     0.095067166 942852  G   W 961744896 + 1024 [kworker/u32:4]      [A.2] request created 
  8,16  11       27     0.095067905 942852  D   W 961743872 + 1024 [kworker/u32:4]	[A.2] dispatched

  8,16  11       29     0.095077441 942852  G   W 961745920 + 1024 [kworker/u32:4]	[A.3] split off
  8,16  11       31     0.095078274 942852  D   W 961744896 + 1024 [kworker/u32:4]	[A.3] dispatched
  :
  later these will complete.

So the split sector/sector is valid in all instances of above as shown, original sector, split sector are valid.

Now sdc device: (crap) int the the original sector is ok, but the split sector number is seriously in error.

  8,32  10        3     0.092621501 1247318  A   W 20517185536 + 4096 <- (8,33) 20517183488	[A.0]
  8,32  10        4     0.092623143 1247318  Q   W 20517185536 + 4096 [kworker/u32:2]

                                                   A.0           A.1  A.1-A. = −17179868160  ... the split off io starting sector is wrong. big time.
  8,32  10        5     0.092629343 1247318  X   W 20517185536 / 3337317376 [kworker/u32:2]     [A.1]
  8,32  10        6     0.092632460 1247318  G   W 20517185536 + 1024 [kworker/u32:2]		... from here we can compute the real starting sector was 20517186560
  8,32  10        8     0.092637070 1247318  D   W 20517184512 + 1024 [kworker/u32:2]

  8,32  10       10     0.092654381 1247318  X   W 20517186560 / 3337318400 [kworker/u32:2]
  8,32  10       11     0.092655232 1247318  G   W 20517186560 + 1024 [kworker/u32:2]
  8,32  10       13     0.092656177 1247318  D   W 20517185536 + 1024 [kworker/u32:2]

  8,32  10       15     0.092666453 1247318  X   W 20517187584 / 3337319424 [kworker/u32:2]
  8,32  10       16     0.092666973 1247318  G   W 20517187584 + 1024 [kworker/u32:2]
  8,32  10       18     0.092668097 1247318  D   W 20517186560 + 1024 [kworker/u32:2]

  8,32  10       20     0.092677788 1247318  G   W 20517188608 + 1024 [kworker/u32:2]
  8,32  10       22     0.092678608 1247318  D   W 20517187584 + 1024 [kworker/u32:2]

This one is much harder to fix in that we only can infer what the correct sector **should** have been
when we get to the G (or I or D) on the B.0 io and figure out what the X-split event should have listed
for the sector, this is a bug within the kernel somewhere.  

We could either add experimental code that postpones processing the of the X split until a G,I,D comes
along that accurately defines what the split sector should have been.  But this is very foreign to the
current model that processes each io as its presented.  The other option is to change the default 
io size from 512 to 1024 and that *may* then make this ok, but we'd have to fork off a split on our
guess of what the sector should be and if we guess wrong we just make the pre-stage orphan problem worse.
And we have to discard and replace the split sector number provided.  I have dim recollection that is
why I added the replacement size code to begin with. 

The other alternative is to mark the original io with an tentative, but incomplete X event.  And for G
event we try and match on the pre-stage queue and will find no exact match, then try a 2nd time for 
a match in range and one that has a tentative X event.  Then apply use the G,I,D event data to update 
and change the tentative/pending X event, process that, then process the G event which now will find a match.

Track the number of times we get clean straight up matches like in sdb data case and ones where we get
"dirty" matches like in sdc and report stats if there are any dirty matches.  Ugh, this could be painful
to code.  It also should be behind a conf_ flag with can change and turn off is we need to.


Using conf_default_xsplit_size to set a default size is 50/50 venture, so its just not enough on its own
to address this issue.

a) add 'io->original_length' to the io context.
b) add two flags, bad_xsplit and pending_xsplit within the io context
c) add an original_xsplit_sector to capture the bad sector info from X event in io context
d) add two global counts, bad_xsplit_count and good_xsplit_count.
e) add conf_default_split_size and change this from 512 to 1024 as default but local blktrace.conf can
   override as needed.



*/

/*
 * And yet another completely different type/sequence of blktrace taken at mpath/dm level -- which is pretty useless to 
 * begin with.
 *


253,11  77       15     1.440012999 65780  G  RS 506885120 + 16 [oracle_65780_oc]		READ-SYNC
253,11  77       16     1.440013400 65780  P   N [oracle_65780_oc]				NON-IO (Plug)
253,11  77       17     1.440014287 65780  I  RS 506885120 + 16 [oracle_65780_oc]
253,11  77       18     1.440014763 65780  U   N [oracle_65780_oc] 1				NON-IO (Unplug)
253,11  77       19     1.440015521 65780  D  RS 506885120 + 16 [oracle_65780_oc]
253,11  77       20     1.445336317     0  C  RS 506885120 + 16 [0]
253,11  77       21     1.445356750   398  C  NS 506885120 [0]					NON-IO-SYNC ??? Whatever that means, but it *is* 0.02ms after completion!
												but note as a non-io it does not include a length but does include a sector!?
												In some cases the 'N'one (non-io) includes information so sometimes associated
                                                                                                with ioctl, non-data movement commands i.e. not read and not write but some
                                                                                                other command that will send or recv data from disk. but in this case NS won't
                                                                                                match RS type of rest of context so is a new type of exception post complete.
                                                                                                but in this case the C RS seems to cover the whole original io and its not split
                                                                                                so C RS will complete the io, output the result and flush the io context from the
                                                                                                tracking queues. ugh.

blktrace_merge: blktrace_parse.v4.c:10768: getreq_event: Assertion `io->info->GSeqNo == 0' failed.
/home/username/.bin/.local/blktrace_parse.bsh: line 435: 258289 Aborted                 (core dumped) $_cmdparse $1.blktrace.txt $1.blktrace.$_cmdfile.txt $_logflag > $_logfile

        if (io->info->GSeqNo != 0)
        {
            /- This is rare, but can happen because of multiple io for the same sector:length -/
            printf( "%%F[%05d]- io %p GSeqNo already set for this io, double 'G' events? %ld -> %ld\n", __LINE__, io, io->info->GSeqNo, state.GSeqNo+1 );
            dump_staged_list();
            dump_mainio_list();
            fflush(stdout);
            sleep(1);
            _assert(io->info->GSeqNo == 0);             /- should only ever be 1     -/
        }
        state.GSeqNo++;
        io->info->GSeqNo = state.GSeqNo;

The io context exists and has a G event already.  Happened pretty deep in the input file, another io is active with the same sector+size:

--bgn:011912-----------------------------------------      0:       1
253,11  86      141    29.916983900 60870  G  RS 492879872 + 32 [ora_tt02_oirb2]
DBG[03308]: verify_staged_list(ok:0)
DBG[03309]: verify_mainio_list
DBG[03309]: verify_mainio_list(ok:1)
DBG[10661]: search_staged1('G',3,492879872,32) 0000000000000000 found '(nil)'
DBG[07787]: mainio list[    1]  check for  492879872:    32 match for getrequest...
DBG[07793]: mainio list[    1]  0x2464170  492879872:    32... match!
DBG[07799]: mainio list[    1]  0x2464170  492879872:    32... passed other filters!
DBG[07806]: mainio list  0x2464170  492879872:    32... <= 1st hit
DBG[10720]: looking for @29.916983900:492879872+    32, found 29.916852280:492879872+    32 on mainio list
%F[10763]- io 0x2464170 GSeqNo already set for this io, double 'G' events? 1684 -> 1685

11732:253,11  29       50    29.769607765 49418  G  WS 492879872 + 32 [ora_lgwr_oirb2]
11734:253,11  29       52    29.769608539 49418  I  WS 492879872 + 32 [ora_lgwr_oirb2]
11736:253,11  29       54    29.769609095 49418  D  WS 492879872 + 32 [ora_lgwr_oirb2]
11737:253,11  29       55    29.770182381     0  C  WS 492879872 + 32 [0]
11738:253,11  29       56    29.770208921     0  C  WS 492879872 [0]

11900:253,11  17      169    29.909104674 60723  G  WS 492879872 + 32 [ora_arc0_oirb2]
11902:253,11  17      171    29.909105350 60723  I  WS 492879872 + 32 [ora_arc0_oirb2]
11904:253,11  17      173    29.909106449 60723  D  WS 492879872 + 32 [ora_arc0_oirb2]
11905:253,11  17      174    29.909686800     0  C  WS 492879872 + 32 [0]
11906:253,11  17      175    29.909692934     0  C  WS 492879872 [0]

11907:253,11  57       78    29.916852280 94244  G  RS 492879872 + 32 [ora_tt04_oirb2]
11909:253,11  57       80    29.916853650 94244  I  RS 492879872 + 32 [ora_tt04_oirb2]
11911:253,11  57       82    29.916854962 94244  D  RS 492879872 + 32 [ora_tt04_oirb2]

11912:253,11  86      141    29.916983900 60870  G  RS 492879872 + 32 [ora_tt02_oirb2]	<< 2nd identical io for same sector as same time before previous one completed. ugh.
11914:253,11  86      143    29.916984931 60870  I  RS 492879872 + 32 [ora_tt02_oirb2]
11916:253,11  86      145    29.917001361 60870  D  RS 492879872 + 32 [ora_tt02_oirb2]

11917:253,11  57       83    29.917272869     0  C  RS 492879872 + 32 [0]
11918:253,11  57       84    29.917288770   298  C  NS 492879872 [0]
11924:253,11  86      146    29.917443215     0  C  RS 492879872 + 32 [0]
11925:253,11  86      147    29.917451570     0  C  NS 492879872 [0]

The only thing we can do is treat this as a duplicate io, which is bad and should not happen. Or I can manually remove it to avoid having to change the program
to deal with these truncated event stream.  There were just two instances of this type of overlapping simultaneous io.  With normal devices its covered as a 
special corner case.  But here its a truncated sequence without the io ever being on the pre-stage queue.  So easier to just remove.


Furthermore as *ALL* io start with G vs normal A|Q they are labeled ghosts and all ghosts are not counted towards stats so no per second summary.  Possibly
need a setable mode whereby ghosts are counted into stats summary.  They aren't normally because if mixed in with non-ghosts they can seriously skew the
stats averaging due to missing events.


*/

/*

 %I[03672]-100000057 of 1264537359 bytes read (%  7.91)

Should include current runtime and new projected completion time.

*/



/* +++EOF+++ */












